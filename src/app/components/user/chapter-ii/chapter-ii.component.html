<div style="margin: 50px;">
    <ng-container *ngIf="(asyncTabs | async) === null">
        Loading tabs...
    </ng-container>
    <table>
        <tr>
            <td>
                <h1><b> CAPÍTULO 2 ALGORITMOS Y ESTRUCTURAS DE CONTROL EN LENGUAJE C/C++
                </b></h1>
            </td>
            <td></td>
            <td>
                <a href="https://drive.google.com/uc?id=1yQtGhmytRdEwydcquFPeafxYunAMHTux&export=download" download="Capitulo12021">
                    <mat-icon>cloud_download</mat-icon>Descargar Archivo Capítulo II
                </a>
            </td>
        </tr>
    </table>

    <mat-tab-group [selectedIndex]="selectedIndex.value" (selectedIndexChange)="selectedIndex.setValue($event)">
        <mat-tab label="Introducción">
            <ng-template matTabContent>
              <br>
              <h1>Introducción</h1>
              <p>En este capítulo se aprenderán a diseñar algoritmos y a utilizar la computadora como una herramienta para resolver problemas creando programas con estructuras de control en el lenguaje C/C++. Para la solución de problemas de programación se aplican aspectos de Ingeniería de Software y el método científico que permiten identificar a la programación con un enfoque sistemático. 
              </p>
              <p>
                En un programa estructurado el flujo lógico se gobierna por tres estructuras de control básicas: a) estructuras secuenciales; b) estructuras de decisión; c) estructuras repetitivas. El estudio de las estructuras de control se realiza en base al diseño de algoritmos y a la creación de programas en un lenguaje de programación estructurado como es el Lenguaje C/C++.
              </p>
            </ng-template>
        </mat-tab>
        <mat-tab label="Objetivos">
            <ng-template matTabContent>
              <br>
                <h1>Objetivos</h1>
                <ul>
                    <li>Revisar los principales conceptos en torno a algoritmos y a estructuras de control.</li>
                    <li>Entender cómo trabajan los algoritmos y las estructuras de control y cómo se aplican con el lenguaje C/C++ en la construcción de programas.</li>
                    <li>Aprender a crear algoritmos en Pseudocódigo y en Lenguaje C/C++.</li>
                    <li>Diseñar y crear programas en lenguaje C/C++ utilizando algoritmos y estructuras de control.</li>
                    <li>Resolver casos de estudio con algoritmos y estructuras de control aplicadas al área matemática.</li>
                </ul>
                  </ng-template>
        </mat-tab>
      <mat-tab label="Algoritmo">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="2.1.1. Definición de Algoritmo">
              <ng-template matTabContent>
                <br>
              <h1>Definición de Algoritmo</h1>
              <p>Un algoritmo es un conjunto de pasos o instrucciones ordenadas y finitas que permiten resolver un problema (Joyanes,L., 2008). Etimológicamente hablando la palabra algoritmo proviene del latín, dixit algorithmus y este del griego arithmos, que significa número y también con la influencia del matemático persa Muhammad Al-Juarismi que vivió durante el siglo IX y alcanzó gran reputación por el enunciado de las reglas paso a paso para sumar, restar, multiplicar y dividir números decimales. Euclides, el gran matemático griego que vivió en el siglo IV antes de Cristo, inventó un método para encontrar el Máximo Común Divisor (MCD) de dos números en base a divisiones sucesivas. A Euclides y a Al-Juarismi se les consideran los padres de la algoritmia que es una ciencia que se dedica al estudio de los algoritmos.
              </p>
              </ng-template>
            </mat-tab>
            <mat-tab  label="2.1.2. Características de los Algoritmos">
              <ng-template matTabContent>
                <br>
                <h1>Características de los Algoritmos </h1>
                <p>
                  Un algoritmo tiene las siguientes tres características (Joyanes, L., 2008):
                </p>
                <br>
                <li><strong>Preciso: </strong>Un algoritmo debe definirse de manera rigurosa sin ambigüedades.
                </li>
                <li><strong>Definido: </strong>Si se sigue un algoritmo dos veces, se debe obtener el mismo resultado.</li>
                <li><strong>Finito: </strong>Un algoritmo debe terminar en algún momento.</li>
                <br>
                <p>
                  Considerando estas características un algoritmo puede tener elementos de entrada y debe producir un resultado claro y conciso, que puede ser escrito en un lenguaje de programación como C/C++.   
                </p>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.3. Etapas para la Solución de un Problema">
              <ng-template matTabContent>
                <br>
                <h1>Etapas para la Solución de un Problema</h1>
            
                <p>
                  Los Ingenieros en Sistemas en la industria de la computación han encontrado que la ingeniería y el método científico para la solución de problemas pueden ser adaptados para el desarrollo confiable de sistemas de software (Hanly, J., Koffman, E., Horvath, J., 1995). Desde hace varias décadas la Ingeniería de Software ha sido utilizada para identificar la programación con un enfoque sistemático (Pressman, R., 2010). En este capítulo se van a aplicar cuatro fases en la resolución de problemas de programación, considerando los aspectos de la ingeniería y el método científico dentro de cada fase.
                </p>
                <br>
                <ol type="1" style="font-weight: normal;" >
                  <li><strong>Análisis del Problema: </strong>En esta fase, se estudia la especificación del problema, se identifican las entradas y salidas requeridas. Se revisan los principios teóricos y científicos que se aplican en la solución de un problema y se listan las fórmulas o relaciones relevantes.</li>
                  <li><strong>Diseño del Algoritmo: </strong>En esta fase, se escribe el algoritmo y se lista los sub-problemas a detalle. Se puede aplicar el proceso llamado “divide y vencerás” (divide and conquer), donde el problema se divide en sub-problemas.</li>
                  <li><strong>Desarrollo y Codificación: </strong>En esta fase, se presenta la codificación del programa en Lenguaje C/C++, debidamente comentado y explicado conforme a los algoritmos diseñados, considerando la especificación de requerimientos, datos, constantes y fórmulas requeridas para resolver el problema.</li>
                  <li><strong>Implementación y Pruebas: </strong>En esta fase, se verifica que la solución del problema es correcta y el programa trabaja adecuadamente, para lo cual se corre el programa varias veces y se prueba con diferentes valores. Además, se pueden contemplar pruebas de escritorio del programa mostrando el funcionamiento de algunas partes del mismo o en su totalidad considerando los datos y los cálculos que se necesitan procesar.</li>
                </ol>

              </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.4. Programas y Algoritmos">
              <ng-template matTabContent>
                <br>
                <h1>Programas y Algoritmos</h1>
               
                <p>Un algoritmo como se mencionó en la sección 2.1.1, es un conjunto de pasos o instrucciones que se siguen para resolver un problema. Un programa implementa uno o más algoritmos y lo traduce a lenguaje máquina. Según Joyanes Aguilar, et al. (2005), un algoritmo se puede expresar de tres maneras: a) forma gráfica, utilizando un diagrama de flujo; b) pseudocódigo que es un lenguaje de descripción algorítmica; c) lenguaje de programación que es una manera explícita de representar un algoritmo. En este capítulo se van a diseñar algoritmos mediante pseudocódigo y se los van a implementar utilizando el Lenguaje de Programación C/C++.</p>
              <p>Los programas se pueden dividir en sub-programas utilizando funciones, de modo que la complejidad algorítmica se reduce a tener un solo programa completo, lo cual ayuda a mejorar el rendimiento del mismo. Esta práctica es muy utilizada y se conoce como refinamiento progresivo. De acuerdo con Wirth Niklaus (1971), un programa está formado por algoritmos y estructuras de datos.</p>
              <p>La programación como tal puede tener muchos enfoques o paradigmas de programación lo cual permite formular la resolución de un problema de diferentes formas. Los dos paradigmas de programación más utilizados son: a) Paradigma de Programación Estructurada, que permite mejorar la calidad, claridad y tiempo de desarrollo de un programa recurriendo al uso de subrutinas y estructuras de control; b) Paradigma de Programación Orientada a Objetos, que permite innovar la programación utilizando objetos que manipulan datos y diferentes mecanismos de abstracción como herencia y polimorfismo (Granizo E., 2016).</p>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.5. Pseudocódigo como Técnica de Representación de un Algoritmo">
              <ng-template matTabContent>
                <br>
                <h1>Pseudocódigo como Técnica de Representación de un Algoritmo</h1>
         
              <p>Pseudocódigo es un lenguaje de especificación o descripción de algoritmos. El uso de este lenguaje ayuda a la codificación de un programa de una manera relativamente fácil (Joyanes Aguilar, L., 2008). Este lenguaje nació en inglés y era un medio de representación básico de las estructuras de control de la programación estructurada. Actualmente, se lo puede utilizar también en español sustituyendo las palabras originales del idioma inglés. En esta obra de programación se utilizará la técnica del pseudocódigo para diseñar los algoritmos de los programas y el Lenguaje C/C++ para implementar los mismos.</p>
              <p>Por ejemplo, algunas de las palabras reservadas y operadores que maneja el Pseudocódigo son:</p>
            <ol>
                <li value="1">Leer (Read)</li>
                <li>Imprimir (Print/Write)</li>
                <li>Calcular (Calculate)</li>
                <li>Repetir (Repeat)</li>
                <li>Asignar a 'x', el valor de 'y':
                  <ul>
                    <li>	x &larr; y; (Opción 1)</li>
                  <li>	x := y; (Opción 2)</li>
                  <li>	x = y; (Opción 3)</li>
                  </ul>
                </li>
            </ol>  
                <p>En la sección 2.2 se presentará el algoritmo en Pseudocódigo y la implementación de programas en Lenguaje C/C++, utilizando estructuras de control secuenciales, selectivas y repetitivas. Además, se presentan varios Casos de Estudio donde se cumplen con las etapas para la solución de un problema, aplicando el método científico.</p>

            </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.6. Diseño Conceptual de Procesos Aplicado a Programas">
              <ng-template matTabContent>
                <br>
                <h1>Diseño Conceptual de Procesos Aplicado a Programas</h1>
               
                <p>Un proceso es un sistema formado por unidades, componentes o equipos interconectados en forma organizada para procesar, modificar o transformar las propiedades de elementos o corrientes de proceso en productos de interés (Mallar, M.A., 2010). Un proceso se puede representar por: a) Diagrama de Entrada-Salida (input-output); b) Diagrama de Bloques (operaciones principales); c) Diagrama de Flujos (Flowsheet); d) Diagrama de tuberías e instrumentación (PID).</p>
                <p>El Diagrama de Entrada-Salida (input-output) se utiliza para representar flujos de materiales considerando las entradas y salidas de los procesos de fabricación de un producto. En la Figura 2.1 se muestra un ejemplo de un Proceso Químico donde las entradas son: a) Recursos económicos; b) Materias primas; c) Energía; las salidas son: a) Recursos económicos; b) Productos; c) Energía; d) Residuos.</p>
                <br>
                <img src="./assets/images/Capitulos/II/media/Figura 2.1..png" style="display:block; margin:auto; "><br>
                
                <h5 style="text-align:center"><b>Figura 2.1. </b>Diagrama de Entrada-Salida de un Proceso Químico (Adaptado de: Arce, E., 2011).</h5>
                <br>
                <p>Este tipo de diagramas también se pueden utilizar para representar un programa como un proceso. Conceptualmente un programa puede ser considerado como una caja negra (Joyanes Aguilar, L., 2008), donde la caja negra es el proceso o algoritmo de resolución, las entradas y las auxiliares son un grupo de datos que van a ser procesados para obtener las salidas o resultados, como se puede ver en la Figura 2.2. En el resto de capítulos y lecciones se utilizará el Diagrama de Entrada-Salida para entender el funcionamiento de un algoritmo como un proceso.</p>
                <br>
                <img src="./assets/images/Capitulos/II/media/Figura 2.2..png" style="display:block; margin:auto; "><br>
                
                <h5 style="text-align:center"><b>Figura 2.2. </b>Diagrama de Entrada-Salida de un Programa (Adaptado de: Joyanes Aguilar, L., 2008).</h5>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.7. Aplicaciones de Algoritmos en la Vida Cotidiana">
              <ng-template matTabContent>
                <br>
                <h1>Aplicaciones de Algoritmos en la Vida Cotidiana</h1>
              
                <p>Un …………………..xyz</p>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.8. Estructuras de Control en Lenguaje C/C++">
              <ng-template matTabContent>
                <br>
                <h1>Estructura de Control en Lenguaje C/C++</h1>
               
                <p>Las estructuras de control permiten manejar y modificar el flujo de ejecución de las instrucciones de un programa (Granizo E., 2016). Entre las principales estructuras de control están:</p>
                <ol type="a">
                  <li>Estructuras de control secuenciales.</li>
                  <li>Estructuras de control selectivas.</li>
                  <li>Estructuras de control repetitivas.</li>
                </ol>
              </ng-template>
            </mat-tab>
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Estructuras de Control Secuenciales">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="Introducción">
              <ng-template matTabContent>
                <br>
               <h1>Estructuras de Control Secuenciales</h1>
              
               <p>La estructura de control secuencial es aquella en la que una instrucción se ejecuta a continuación de otra a modo de secuencia, es decir, una instrucción no se ejecuta hasta que finaliza la anterior (Joyanes Aguilar, L., 2008). Las operaciones se suceden de tal modo que la salida de una es la entrada de la siguiente y así sucesivamente hasta el fin del proceso. Los principales componentes de las estructuras de control secuenciales son:</p>
               <ol type="a">
                 <li>Escritura</li>
                 <li>Lectura</li>
                 <li>Asignación
                   <ul>
                     <li>Asignación Simple</li>
                     <li>Asignación Contador</li>
                     <li>Asignación Acumulador</li>
                     <li>Asignación de Trabajo</li>
                   </ul>
                 </li>
               </ol>
               </ng-template>
            </mat-tab>
            <mat-tab  label="2.2.1. Escritura">
              <ng-template matTabContent>
                <br>
                <h1>Escritura</h1>

                <p>La escritura consiste en enviar por un dispositivo de salida un resultado o mensaje. En la sección 1.4.1 se explica a detalle la función de escritura en el Lenguaje C/C++. Esta operación se puede representar mediante pseudocódigo y Lenguaje C/C++ como se indica a continuación: </p>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="200"> <b> Pseudocódigo </b> </th>
                    <th width="200"> <b> Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR>
                    <td><p>entero : a</p>
                    <p>a &#8592; 7</p>
                    <p>Imprimir 'a'</p></td>
                    <td> <p>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> a;</font></p>
                    <p>a=7;</p>
                    <p>cout 
                      <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font>
                       a;</p></td>
                  </TR>
                </TABLE>

              </ng-template>
            </mat-tab>
            <mat-tab  label="2.2.2. Lectura">
              <ng-template matTabContent>
                <br>
                <h1>Lectura</h1>
              
                <p>La lectura consiste en recibir desde un dispositivo de entrada un valor. En la sección 1.4.2 se explica a detalle la función de lectura en el Lenguaje C/C++. Esta operación se puede representar mediante pseudocódigo y Lenguaje C/C++ como se indica a continuación:</p>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="200"> <b> Pseudocódigo </b> </th>
                    <th width="200"> <b> Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR>
                    <td><p>entero : a</p>
                    <p>Leer 'a'</p></td>
                    <td> <p>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> a;</font></p>
                    <p>cin 
                      <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                       a;</p></td>
                  </TR>
                </TABLE><br>
                <p><b>Ejercicio 2.1: </b>Escribir un programa que permita sumar dos números enteros, para lo cual se puede utilizar la siguiente expresión matemática: num3 = num1 + num2, considerando que se deben utilizar tres variables.</p>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> 
                    <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                    <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR>
                    <td>1</td>  <td>entero : num1</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> num1;</font>
                    </td>
                  </TR>
                  <TR>
                    <td>2</td>
                    <td>entero : num2</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> num2;</font>
                    </td>
                  </TR>
                  <TR>
                    <td>3</td> <td>entero : num3</td> <td> 
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> num3;</font>
                    </td>
                  </TR>
                  <TR><td>4</td><td>Leer num1</td><td>cin <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font> num1;</td></TR>
                  <TR><td>5</td><td>Leer num1</td><td>cin <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font> num2;</td></TR>
                  <TR><td>6</td><td>num3 &#8592; num1 + num2</td><td>num3 = num1 + num2;</td></TR>
                  <TR><td>7</td><td>Imprimir mensaje: "Resultado de la suma: "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                    <font color="red">"Resultado de la suma: "</font>;</td></TR>
                  <TR><td>8</td><td>Imprimir num3</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> num3</td></TR>
                </TABLE>
                <br><h5><b>Programa 2.1.</b> Código del programa.</h5>
                <pre><code [highlight]="prefTab2[0].programa2_1"  [lineNumbers]="true"></code></pre><br>
                <p>La Ejecución 2.1, correspondiente a la salida del programa, muestra que al ingresar el primer número que es el 8 y el segundo número que es el 2, se obtiene la suma entre los dos números que es el 9.</p>
                <h5><b>Ejecución 2.2.</b>Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Ejecución 2.1.png" style="display:block; margin:auto; "><br>
                
              </ng-template>
            </mat-tab>
            <mat-tab  label="2.2.3. Asignación">
              <ng-template matTabContent>
                <br><h1>Asignación</h1>
                <p>La asignación consiste en el paso de valores a una zona de la memoria RAM, tal y como se describió en la sección 1.5.4 sobre el funcionamiento del operador de asignación igual. En la memoria RAM se almacenan temporalmente las variables que reciben valores de procesos lectura y de cálculos. La asignación se puede clasificar en cuatro tipos: a) Asignación simple; b) Asignación contador; c) Asignación acumulador; d) Asignación de trabajo.</p>
                <ol type="a">
                  <li><b>Asignación simple: </b>Esta asignación consiste en pasar un valor a una variable. Esta operación se puede representar mediante pseudocódigo y Lenguaje C/C++ como se indica a continuación:</li>
                </ol>
                <h4><b>Ejercicio 2.2: </b>Escribir un programa que permita probar la asignación simple, donde se asigna un valor a una variable, luego ese mismo valor se asigna a otra utilizando la misma variable y finalmente se imprime los valores de las dos variables. </h4>
                
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> 
                    <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                    <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR> <td>1</td>  <td>entero : a</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      a;</td>
                  </TR>
                  <TR>
                    <td>2</td>
                    <td>entero : b</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> b;</font>
                    </td>
                  </TR>
                  <TR><td>3</td> <td>a &#8592; 7 </td> <td>a=7;</td> </TR>
                  <TR><td>4</td><td>b &#8592; a</td><td>b=a;</td></TR>
                  <TR><td>5</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>6</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  <TR><td>7</td><td>Imprimir mensaje: "Valor de 'b': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                    <font color="red">"Valor de 'b': "</font>;</td></TR>
                  <TR><td>8</td><td>Imprimir b</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> b</td></TR>
                </TABLE> <br>
                <h5><b>Programa 2.2. </b> Código del programa</h5>
                <pre><code [highlight]="prefTab2[0].programa2_2"  [lineNumbers]="true"></code></pre><br>
               <p>La Ejecución 2.2, correspondiente a la salida del programa, muestra que al ingresar el valor igual a 7 en la variable ‘a’, se asigna este mismo valor a la variable ‘b’ y se imprimen sus valores.</p>
               <h4><b>Ejecución 2.2. </b>Salida del programa</h4>
               <img src="./assets/images/Capitulos/II/media/Ejecución 2.2.png" style="display:block; margin:auto; "><br>
                
               <ol type="a" start="2">
                  <li><b>Asignación Contador: </b>Esta asignación consiste en usarla como un verificador del número de veces que se realiza un proceso. Esta operación se puede representar mediante pseudocódigo y Lenguaje C/C++ como se indica a continuación:</li>
                </ol>
                <h4><b>Ejercicio 2.3: </b>Escribir un programa que permita contar desde el uno hasta el cinco, utilizando un contador, donde inicialmente se le asigna el valor de cero a la variable que opera como contador, luego se utiliza este contador para contar hasta cinco y también se imprimen los valores del mismo.</h4>
                
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th><th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR> <td>1</td>  <td>entero : a</td><td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font> a;</td>
                  </TR>
                  <TR>
                    <td>2</td><td>a &#8592; 0</td><td>a=0;</td>
                  </TR>
                  <TR><td>3</td> <td>a &#8592; a+1 </td> <td>a=a+1;</td> </TR>
                  <TR><td>4</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>5</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  <TR><td>6</td> <td>a &#8592; a+1 </td> <td>a = a+1;</td> </TR>
                  <TR><td>7</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>8</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  <TR><td>9</td> <td>a &#8592; a+1 </td> <td>a = a+1;</td> </TR>
                  <TR><td>10</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>11</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  <TR><td>12</td> <td>a &#8592; a+1 </td> <td>a = a+1;</td> </TR>
                  <TR><td>13</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>14</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  <TR><td>15</td> <td>a &#8592; a+1 </td> <td>a = a+1;</td> </TR>
                  <TR><td>16</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>17</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  
                </TABLE> <br>
                <h5><b>Programa 2.3. </b> Código del programa</h5>
                <pre><code [highlight]="prefTab2[0].programa2_3"  [lineNumbers]="true"></code></pre><br>
                <p>La Ejecución 2.3, correspondiente a la salida del programa, muestra que el valor del contador ‘a’ varía entre uno y cinco.</p>
                <h4><b>Ejecución 2.3. </b>Salida del programa</h4>
                <img src="./assets/images/Capitulos/II/media/Ejecución 2.3.png" style="display:block; margin:auto; "><br>

                <ol type="a" start="3">
                  <li><b>Asignación Acumulador: </b>Esta asignación consiste en usarla como un sumador o un producto en un proceso. </li>
                  <ul>
                    <li>Un sumador generalmente se inicializa con el neutro aditivo que es el valor de cero y se aplica la siguiente fórmula: sum = sum + valor; donde el valor depende de lo que se quiere acumular.</li>
                    <li>Un producto generalmente se inicializa con el neutro multiplicativo que es el valor de uno y se aplica la siguiente fórmula: prod = prod * valor; donde el valor depende de lo que se quiere acumular.</li>
                  </ul>
                  Estas operaciones se pueden representar mediante pseudocódigo y Lenguaje C/C++ como se indican a continuación en los siguientes ejercicios:
                </ol>
                <h4><b>Ejercicio 2.4: </b>Escribir un programa que permita realizar la sumatoria de los cinco primeros dígitos, es decir, 1+2+3+4+5, utilizando cinco variables y un acumulador de sumas. A cada variable se le asigna uno de los dígitos y luego se le asigna al acumulador cada variable, para finalmente imprimir el valor del acumulador.</h4>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> 
                    <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                    <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR> <td>1</td>  <td>entero : n1</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n1;</td>
                  </TR>
                  <TR> <td>2</td>  <td>entero : n2</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n2;</td>
                  </TR>
                  <TR> <td>3</td>  <td>entero : n3</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n3;</td>
                  </TR>
                  <TR> <td>4</td>  <td>entero : n4</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n4;</td>
                  </TR>
                  <TR> <td>5</td>  <td>entero : n5</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n5;</td>
                  </TR>
                  <TR> <td>6</td>  <td>entero : sum</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      sum;</td>
                  </TR>
                  <TR><td>7</td> <td>n1 &#8592; 1 </td> <td>n1 = 1;</td> </TR>
                  <TR><td>8</td> <td>n2 &#8592; 2 </td> <td>n2 = 2;</td> </TR>
                  <TR><td>9</td> <td>n3 &#8592; 3 </td> <td>n3 = 3;</td> </TR>
                  <TR><td>10</td> <td>n4 &#8592; 4 </td> <td>n4 = 4;</td> </TR>
                  <TR><td>11</td> <td>n5 &#8592; 5 </td> <td>n5 = 5;</td> </TR>
                  <TR><td>12</td><td>sum &#8592; 0</td><td>sum = 0;</td></TR>
                  <TR><td>13</td><td>sum &#8592; sum + n1</td><td>sum = sum + n1;</td></TR>
                  <TR><td>14</td><td>sum &#8592; sum + n2</td><td>sum = sum + n2;</td></TR>
                  <TR><td>15</td><td>sum &#8592; sum + n3</td><td>sum = sum + n3;</td></TR>
                  <TR><td>16</td><td>sum &#8592; sum + n4</td><td>sum = sum + n4;</td></TR>
                  <TR><td>17</td><td>sum &#8592; sum + n5</td><td>sum = sum + n5;</td></TR>
                  <TR><td>18</td><td>Imprimir mensaje: "Valor del acumulador 'sum': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor del acumulador 'sum': "</font>; </td></TR>
                  <TR><td>19</td><td>Imprimir 'sum'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> sum;</td></TR>
                </TABLE> <br>

                <h5><b>Programa 2.4. </b> Código del programa</h5>
                <pre><code [highlight]="prefTab2[0].programa2_4"  [lineNumbers]="true"></code></pre><br>
                <p>La Ejecución 2.4, correspondiente a la salida del programa, muestra que la variable ‘sum’ tiene acumulado el valor de 15 que representa la sumatoria de los cinco primeros dígitos.</p>
                <h4><b>Ejecución 2.4. </b>Salida del programa</h4>
                <img src="./assets/images/Capitulos/II/media/Ejecución 2.4.png" style="display:block; margin:auto; "><br>

                <h4><b>Ejercicio 2.5: </b>Escribir un programa que permita realizar el producto de los cinco primeros dígitos, es decir, 1*2*3*4*5, utilizando cinco variables y un acumulador de productos. A cada variable se le asigna uno de los dígitos y luego se le asigna al acumulador cada variable, para finalmente imprimir el valor del acumulador.</h4>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> 
                    <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                    <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR> <td>1</td>  <td>entero : n1</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n1;</td>
                  </TR>
                  <TR> <td>2</td>  <td>entero : n2</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n2;</td>
                  </TR>
                  <TR> <td>3</td>  <td>entero : n3</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n3;</td>
                  </TR>
                  <TR> <td>4</td>  <td>entero : n4</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n4;</td>
                  </TR>
                  <TR> <td>5</td>  <td>entero : n5</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n5;</td>
                  </TR>
                  <TR> <td>6</td>  <td>entero : prod</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      prod;</td>
                  </TR>
                  <TR><td>7</td> <td>n1 &#8592; 1 </td> <td>n1 = 1;</td> </TR>
                  <TR><td>8</td> <td>n2 &#8592; 2 </td> <td>n2 = 2;</td> </TR>
                  <TR><td>9</td> <td>n3 &#8592; 3 </td> <td>n3 = 3;</td> </TR>
                  <TR><td>10</td> <td>n4 &#8592; 4 </td> <td>n4 = 4;</td> </TR>
                  <TR><td>11</td> <td>n5 &#8592; 5 </td> <td>n5 = 5;</td> </TR>
                  <TR><td>12</td><td>prod &#8592; 0</td><td>prod = 0;</td></TR>
                  <TR><td>13</td><td>prod &#8592; prod * n1</td><td>prod = prod * n1;</td></TR>
                  <TR><td>14</td><td>prod &#8592; prod * n2</td><td>prod = prod * n2;</td></TR>
                  <TR><td>15</td><td>prod &#8592; prod * n3</td><td>prod = prod * n3;</td></TR>
                  <TR><td>16</td><td>prod &#8592; prod * n4</td><td>prod = prod * n4;</td></TR>
                  <TR><td>17</td><td>prod &#8592; prod * n5</td><td>prod = prod * n5;</td></TR>
                  <TR><td>18</td><td>Imprimir mensaje: "Valor del acumulador 'prod': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor del acumulador 'prod': "</font>; </td></TR>
                  <TR><td>19</td><td>Imprimir 'prod'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> prod;</td></TR>
                </TABLE> <br>
                <h5><b>Programa 2.5. </b> Código del programa</h5>
                <pre><code [highlight]="prefTab2[0].programa2_5"  [lineNumbers]="true"></code></pre><br>
                <p>La Ejecución 2.5, correspondiente a la salida del programa, muestra que la variable ‘prod’ tiene acumulado el valor de 120 que representa el producto de los cinco primeros dígitos.</p>
                <h4><b>Ejecución 2.5. </b>Salida del programa</h4>
                <img src="./assets/images/Capitulos/II/media/Ejecución 2.5.png" style="display:block; margin:auto; "><br>

                <ol type="a" start="4">
                  <li><b>Asignación de Trabajo: </b>Esta asignación consiste en recibir el resultado de una operación o fórmula matemática que involucre muchas variables. Esta operación se puede representar mediante pseudocódigo y Lenguaje C/C++ como se indica a continuación:</li>
                </ol>
                <h4><b>Ejercicio 2.6: </b>Escribir un programa que permita probar la siguiente expresión matemática: d = (a * c) + (c / 2), para lo cual se deben utilizar cuatro variables, donde las variables ‘a’, ‘b’ y ‘c’ tienen los valores de 5, 2 y 7 respectivamente.</h4>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> 
                    <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                    <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR> <td>1</td>  <td>entero : a</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      a;</td>
                  </TR>
                  <TR> <td>2</td>  <td>entero : b</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      b;</td>
                  </TR>
                  <TR> <td>3</td>  <td>entero : c</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      c;</td>
                  </TR>
                  <TR> <td>4</td>  <td>entero : d</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      d;</td>
                  </TR>
                  <TR><td>5</td> <td>a &#8592; 5 </td> <td>a = 5;</td> </TR>
                  <TR><td>6</td> <td>b &#8592; 2 </td> <td>b = 2;</td> </TR>
                  <TR><td>7</td> <td>c &#8592; 7 </td> <td>c = 7;</td> </TR>
                  <TR><td>8</td> <td>d &#8592; (a*c) + (c/2) </td> <td>d = (a*c) + (c/2) ;</td> </TR>
                  <TR><td>9</td><td>Imprimir mensaje: "Valor de la expresión 'd': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de la expresión 'd': "</font>; </td></TR>
                  <TR><td>10</td><td>Imprimir 'd'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> d;</td></TR>
                </TABLE> <br>
                <h5><b>Programa 2.6. </b> Código del programa</h5>
                <pre><code [highlight]="prefTab2[0].programa2_6"  [lineNumbers]="true"></code></pre><br>
                <p>La Ejecución 2.6, correspondiente a la salida del programa, muestra que el valor de la expresión matemática evaluada es igual a 38.</p>
                <h4><b>Ejecución 2.6. </b>Salida del programa</h4>
                <img src="./assets/images/Capitulos/II/media/Ejecución 2.6.png" style="display:block; margin:auto; "><br>

              </ng-template>
            </mat-tab>
            <mat-tab  label="2.2.4. Casos de Estudio">
              <ng-template matTabContent>
                <br>
                <h1><b>Caso de Estudio 2.1: Encontrar el Perímetro y el Área de un Círculo.</b></h1>
                <h2><b>A) Problema</b></h2>
                <p>Escribir un programa para calcular e imprimir el perímetro y el área de un círculo. (Ver Figura 2.1.1)</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.1.1.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.1.1. </b>El círculo y sus fórmulas</h5>
                
                <h2><b>B) Análisis</b></h2>
                <p>Claramente, se puede ver que la entrada del problema es el radio del círculo. Hay dos salidas requeridas: el perímetro y el área del círculo. Partiendo de un conocimiento básico de geometría, se sabe que hay una relación entre el radio del círculo con el perímetro y con el área de la figura geométrica. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
                <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Constante del Problema</b></p>
                <p>PI=3.141596</p>
                <p><b>Entradas del Problema</b></p>
                <table>
                  <tr><td width="200">radio</td><td width="200">/* radio del círculo */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200">perímetro</td><td width="200">/* perímetro del círculo */</td></tr>
                  <tr><td>área</td><td>/* área del círculo */</td></tr>
                </table><br>
                <p><b>Fórmulas Relevantes</b></p>
                <table>
                  <tr><td width="60"><em>P= 2 &pi; r</em></td><td width="30"> (1) </td><td width="270">/* Fórmula del perímetro de un círculo */</td></tr>
                  <tr><td ><em>A=&pi; r <sup>2</sup></em></td><td> (2) </td><td>/* Fórmula del área de un círculo */</td></tr>
                  
                </table> <br>
                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.1.2 se muestra el Diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘radio’; b) Salidas: las variables ‘perimetro’ y ‘area’; c) Auxiliares: la constante PI.</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.1.2.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.1.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <br>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                <p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el radio del círculo.</li>
                  <li>Calcular el perímetro.</li>
                    <ol type="1" start="2">
                      <li>1. Asignar el producto de dos veces PI por el radio a la variable ‘perimetro’.</li>
                    </ol>
                  <li>Calcular el área.</li>
                  <ol type="1" start="3">
                    <li>1.	Asignar el producto de PI por el cuadrado del radio a la variable ‘area’.</li>
                  </ol>
                  <li>Imprimir el valor de la variable 'perímetro' y de la variable 'área'</li>
                </ol>
                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.1.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.1.1. </b>Programa que calcula el perímetro y el área del círculo.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_1_1"  [lineNumbers]="true"></code></pre>
                <br>
                <h2>E) Pruebas</h2>
                <p>La Tabla 2.1.2 muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora, donde como se puede ver en la siguiente salida del programa, se le pide al usuario que ingrese un valor para el radio que puede ser ‘5’ y el programa calcula los valores del perímetro y del área como son ‘31.41’ y ‘78.53’ respectivamente.</p>
                <h5><b>Tabla 2.1.2.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.1.2.png" style="display:block; margin:auto; "><br>
                
                <h1><b>Caso de Estudio 2.2: Encontrar el Perímetro y el Área de un Rectángulo.</b></h1>
                <h2><b>A) Problema</b></h2>
                <p>Escribir un programa para calcular e imprimir el perímetro y el área de un rectángulo. (Ver Figura 2.2.1)</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.2.1.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.2.1. </b>El rectángulo y sus fórmulas</h5>
                <h2><b>B) Análisis</b></h2>
                <p>Claramente, se puede ver que las entradas del problema son el ancho y el largo del rectángulo. Hay dos salidas requeridas: el perímetro y el área del rectángulo. Partiendo de un conocimiento básico de geometría, se sabe que hay una relación entre el ancho y el largo del rectángulo con el perímetro y con el área de la figura geométrica. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
                <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Entradas del Problema</b></p>
                <table>
                  <tr><td width="200">ancho</td><td width="200">/* ancho del rectángulo */</td></tr>
                  <tr><td width="200">largo</td><td width="200">/* largo del rectángulo */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200">perímetro</td><td width="200">/* perímetro del rectángulo  */</td></tr>
                  <tr><td width="200">área</td><td width="200">/* área del rectángulo */</td></tr>
                </table><br>
                <p><b>Fórmulas Relevantes</b></p>
                <table>
                  <tr><td width="70"><em>P= 2a + 2b</em></td><td width="30"> (1) </td><td width="280">/* Fórmula del perímetro de un rectángulo */</td></tr>
                  <tr><td ><em>A= ab <sup>2</sup></em></td><td> (2) </td><td>/* Fórmula del área de un rectángulo */</td></tr>
                </table> <br>
                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.2.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas y salidas del problema como son: a) Entradas: las variables ‘ancho’ y ‘largo’; b) Salidas: las variables ‘perimetro’ y ‘area’.</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.2.2.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.2.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                <p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el ancho del rectángulo.</li>
                  <li>Leer el largo del rectángulo.</li>
                  <li>Calcular el perímetro.</li>
                  <ol type="1"  start="3">
                    <li>1. Asignar el producto de dos veces el ancho por dos veces el largo a la variable ‘perimetro’.</li>
                  </ol>
                  <li>Calcular el área.</li>
                  <ol type="1" start="4">
                    <li>1. Asignar el producto del ancho por el largo a la variable ‘area’.</li>
                    
                  </ol>
                  <li>Imprimir el valor de la variable ‘perimetro’ y de la variable ‘area’.</li>
                </ol>

                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.2.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.2.1. </b>Programa que calcula el perímetro y el área del rectángulo.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_2_1"  [lineNumbers]="true"></code></pre>
                <br>
                <h2>E) Pruebas</h2>
                <p>La Tabla 2.2.2 muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <h5><b>Tabla 2.2.2. </b>Salida del programa.</h5>

                <img src="./assets/images/Capitulos/II/media/Tabla 2.2.2.png" style="display:block; margin:auto; "><br>
                
                <h1><b>Caso de Estudio 2.3: Encontrar la Generatriz, el Área y el Volumen de un Cono.</b> </h1>
                
                <h2><b>A) Problema</b></h2>
                <p>Escribir un programa para calcular e imprimir la generatriz, el área y el volumen de un cono. (Ver Figura 2.2.1)</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.3.1.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.2.1. </b>El Cono y sus fórmulas.</h5>
                <h5></h5>
                <h2><b>B) Análisis</b></h2>
                <p>Claramente, se puede ver que las entradas del problema son el radio y la altura del cono. Hay tres salidas requeridas: la generatriz, el área y el volumen del cilindro. Partiendo de un conocimiento básico de geometría, se sabe que hay una relación entre el radio y la altura del rectángulo con la generatriz, con el área y con el volumen de la figura geométrica. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
                <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Constante del Problema</b></p>
                <p>PI=3.141596</p>
                <p><b>Entradas del Problema</b></p>
                <table>
                  <tr><td width="200">r</td><td width="200">/* radio del Cono */</td></tr>
                  <tr><td width="200">h</td><td width="200">/* altura del cono */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200">perímetro</td><td width="200">/* generatriz del cono  */</td></tr>
                  <tr><td width="200">área</td><td width="200">/* área del cono*/</td></tr>
                  <tr><td>volumen</td><td>/* volumen del cono */</td></tr>
                </table><br>

                <p><b>Fórmulas Relevantes</b></p>
                <table>
                  <tr><td width="120"><em>g= &#8730;(r<sup>2</sup> + h<sup>2</sup> ) </em></td><td width="30"> (1) </td><td width="280">/* Fórmula de la generatriz de un cono */</td></tr>
                  <tr><td ><em>A= &pi;∙r∙g + &pi;∙r<sup>2</sup></em></td><td> (2) </td><td>/* Fórmula del área de un cono */</td></tr>
                  <tr><td><em>V= <sup>1</sup>/<sub>3</sub> &pi;∙r<sup>2</sup>∙h</em></td><td>(3)</td> <td>/* Fórmula del volumen de un cono */</td></tr>
                </table> <br>

                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.3.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘r’ (radio) y la variable ‘h’ (altura); b) Salidas: las variables ‘g’ (generatriz), ‘area’ y ‘volumen’; c) Auxiliares: la constante PI.</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.3.2.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.3.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h3><b>B.3) Diagrama de Proceso</b></h3>
                <p>En la Figura 2.3.2 se muestra el diagrama de procesos del problema donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘r’ (radio) y la variable ‘h’ (altura); b) Salidas: las variables ‘g’ (generatriz), ‘area’ y ‘volumen’; c) Auxiliares: la constante PI.</p>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                <p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el radio del cono, utilizando la variable ‘r’.</li>
                  <li>Leer la altura del cono, utilizando la variable ‘h’.</li>
                  <li>Calcular la generatriz del cono.</li>
                  <ol type="1" start="3">
                    <li>1. Asignar la raíz cuadrada de la suma del cuadrado del radio más el cuadrado de la altura (‘h’), a la variable ‘g’ (generatriz).</li>
                  </ol>
                  <li>Calcular el área.</li>
                  <ol type="1" start="4">
                    <li>1. Asignar la suma entre el producto de PI por el radio y por la altura más el producto de PI por el cuadrado del radio, a la variable ‘area’.</li>
                    
                  </ol>
                  <li>Calcular el volumen.</li>
                  <ol type="1" start="5">
                    <li>1. Asignar el producto de un tercio por PI por el cuadrado del radio y por la altura, a la variable ‘volumen’.</li>
                  </ol>
                  <li>Imprimir el valor de la variable ‘g’ (generatriz), de la variable ‘area’ y de la variable ‘volumen’.</li>
                </ol>


                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.3.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.3.1. </b>Programa que calcula la generatriz, el área y el volumen del cono.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_3_1"  [lineNumbers]="true"></code></pre> <br>
                <h2>E) Pruebas</h2>
                <p>La Tabla 2.3.2 muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <h5><b>Tabla 2.3.2.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.3.2.png" style="display:block; margin:auto; "><br>
                
                <h1><b>Caso de Estudio 2.4: Encontrar la distancia, tiempo de vuelo y la altura alcanzada por un proyectil.</b> </h1>
                <h2><b>A) Problema</b></h2>
                <p>Escribir un programa para calcular e imprimir la distancia ‘d’, el tiempo de vuelo ‘t’ y la altura ‘h’ alcanzada por un proyectil que es disparado con un ángulo θ (‘theta’) en grados con respecto a la horizontal y a una velocidad inicial ‘v’ en m/seg. La trayectoria parabólica del proyectil se muestra en la Figura 2.4.1 y cuyas fórmulas son las siguientes:</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.4.1.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.4.1. </b>Tiro Parabólico de un Proyectil.</h5>
                <h5></h5>
                <h2><b>B) Análisis</b></h2>
                <p>Claramente, se puede ver que las entradas del problema son la velocidad inicial de lanzamiento del proyectil y el ángulo de lanzamiento theta en grados. Hay tres salidas requeridas: el tiempo de vuelo, la distancia y la altura alcanzada por un proyectil. Partiendo de un conocimiento básico de Física, se sabe que hay una relación entre la velocidad y el ángulo de lanzamiento con la distancia, el tiempo de vuelo y la altura. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
                <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Constante del Problema</b></p>
                <p>PI= 3.141596</p>
                <p>g= 9.8</p>
                <p><b>Entradas del Problema</b></p>
                <table>
                  <tr><td width="200">v</td><td width="200">/* velocidad de lanzamiento  */</td></tr>
                  <tr><td width="200">theta</td><td width="200">/* ángulo de lanzamiento  */</td></tr>
                </table>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200">d</td><td width="200">/* distancia alcanzada por el proyectil */</td></tr>
                  <tr><td width="200">t</td><td width="200">/* tiempo de vuelo */</td></tr>
                  <tr><td>h</td> <td>/* altura alcanzada por el proyectil */</td></tr>
                </table>

                <p><b>Fórmulas Relevantes</b></p>
                <table>
                  <tr><td width="100"><em>d=(v<sup>2</sup>∙sen(2θ))/g</em></td><td width="30"> (1) </td><td width="280">/* Fórmula de la distancia alcanzada por el proyectil */</td></tr>
                  <tr><td ><em>t=(v∙sen(2θ))/g</em></td><td> (2) </td><td>/* Fórmula del tiempo de vuelo del proyectil */</td></tr>
                  <tr><td><em>h=(v<sup>2</sup>∙sen<sup>2</sup>(θ))/g</em></td><td>(3)</td><td>/* Fórmula de la altura alcanzada por el proyectil */</td></tr>
                </table><br>

                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.4.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘v’ (velocidad) y la variable ‘theta’ (ángulo); b) Salidas: las variables ‘d’ (distancia), ‘t’ (tiempo) y ‘h’ (altura); c) Auxiliares: la constante ‘PI’ y la constante ‘g’ (gravedad).</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.4.2.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.4.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conocen las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                <p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el valor de la velocidad en m/seg, utilizando la variable ‘v’.</li>
                  <li>Leer el valor del ángulo theta en grados, utilizando la variable ‘theta’.</li>
                  <li>Convertir el ángulo theta de grados a radianes.</li>
                  <ol type="1" start="3">
                    <li>1. Asignar a la variable theta el producto del ángulo theta por la constante PI y dividirlo para el valor de 180 grados.</li>
                  </ol>
                  <li>Calcular la distancia alcanzada por el proyectil.</li>
                  <ol type="1" start="4">
                    <li>1.	Asignar a la variable ‘d’ (distancia) los valores que contempla la fórmula de la distancia (1), según la Física Clásica</li>
                  </ol>
                  <li>Calcular el tiempo de vuelo del proyectil</li>
                  <ol type="1" start="5">
                    <li>1.	Asignar a la variable ‘t’ (tiempo) los valores que contempla la fórmula del tiempo de vuelo (2), según la Física Clásica.</li>
                  </ol>
                  <li>Calcular la altura alcanzada por el proyectil.</li>
                  <ol type="1" start="6">
                    <li>1.	Asignar a la variable ‘h’ (altura) los valores que contempla la fórmula de la altura (3), según la Física Clásica.</li>
                  </ol>
                  <li>Imprimir los valores de la variable ‘d’ (distancia), de la variable ‘t’ (tiempo) y de la variable ‘h’ (altura).</li>
                </ol>

                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.4.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.4.1. </b>Programa que calcula la distancia, tiempo de vuelo y la altura alcanzada por un proyectil.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_4_1"  [lineNumbers]="true"></code></pre> <br>
                <h2>E) Pruebas</h2>
                <p>En la Tabla 2.4.2 se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <h5><b>Tabla 2.4.2. </b>Salida del programa.</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.4.2.png" style="display:block; margin:auto; "><br>
                
              </ng-template>
            </mat-tab>
            
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Estructuras de Control de Selección">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="2.3.1. La sentencia if">
              <ng-template matTabContent>
              </ng-template>
            </mat-tab>
            <mat-tab  label="2.3.2. La sentencia if-else">
              <ng-template matTabContent>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.3.3. Sentencias if-else Anidadas">
              <ng-template matTabContent>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.3.4. Secuencia de Sentencias if">
              <ng-template matTabContent>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.3.5. Secuencia de Sentencias if-else">
            </mat-tab>

            <mat-tab  label="2.3.6. Sentencia de Control switch">
            </mat-tab>
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Estructuras de Control Repetitivas o Bucles">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
              <mat-tab  label="Introducción">
                <ng-template matTabContent>
                  <br>
                  <h1>Estructuras de Control Repetitivas o Bucles</h1>
                  <p>La estructura de control conocida como bucle es aquella que realiza la repetición o iteración de acciones. La sentencia o grupos de sentencias que se repiten en un bloque se denominan cuerpo del bucle y cada repetición del cuerpo del bucle se llama iteración del bucle. Las principales sentencias de repetición son:
                  </p>
                  <ol type="a">
                    <li>La sentencia while </li>
                    <li>	La sentencia do-while </li>
                     <li>	La sentencia for </li>
                    <li>	Bucles anidados  </li> 
                  </ol>
                </ng-template>
              </mat-tab>
              <mat-tab  label="2.4.1. La sentencia while">
                <ng-template matTabContent>
                  <br><h1>La sentencia while()</h1>
                  <p>La sentencia while() crea un bucle que se repite hasta que la expresión lógica o condición del bucle se vuelva falsa. El cuerpo del bucle while() se ejecutará cero o más veces dependiendo de la condición del bucle. El formato de esta sentencia tiene la siguiente sintaxis:</p>
                  <p><b>Sintaxis 1:</b></p>
                  <pre><code align="left">while(Condición_Bucle)
      sentencia;</code></pre>
                    <table>
                      <tr VALIGN=top><td><code>Condición_Bucle</code></td>
                        <td>Expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva.</td></tr>
                        <tr VALIGN=top><td><code>sentencia</code></td>
                        <td>La sentencia o acción se ejecuta si la expresión lógica es verdadera dentro del bucle.</td></tr>
                    </table>
                    <br>
                    <table border="1" CELLPADDING=5 CELLSPACING=0>
                      <tr VALIGN=top><td width="50"><b> Nota:</b></td><td>  En esta sintaxis no es necesario utilizar llaves ya que se tiene una sola sentencia o instrucción.</td></tr>
                    </table>
                    <br>
                    <p><b>Sintaxis 2:</b></p>
                  <pre><code align="left">while(Condición_Bucle)
  &#65371;
        sentencia<sub>1</sub>;
        sentencia<sub>2</sub>;
        ...
        sentencia<sub>n</sub>;
  &#65373; 
  </code></pre>
                    <table>
                      <tr VALIGN=top><td><code>Condición_Bucle</code></td>
                        <td>Expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva.</td></tr>
                        <tr VALIGN=top><td><code>sentencia</code></td>
                        <td>Las acciones o sentencias se ejecutan si la expresión lógica es verdadera dentro del bucle.</td></tr>
                    </table>
                    <br>
                    <h4><b>Ejercicio 2.17: </b>Escribir un programa que permita imprimir de manera ascendente los números del 1 al 10 utilizando un bucle while().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en uno</td>
                        <td>i = 1;  </td>
                      </TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &gt;=10) &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Incrementar el valor del contador en uno.</td>
<td><pre>i++;
  &#65373; 
</pre> </td></TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.17: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_17"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.17 se puede ver la impresión del 1 al 10 de manera creciente.</p>
                    <h5><b>Ejecución 2.17 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.17.png" style="display:block; margin:auto; "><br>
                    <p>En la Tabla 2.17 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se incrementa en uno, mientras la condición del bucle sea verdadera.</p>
                    <h5><b>Tabla 2.17: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>1</td><td>1 &gt;=10 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>2</td><td>2 &gt;=10 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>3</td><td>3 &gt;=10 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>4</td><td>4 &gt;=10 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>5</td><td>5 &gt;=10 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>6</td><td>6 &gt;=10 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>7</td><td>7 &gt;=10 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>8</td><td>8 &gt;=10 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>9</td><td>9 &gt;=10 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>10</td><td>10 &gt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>11</td><td style="color:rgb(33, 15, 201)">11 &gt;=10 (F)</td><td> </td></tr>
                      
                    </table>
                    <br>
                    <h4><b>Ejercicio 2.18: </b>Escribir un programa que permita imprimir de manera descendente los números del 10 al 1 utilizando un bucle while().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en diez</td>
                        <td>i = 10;  </td>
                      </TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &lt;=1) &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Decrementar el valor del contador en uno.</td>
<td><pre>i--;
  &#65373; 
</pre> </td></TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.18: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_18"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.18 se puede ver la impresión del 10 al 1 de manera decreciente.</p>
                    <h5><b>Ejecución 2.18 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.18.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.18 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en uno, mientras la condición del bucle sea verdadera.</p>
                    <h5><b>Tabla 2.18: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &lt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>10</td><td>10 &lt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>9</td><td>9 &lt;=1 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>8</td><td>8 &lt;=1 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>7</td><td>7 &lt;=1 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>6</td><td>6 &lt;=1 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>5</td><td>5 &lt;=1 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>4</td><td>4 &lt;=1 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>3</td><td>3 &lt;=1 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>2</td><td>2 &lt;=1 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>1</td><td>1 &lt;=1 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>0</td><td style="color:rgb(33, 15, 201)">0 &lt;=1 (F)</td><td> </td></tr>
                      
                    </table><br>
                    <h4><b>Ejercicio 2.19: </b>Escribir un programa que permita imprimir de manera ascendente los números pares del 2 al 10 utilizando un bucle while().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en dos</td>
                        <td>i = 2;  </td>
                      </TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &gt;=1) &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Incrementar el valor del contador en dos.</td>
<td><pre>i=i+2;
  &#65373; 
</pre> </td></TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.19: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_19"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.19 se puede ver la impresión de los números pares del 2 al 10 de manera creciente.</p>
                    <h5><b>Ejecución 2.19 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.19.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.19 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se incrementa en dos, mientras la condición del bucle sea verdadera.
</p>
                    <h5><b>Tabla 2.19: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>2</td><td>2 &gt;=10 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>4</td><td>4 &gt;=10 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>6</td><td>6 &gt;=10 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>8</td><td>8 &gt;=10 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>10</td><td>10 &gt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>12</td><td>12 &gt;=10 (F)</td><td> </td></tr>                      
                    </table> <br>
 <h4><b>Ejercicio 2.20: </b>Escribir un programa que permita imprimir de manera descendente los números impares del 9 al 1 utilizando un bucle while().
</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en nueve</td>
                        <td>i = 9;  </td>
                      </TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &lt;=1) &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Decrementar el valor del contador en dos.</td>
<td><pre>i=i-2;
  &#65373; 
</pre> </td></TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.20: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_20"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.20 se puede ver la impresión del 9 al 1 de manera decreciente.
</p>
                    <h5><b>Ejecución 2.20 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.20.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.20 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en dos, mientras la condición del bucle sea verdadera.

</p>
                    <h5><b>Tabla 2.20: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=1</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>9</td><td>9 &gt;=1 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>7</td><td>7 &gt;=1 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>5</td><td>5 &gt;=1 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>3</td><td>3 &gt;=1 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>1</td><td>1 &gt;=1 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>-1</td><td>-1 &gt;=1 (F)</td><td> </td></tr>                      
                    </table> <br>
                    <h1><b>Caso de Estudio 2.17: Sumatoria y Promedio de un Grupo de Notas.</b></h1>
                    <h2><b>A) Problema</b></h2>
                    <p>Escribir un programa que permita calcular la sumatoria y el promedio de un grupo de notas leídas desde el teclado.</p>
                    <h2><b>B) Análisis</b></h2>
                    <p>Claramente se puede ver que las entradas del problema son el número de notas representada por la variable ‘n’ y el valor de una nota representada por la variable ‘nota’. Hay dos salidas requeridas que son la sumatoria de un grupo de notas representada por la variable ‘sum’ y el promedio de un grupo de notas representada por la variable ‘prom’. Se requiere un dato auxiliar que es el contador del bucle representado por la variable ‘i’. El requerimiento de los datos y las fórmulas requeridas se muestran a continuación. </p>
                    <h3><b>Requerimiento de los Datos</b></h3>
                    <p><b>Entradas del Programa</b></p>
                    <table>
                      <tr><td width="200">n</td><td width="200">/* Número de notas */</td></tr>
                      <tr><td width="200">nota</td><td width="200">/* Valor de una nota */</td></tr>
                    </table><br>
                    <p><b>Salidas del Problema</b></p>
                    <table>
                      <tr><td width="200">sum</td><td width="200">/* Sumatoria de un grupo de notas  */</td></tr>
                      <tr><td width="200">prom</td><td width="200">/* Media o promedio de un grupo de notas */</td></tr>
                     </table><br>
                    <p><b>Auxiliares del Problema</b></p>
                    <table>
                      <tr><td width="200">i</td><td width="200">/* Contador del bucle  */</td></tr>
                   </table><br>
                   <p><b>Fórmulas Relevantes</b></p>
                      <table>
                        <tr><td width="120"><em>sum = sum + valor </em></td><td width="30"> (1) </td><td width="280">/* Fórmula que representa el acumulador de una sumatoria */</td></tr>
                        <tr><td ><em>prom = <sup>sum</sup> / <sub>n</sub></em></td><td> (2) </td><td>/* Fórmula que calcula el promedio de un grupo de elementos en función del valor de la sumatoria  */</td></tr>
                      </table> <br>
                      <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.17.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘n’; la variable ‘nota’; b) Salidas: la variable ‘sum’; la variable ‘prom’; c) Auxiliares: el contador ‘i’.
</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.17.2.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.17.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                
		<p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Impresión de un mensaje de información.</li>
                  <li>Leer el valor del número de notas que se desea ingresar.</li>
		<li>Inicializar el valor del contador en uno.</li>
		<li>Inicializar el valor de la sumatoria en cero.</li>                  
		<li>Mientras el valor del contador ‘i’ sea menor o igual que cero, hacer:</li>
                  <ol type="1" start="5">
                    <li>1. Leer el valor de una nota.</li>
                  </ol><ol type="1" start="5">
                    <li>2. Asignar al acumulador de sumas ‘sum’ el valor que tiene acumulado más el valor de una nueva nota, utilizando la ecuación (1).</li>
                  </ol><ol type="1" start="5">
                    <li>3. Incrementar el valor del contador ‘i’ en uno.</li>
                  </ol>
                  <li>Calcular el valor del promedio de un grupo de notas, utilizando la ecuación (2).</li>
                  <li>Imprimir el valor de la sumatoria de un grupo de notas.</li>
                  
                  <li>Imprimir el valor del promedio de un grupo de notas.</li>
                </ol>
                
                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.17.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.17.1. </b>Programa que convierte un número decimal en un número binario.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_17_1"  [lineNumbers]="true"></code></pre> <br>
                <h2>E) Pruebas</h2>
                <p>En la Tabla 2.17.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <p>En la salida de la Tabla 2.17.2 se puede ver que, se solicita al usuario que ingrese el número de notas que para este ejemplo es 10. Luego, el usuario ingresa cada una de las 10 notas y el programa calcula la sumatoria y el promedio.</p>
		<h5><b>Tabla 2.17.2.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.17.2.png" style="display:block; margin:auto; "><br>
		<p>En la Tabla 2.17.3, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada ciclo del bucle while() se lee el valor de una nota y se suma en un acumulador el valor que tiene con el valor de una nueva nota ingresada desde el teclado y se incrementa en uno el valor del contador. Finalmente, la ejecución de la sentencia while() termina cuando la condición del bucle se hace falsa.</p>
               <h5><b>Tabla 2.17.2. </b>Prueba de escritorio del programa.</h5>

               <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                <tr style="color:red"><td>n</td><td>i</td><td>i &gt;=n</td><td>nota</td><td>sum</td><td>prom</td></tr>
                <tr><td>10</td><td>1</td><td>1 &gt;=10 (V)</td><td>11.8</td><td>0</td><td>13.983</td></tr>
                <tr><td></td><td>2</td><td>2 &gt;=10 (V)</td><td>12.6</td><td>0+11.8=11.8</td><td></td></tr>
                <tr><td></td><td>3</td><td>3 &gt;=10 (V)</td><td>16.5</td><td>11.8+12.6=24.4</td><td></td></tr>
                <tr><td></td><td>4</td><td>4 &gt;=10 (V)</td><td>18.03</td><td>24.4+16.5=40.9</td><td></td></tr>
                <tr><td></td><td>5</td><td>5 &gt;=10 (V)</td><td>14.8</td><td>40.9+18.03=58.93</td><td></td></tr>
                <tr><td></td><td>6</td><td>6 &gt;=10 (V)</td><td>10.3</td><td>58.93+14.8=73.73</td><td></td></tr>
                <tr><td></td><td>7</td><td>7 &gt;=10 (V)</td><td>7.4</td><td>73.73+10.3=84.03</td><td></td></tr>
                <tr><td></td><td>8</td><td>8 &gt;=10 (V)</td><td>17.6</td><td>84.03+7.4=91.43</td><td></td></tr>
                <tr><td></td><td>9</td><td>9 &gt;=10 (V)</td><td>16.2</td><td>91.43+1706=109.03</td><td></td></tr>
                <tr><td></td><td>10</td><td>10 &gt;=10 (V)</td><td>14.6</td><td>109.03+16.2=125.23</td><td></td></tr>
                <tr><td></td><td>11</td><td style="color:blue">11 &gt;=10 (F)</td><td>11.8</td><td>125.23+14.6=139.83</td><td></td></tr>
                        
              </table> <br>
              <h1><b>Caso de Estudio 2.18: Máximo Común Divisor y mínimo común múltiplo entre dos números.</b></h1>
              <h2><b>A) Problema</b></h2>
              <p>Escribir un programa que permita calcular el Máximo Común Divisor (MCD) y el mínimo común múltiplo (mcm) entre dos números enteros. Así, por ejemplo, el MCD entre 1032 y 180 es 12 y el mcm es 15480.</p>
              <h2><b>B) Análisis</b></h2>
              <p>Claramente se puede ver que las entradas del problema son dos números enteros. Hay dos salidas requeridas que son el MCD y el mcm. Se requieren tres datos auxiliares que son: el dividendo de la división, el divisor de la división y el residuo de la división. El proceso manual de cálculo del MCD se basa en el Algoritmo de Euclides donde se utilizan divisiones sucesivas para calcular los restos de las divisiones, donde en cada división resultante, el divisor obtenido pasa a ser el nuevo Dividendo y el Residuo obtenido pasa a ser el nuevo divisor, como se puede ver en la Figura 2.18.1.</p>
              <img src="./assets/images/Capitulos/II/media/Figura 2.18.1.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 2.18.1. </b>Divisiones sucesivas del Algoritmo de Euclides.</h5>
              <p>En la Tabla 2.18.1 se presenta el resumen de los resultados de los cocientes, Dividendos, divisores y Residuos de las divisiones sucesivas realizadas para calcular el MCD entre los números 1032 y 180.</p>
              <h5><b>Tabla 2.18.1. </b>Resumen de resultados del Algoritmo de Euclides.</h5>
            <table border="1" cellspacing="0" cellpadding="5">
              <tr><td>Cociente</td><td width="30"></td><td width="30">5</td><td width="30">1</td><td width="30">2</td><td width="30">1</td><td width="30">3</td><td width="30"></td></tr>
              <tr><td>Dividendos/Divisores</td><td>1032</td><td>180</td><td>132</td><td>48</td><td>36</td><td>12</td><td>0</td></tr>
              <tr><td>Restos</td><td>132</td><td>48</td><td>36</td><td>12</td><td>0</td><td></td><td></td></tr>
            </table>  <br>
            <p>En la solución computacional del MCD se cumple con el Algoritmo de Euclides donde se utiliza un bucle que controla las divisiones sucesivas, donde en cada división resultante, el divisor obtenido pasa a ser el nuevo Dividendo y el Residuo obtenido pasa a ser el nuevo divisor. El requerimiento de los datos y las fórmulas requeridas se muestran a continuación. </p>
            <h3><b>Requerimiento de los Datos</b></h3>
              <p><b>Entradas del Programa</b></p>
              		
		<table>
                  <tr><td width="200"> a </td><td width="200">/* primer número entero  */</td></tr>
                  <tr><td width="200"> b </td><td width="200">/* segundo número entero */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200"> MCD </td><td width="200">/* Máximo Común Divisor  */</td></tr>
                  <tr><td> mcm </td><td>/* mínimo común múltiplo */</td></tr>
                </table><br>
		<p><b>Auxiliares del Problema</b></p>
              <table>
                <tr><td width="200">D</td><td width="200">/* Dividendo de la división */</td></tr>
		<tr><td width="200">d</td><td width="200">/* divisor de la división */</td></tr>
		<tr><td width="200">R</td><td width="200">/* Residuo de la división */</td></tr>
             </table><br>
                <p><b>Fórmulas Relevantes</b></p>
                <table>
                  <tr><td width="120"><em>R=D MOD2 </em></td><td width="30"> (1) </td><td width="280">/* Fórmula que calcula el residuo de una división */</td></tr>
                  <tr><td ><em>mcm = <sup>a∙b</sup> / <sub>MCD</sub></em></td><td> (2) </td><td>/* Fórmula que calcula el mcm entre dos números ‘a’ y ‘b’ utilizando el MCD */</td></tr>
                </table> <br>

                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.18.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘a’; la variable ‘b’; b) Salidas: la variable ‘MCD’; la variable ‘mcm’; c) Auxiliares: la variable ‘D’; la variable ‘d’; la variable ‘R’.
</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.18.2.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.18.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                
			<p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el valor del primer número entero.</li>
                  <li>Leer el valor del segundo número entero.</li>
		<li>Asignar a la variable Dividendo el valor del primer número.</li>
		<li>Asignar a la variable divisor el valor del segundo número.</li>                  
		<li>Mientras el divisor sea diferente de cero, hacer:</li>
                  <ol type="1" start="5">
                    <li>1. Calcular el valor del Residuo entre el Dividendo y el divisor.</li>
                  </ol><ol type="1" start="5">
                    <li>2. Asignar a la variable Dividendo el valor del divisor.</li>
                  </ol><ol type="1" start="5">
                    <li>3. Asignar a la variable divisor el valor del Residuo.</li>
                  </ol>
                  <li>Asignar a la variable MCD el valor final del Dividendo.</li>
                  <li>Calcular el valor del mínimo común múltiplo.</li>
                   <li>Imprimir el valor del Máximo Común Divisor (MCD).</li>
                  <li>Imprimir el valor del mínimo común múltiplo (mcm).</li>
                </ol>


                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.18.2 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.18.2. </b>Programa que calcula el MCD y el mcm entre dos números.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_18_2"  [lineNumbers]="true"></code></pre> <br>
                <h2>E) Pruebas</h2>
                <p>En la Tabla 2.18.3, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <p>En la salida de la Tabla 2.18.3 se puede ver que, al ingresar el primer número que es 1032 y al ingresar el segundo número que es 180, se obtiene el valor del MCD que es 12 y el valor del mcm que es 15480.</p>
	            	<h5><b>Tabla 2.18.3.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.18.3.png" style="display:block; margin:auto; "><br>
            		<p>En la Tabla 2.18.4, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada división sucesiva el divisor de una división pasa a ser el nuevo Dividendo de la siguiente división y el Residuo de la división pasa a ser el nuevo divisor de la siguiente división. También, se puede comprobar que el MCD resultante es el valor final del Dividendo calculado y la ejecución de la sentencia while() termina cuando la condición del bucle se hace falsa.</p>
               <h5><b>Tabla 2.18.4. </b>Prueba de escritorio del programa.</h5>
            		<table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                <tr style="color:red"><td>a</td><td>b</td><td>D</td><td>D</td><td>d &lt; 0</td><td>R = D % d</td></tr>
                <tr><td>1032</td><td>180</td><td>1032</td><td>180</td><td>180 &lt; 0 (V)</td><td>132</td></tr>
	            	<tr><td></td><td></td><td>180</td><td>132</td><td>132 &lt; 0 (V)</td><td>48</td></tr>
            		<tr><td></td><td></td><td>132</td><td>48</td><td>48 &lt; 0 (V)</td><td>36</td></tr>
            		<tr><td></td><td></td><td>48</td><td>36</td><td>36 &lt; 0 (V)</td><td>12</td></tr>
                <tr><td></td><td></td><td>36</td><td>12</td><td>12 &lt; 0 (V)</td><td>0</td></tr>
                <tr><td></td><td></td><td>12</td><td>0</td><td style="color:blue">0 &lt;=0 (F)</td><td></td></tr>
                        
               </table> <br>
            </ng-template>
            </mat-tab>
            <mat-tab  label="2.4.2. La sentencia do-while">
              <ng-template matTabContent>
                <br>
                <h1>La sentencia do-while()</h1>
                <p>La sentencia do-while() crea un bucle que se repite hasta que la expresión lógica o condición del bucle se vuelva falsa. El cuerpo del bucle do-while() se ejecutará una o varias veces, pero al menos una vez, dependiendo de la condición del bucle. El formato de esta sentencia tiene la siguiente sintaxis:</p>
                <p><b>Sintaxis 1:</b></p>
                <pre><code align="left">
do
    sentencia;
while(Condición_Bucle);
</code></pre>
                  <table>
                    <tr VALIGN=top><td><code>Condición_Bucle</code></td>
                      <td>Expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva.</td></tr>
                      <tr VALIGN=top><td><code>sentencia</code></td>
                      <td>La sentencia o acción se ejecuta si la expresión lógica es verdadera dentro del bucle.</td></tr>
                  </table>
                  <br>
                  <table border="1" CELLPADDING=5 CELLSPACING=0>
                    <tr VALIGN=top><td width="50"><b> Nota:</b></td><td>  En esta sintaxis no es necesario utilizar llaves ya que se tiene una sola sentencia o instrucción.</td></tr>
                  </table>
                  <br>
                  <p><b>Sintaxis 2:</b></p>
                <pre><code align="left">
do
&#65371;
      sentencia<sub>1</sub>;
      sentencia<sub>2</sub>;
      ...
      sentencia<sub>n</sub>;
&#65373; while(Condición_Bucle);
</code></pre>
                  <table>
                    <tr VALIGN=top><td><code>Condición_Bucle</code></td>
                      <td>Expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva.</td></tr>
                      <tr VALIGN=top><td><code>sentencia</code></td>
                      <td>Las acciones o sentencias se ejecutan si la expresión lógica es verdadera dentro del bucle.</td></tr>
                  </table>
                  <br>
         
                  <h4><b>Ejercicio 2.21: </b>Escribir un programa que permita imprimir de manera ascendente los números del 1 al 10 utilizando un bucle do-while().</h4>
                  <br>
                  <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                    <TR>
                      <th width="10"> <b> N° </b> </th> 
                      <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                      <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                    </TR>
                    <TR> <td>1</td>  <td>entero : i</td>
                      <td>
                        <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                        i;</td>
                    </TR>
                    <TR>
                      <td>2</td>
                      <td>Inicializar el valor del contador en uno</td>
                      <td>i = 1;  </td>
                    </TR>
                    <TR><td>3</td> <td>Hacer:</td> 
                      <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">do </font>
                       &#65371;</td> </TR>
                    <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                      <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                        i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                     <TR><td>5</td><td>Incrementar el valor del contador en uno.</td> <td>i++; </td></TR>
    <TR><td>6</td><td>Mientras la condicion sea verdadera.</td><td>&#65373; 
    <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>(i &gt; 10);</td></TR>
                  </TABLE> <br>
                  <h5><b>Programa 2.21: </b>Código del programa</h5>
                  <pre><code [highlight]="prefTab2[0].programa2_21"  [lineNumbers]="true"></code></pre>
                  <p>En la salida de la Ejecución 2.21 se puede ver la impresión del 1 al 10 de manera creciente.</p>
                  <h5><b>Ejecución 2.21 </b>Salida del programa.</h5>
                  <img src="./assets/images/Capitulos/II/media/Ejecución 2.21.png" style="display:block; margin:auto; "><br>
                  <p>En la Tabla 2.21 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se incrementa en uno, mientras la condición del bucle sea verdadera.</p>
                  <h5><b>Tabla 2.21: </b>Prueba de escritorio del programa.</h5>
                  <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                    <tr style="color:red"><td>i</td><td>i &gt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                    <tr><td>1</td><td>1 &gt;=10 (V)</td><td>1 INTRO</td></tr>
                    <tr><td>2</td><td>2 &gt;=10 (V)</td><td>2 INTRO</td></tr>
                    <tr><td>3</td><td>3 &gt;=10 (V)</td><td>3 INTRO</td></tr>
                    <tr><td>4</td><td>4 &gt;=10 (V)</td><td>4 INTRO</td></tr>
                    <tr><td>5</td><td>5 &gt;=10 (V)</td><td>5 INTRO</td></tr>
                    <tr><td>6</td><td>6 &gt;=10 (V)</td><td>6 INTRO</td></tr>
                    <tr><td>7</td><td>7 &gt;=10 (V)</td><td>7 INTRO</td></tr>
                    <tr><td>8</td><td>8 &gt;=10 (V)</td><td>8 INTRO</td></tr>
                    <tr><td>9</td><td>9 &gt;=10 (V)</td><td>9 INTRO</td></tr>
                    <tr><td>10</td><td>10 &gt;=10 (V)</td><td>10 INTRO</td></tr>
                    <tr><td>11</td><td style="color:rgb(33, 15, 201)">11 &gt;=10 (F)</td><td> </td></tr>
                    
                  </table>
                  <br>
                  <h4><b>Ejercicio 2.22: </b>Escribir un programa que permita imprimir de manera descendente los números del 10 al 1 utilizando un bucle do-while().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en diez</td>
                        <td>i = 10;  </td>
                      </TR>
                      <TR><td>3</td> <td>Hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">do </font>&#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Decrementar el valor del contador en uno.</td><td>i--;</td></TR>
			<TR><td>6</td> <td>Mientras la condición sea verdadera</td> 
			<td>&#65373;<font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &lt;=1); </td> </TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.22: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_22"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.22 se puede ver la impresión del 10 al 1 de manera decreciente.</p>
                    <h5><b>Ejecución 2.22 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.22.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.22 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en uno, mientras la condición del bucle sea verdadera.</p>
                    <h5><b>Tabla 2.22: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &lt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>10</td><td>10 &lt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>9</td><td>9 &lt;=1 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>8</td><td>8 &lt;=1 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>7</td><td>7 &lt;=1 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>6</td><td>6 &lt;=1 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>5</td><td>5 &lt;=1 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>4</td><td>4 &lt;=1 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>3</td><td>3 &lt;=1 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>2</td><td>2 &lt;=1 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>1</td><td>1 &lt;=1 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>0</td><td style="color:rgb(33, 15, 201)">0 &lt;=1 (F)</td><td> </td></tr>
                      
                    </table><br>
                    <h4><b>Ejercicio 2.23: </b>Escribir un programa que permita imprimir de manera ascendente los números pares del 2 al 10 utilizando un bucle do-while().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en dos</td>
                        <td>i = 2;  </td>
                      </TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">do </font>
                          &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Incrementar el valor del contador en dos.</td>
			<td>i=i+2; </td></TR>
			<TR><td>6</td> <td>Mientras la condición sea verdadera</td> 
                        <td>&#65373; <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &gt;=10);</td> </TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.23: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_23"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.23 se puede ver la impresión de los números pares del 2 al 10 de manera creciente.</p>
                    <h5><b>Ejecución 2.23 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.23.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.23 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se incrementa en dos, mientras la condición del bucle sea verdadera.
</p>
                    <h5><b>Tabla 2.23: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>2</td><td>2 &gt;=10 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>4</td><td>4 &gt;=10 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>6</td><td>6 &gt;=10 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>8</td><td>8 &gt;=10 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>10</td><td>10 &gt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>12</td><td>12 &gt;=10 (F)</td><td> </td></tr>                      
                    </table> <br>   
                  <h4><b>Ejercicio 2.24: </b>Escribir un programa que permita imprimir de manera descendente los números impares del 9 al 1 utilizando un bucle do-while().
</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR><td>2</td><td>Inicializar el valor del contador en nueve</td><td>i = 9;  </td></TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">do </font>
                        &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Decrementar el valor del contador en dos.</td><td>i=i-2;</td></TR>
			<TR><td>6</td> <td>Mientras la condición sea verdadera.</td> 
                        <td>&#65373; <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &lt;=1);</td> </TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.24: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_24"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.24 se puede ver la impresión del 9 al 1 de manera decreciente.
</p>
                    <h5><b>Ejecución 2.24 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.24.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.24 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en dos, mientras la condición del bucle sea verdadera.

</p>
                    <h5><b>Tabla 2.24: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &lt;=1</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>9</td><td>9 &gt;=1 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>7</td><td>7 &gt;=1 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>5</td><td>5 &gt;=1 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>3</td><td>3 &gt;=1 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>1</td><td>1 &gt;=1 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>-1</td><td>-1 &gt;=1 (F)</td><td> </td></tr>                      
                    </table> <br>
                    <h4><b>Ejercicio 2.24: </b>Escribir un programa que permita imprimir de manera descendente los números impares del 9 al 1 utilizando un bucle do-while().
                    </h4>
                    <br>
                                        <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                                          <TR>
                                            <th width="10"> <b> N° </b> </th> 
                                            <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                                            <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                                          </TR>
                                          <TR> <td>1</td>  <td>entero : i</td>
                                            <td>
                                              <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                                              i;</td>
                                          </TR>
                                          <TR><td>2</td><td>Inicializar el valor del contador en nueve</td><td>i = 9;  </td></TR>
                                          <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                                            <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">do </font>
                                            &#65371;</td> </TR>
                                          <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                                            <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                                              i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                                           <TR><td>5</td><td>Decrementar el valor del contador en dos.</td><td>i=i-2;</td></TR>
                          <TR><td>6</td> <td>Mientras la condición sea verdadera.</td> 
                                            <td>&#65373; <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                                              (i &lt;=1);</td> </TR>
                                        </TABLE> <br>
                                        <h5><b>Programa 2.24: </b>Código del programa</h5>
                                        <pre><code [highlight]="prefTab2[0].programa2_24"  [lineNumbers]="true"></code></pre>
                                        <p>En la salida de la Ejecución 2.24 se puede ver la impresión del 9 al 1 de manera decreciente.
                    </p>
                                        <h5><b>Ejecución 2.24 </b>Salida del programa.</h5>
                                        <img src="./assets/images/Capitulos/II/media/Ejecución 2.24.png" style="display:block; margin:auto; "><br>
                     <p>En la Tabla 2.24 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en dos, mientras la condición del bucle sea verdadera.
                    
                    </p>
                                        <h5><b>Tabla 2.24: </b>Prueba de escritorio del programa.</h5>
                                        <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                                          <tr style="color:red"><td>i</td><td>i &gt;=1</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                                          <tr><td>9</td><td>9 &gt;=1 (V)</td><td>9 INTRO</td></tr>
                                          <tr><td>7</td><td>7 &gt;=1 (V)</td><td>7 INTRO</td></tr>
                                          <tr><td>5</td><td>5 &gt;=1 (V)</td><td>5 INTRO</td></tr>
                                          <tr><td>3</td><td>3 &gt;=1 (V)</td><td>3 INTRO</td></tr>
                                          <tr><td>1</td><td>1 &gt;=1 (V)</td><td>1 INTRO</td></tr>
                                          <tr><td>-1</td><td>-1 &gt;=1 (F)</td><td> </td></tr>                      
                                        </table> <br>
                     <h1><b>Caso de Estudio 2.19: Conversión de Decimal a Binario.</b></h1>
              <h2><b>A) Problema</b></h2>
              <p>Escribir un programa que permita convertir un número en sistema decimal o base 10 a sistema binario o base 2, utilizando divisiones sucesivas. Así, por ejemplo, el número 233 en binario es 11101001.</p>
              <h2><b>B) Análisis</b></h2>
              <p>Claramente se puede ver que la entrada del problema es el número decimal. Hay una sola salida requerida que es el número binario o en base dos. Se requieren cinco datos auxiliares que son: el dividendo de la división, el cociente de la división, el residuo de la división, una sumatoria para acumular valores y un contador para las potencias de 10. El proceso manual de cálculo de conversión de un número decimal a binario se basa en divisiones sucesivas y los restos obtenidos de abajo hacia arriba generan el número binario como se puede ver en la Figura 2.19.1.
</p>
              <img src="./assets/images/Capitulos/II/media/Figura 2.19.1.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 2.19.1. </b>Proceso manual de cálculo de un número binario.</h5>
             
 <p>En la solución computacional del número binario hay un bucle que controla las divisiones sucesivas, que permiten obtener los restos de las divisiones que se acumulan en una sumatoria que acumula los resultados parciales del producto del residuo por 10 elevado a una potencia de ‘n’ y un contador que controla los valores de la potencia de ‘n’. De manera sucesiva el resultado del cociente de una división pasa a ser el dividendo de la siguiente división, asignando a la variable dividendo el valor del cociente en cada iteración del bucle. Finalmente, el valor de la sumatoria obtenida viene a ser el valor del número binario calculado, como se puede ver en la Figura 2.19.2. El requerimiento de los datos y las fórmulas requeridas se muestran a continuación. 
</p>              <img src="./assets/images/Capitulos/II/media/Figura 2.19.2.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 2.19.2. </b>Solución computacional del número binario.</h5>
    
	<h3><b>B.1) Requerimiento de los Datos</b></h3>
              <p><b>Entradas del Programa</b></p>
              		
		<table>
                  <tr><td width="200"> num </td><td width="200">/* número en sistema decimal o base 10  */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200"> bin </td><td width="200">/* número en binario o base 2 */</td></tr>
                </table><br>
		<p><b>Auxiliares del Problema</b></p>
              <table>
                <tr><td width="200">D</td><td width="200">/* Dividendo de la división */</td></tr>
		<tr><td width="200">c</td><td width="200">/* cociente de la división */</td></tr>
		<tr><td width="200">R</td><td width="200">/* Residuo de la división */</td></tr>
<tr><td width="200">sum</td><td width="200">/* sumatoria */</td></tr>
<tr><td width="200">i</td><td width="200">/* contador */</td></tr>
             </table><br>
                <p><b>Fórmulas Relevantes</b></p>
                <table>
		<tr><td ><em>c = <sup>D</sup> / <sub>2</sub></em></td><td> (2) </td><td>/* Fórmula que calcula el cociente de una división */</td></tr>
                <tr><td width="120"><em>R=D MOD2 </em></td><td width="30"> (1) </td><td width="280">/* Fórmula que calcula el residuo de una división */</td></tr>
                  <tr><td ><em>sum = sum + R∙10<sup>n</sup> </em></td><td> (2) </td><td>/* Fórmula que acumula el valor de una sumatoria más el producto entre el residuo por 10 elevado a la potencia de n */</td></tr>
                </table> <br>

                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>
En la Figura 2.19.3 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘num’; b) Salidas: la variable ‘bin’; c) Auxiliares: la variable ‘D’; la variable ‘c’; la variable ‘R’; la variable ‘sum’; la variable ‘i’.

</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.19.3.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.19.3. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                
			<p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el valor del número decimal.</li>
                  <li>Asignar a la variable Dividendo el valor del número decimal.</li>
		<li>Inicializar la variable sumatoria con el valor de cero.</li>
		<li>Inicializar el contador ‘i’ con el valor de cero.</li>                  
		<li>Hacer:</li>
                  <ol type="1" start="5">
                    <li>1. Calcular el valor del cociente entre el Dividendo y el valor de 2.</li>
                  </ol><ol type="1" start="5">
                    <li>2. Calcular el valor del Residuo entre el Dividendo y el valor de 2.</li>
                  </ol><ol type="1" start="5">
                    <li>3. Asignar a la sumatoria el valor que tiene acumulado más el producto entre el Residuo con el valor de 10 elevado a la potencia de ‘i’.</li>
                  </ol><ol type="1" start="5">
                    <li>4. Asignar a la variable Dividendo el valor del cociente.</li>
                  </ol><ol type="1" start="5">
                    <li>5. Incrementar el valor del contador ‘i’ en uno.</li>
			Mientras el cociente de la división sea diferente de cero.
                  </ol>
                  <li>Asignar a la variable ‘bin’ el valor de la sumatoria que corresponde al número binario calculado.</li>
                  <li>Imprimir el valor del número binario.</li>
                </ol>

                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.19.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.19.1. </b>Programa que convierte un número decimal en un número binario.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_19_1"  [lineNumbers]="true"></code></pre> <br>
                <h2>E) Pruebas</h2>
                <p>En la Tabla 2.19.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <p>En la salida de la Tabla 2.19.2 se puede ver que, al ingresar el número 233 en sistema de numeración decimal, se obtiene el número 11101001 en sistema de numeración binario.</p>
	            	<h5><b>Tabla 2.19.2.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.19.2.png" style="display:block; margin:auto; "><br>
            		<p>En la Tabla 2.19.3, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada división sucesiva el cociente de una división pasa a ser el dividendo de la siguiente división. También, se puede comprobar que el resultado de la sumatoria es el número binario calculado y la ejecución de la sentencia do-while() termina cuando la condición del bucle se hace falsa.
</p>
               <h5><b>Tabla 2.19.3. </b>Prueba de escritorio del programa.</h5>
               <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                <tr style="color:red"><td>num</td><td>D</td><td>Sum</td><td>i</td><td>c</td><td>R</td><td>c! = 0</td></tr>
                <tr><td>233</td><td>233</td><td>0</td><td>0</td><td></td><td></td><td></td></tr>
	            	<tr><td></td><td>116</td><td>0+1&#88;10<sup>0</sup>=1</td><td>1</td><td>116</td><td>1</td><td>116 != 0 (V)</td></tr>
            		<tr><td></td><td>58</td><td>1+0&#88;10<sup>1</sup>=1</td><td>2</td><td>58</td><td>0</td><td>58 != 0 (V)</td></tr>
            		<tr><td></td><td>29</td><td>1+0&#88;10<sup>2</sup>=1</td><td>3</td><td>29</td><td>0</td><td>29 != 0 (V)</td></tr>
                <tr><td></td><td>14</td><td>1+1&#88;10<sup>3</sup>=1001</td><td>4</td><td>14</td><td>1</td><td>14 != 0 (V)</td></tr>
                <tr><td></td><td>7</td><td>1001+0&#88;10<sup>4</sup>=1001</td><td>5</td><td>7</td><td>0</td><td>7 != 0 (V)</td></tr>
                <tr><td></td><td>3</td><td>1001+1&#88;10<sup>5</sup>=101001</td><td>6</td><td>3</td><td>1</td><td>3 != 0 (V)</td></tr>
                <tr><td></td><td>1</td><td>101001+1&#88;10<sup>6</sup>=1101001</td><td>7</td><td>1</td><td>1</td><td>1 != 0 (V)</td></tr>
                <tr><td></td><td>0</td><td>1101001+1&#88;10<sup>7</sup>=11101001</td><td>8</td><td>0</td><td>1</td><td style="color:blue">0! = 0 (F)</td></tr>    
               </table> <br>

               <h1><b>Caso de Estudio 2.20: Análisis de Números Palíndromos.</b></h1>
               <h2><b>A) Problema</b></h2>
               <p>Escribir un programa que permita analizar si un número es palíndromo o no lo es. Un número palíndromo es aquel número que invertido o dado la vuelta resulta ser el mismo número. Así, por ejemplo, los números 1234321, 55555, 333, son números palíndromos. Analizar además el número de cifras que tiene el número, visualizar el número original al revés y desplegar un mensaje donde se mencione si el número ingresado por teclado es o no palíndromo.
 
 </p>
               <h2><b>B) Análisis</b></h2>
               <p>Claramente se puede ver que la entrada del problema es un número entero. Hay dos salidas requeridas que son el número de cifras del número y el número original invertido. Se requieren seis datos auxiliares que son: un contador de cifras para el número, el dividendo de la división, el cociente de la división, el residuo de la división, una sumatoria para acumular valores y un contador para las potencias de 10. 
 </p>
     <p>En la solución computacional de análisis de un número palíndromo se plantea primeramente un bucle que cuenta el número de cifras del número entero leído desde el teclado, como se puede ver en la Figura 2.20.1.
 </p>
               <img src="./assets/images/Capitulos/II/media/Figura 2.20.1.png" style="display:block; margin:auto; "><br>
               <h5 style="text-align:center"><b>Figura 2.20.1. </b>Proceso para contar el número de cifras de un número entero.</h5>
              
  <p>Luego, hay un bucle que controla las divisiones sucesivas, que permiten obtener los restos de las divisiones que se acumulan en una sumatoria que acumula los resultados parciales del producto del residuo por 10 elevado a una potencia de ‘n’ y un contador que controla los valores de la potencia de ‘n’. Antes de ingresar a este bucle, el contador se inicializa con el valor del número de cifras menos el valor de uno. De manera sucesiva, el resultado del cociente de una división pasa a ser el dividendo de la siguiente división, asignando a la variable dividendo el valor del cociente en cada iteración del bucle. Finalmente, el valor de la sumatoria obtenida viene a ser el valor del número invertido calculado, como se puede ver en la Figura 2.20.2. El requerimiento de los datos y las fórmulas requeridas se muestran a continuación.
 </p>              <img src="./assets/images/Capitulos/II/media/Figura 2.20.2.png" style="display:block; margin:auto; "><br>
               <h5 style="text-align:center"><b>Figura 2.20.2. </b>Proceso para invertir un número entero.</h5>
     
   <h3><b>B.1) Requerimiento de los Datos</b></h3>
               <p><b>Entradas del Programa</b></p>
                   
     <table>
                   <tr><td width="200"> num </td><td width="200">/* número entero original  */</td></tr>
                 </table><br>
                 <p><b>Salidas del Problema</b></p>
                 <table>
                   <tr><td width="200"> numeroCifras </td><td width="200">/* número de cifras decimales del entero  */</td></tr>
                   <tr><td width="200"> numInvertido </td><td width="200">/* número entero invertido */</td></tr>
                   <tr><td width="200"> Mensaje </td><td width="200">/* que indica que el número ingresado es palíndromo o no es palíndromo */</td></tr>
                 </table><br>
     <p><b>Auxiliares del Problema</b></p>
               <table>
                 <tr><td width="200">cont</td><td width="200">/* contador de cifras decimales de un entero */</td></tr>
     <tr><td width="200">D</td><td width="200">/* Dividendo de la división */</td></tr>
     <tr><td width="200">c</td><td width="200">/* cociente de la división */</td></tr>
     <tr><td width="200">R</td><td width="200">/* Residuo de la división */</td></tr>
     <tr><td width="200">sum</td><td width="200">/* sumatoria */</td></tr>
     <tr><td width="200">i</td><td width="200">/* contador */</td></tr>
              </table><br>
                 <p><b>Fórmulas Relevantes</b></p>
                 <table>
     <tr><td ><em>c = <sup>D</sup> / <sub>10</sub></em></td><td> (2) </td><td>/* Fórmula que calcula el cociente de una división */</td></tr>
                 <tr><td width="120"><em>R=D MOD2 </em></td><td width="30"> (1) </td><td width="280">/* Fórmula que calcula el residuo de una división */</td></tr>
                   <tr><td ><em>sum = sum + R∙10<sup>n</sup> </em></td><td> (2) </td><td>/* Fórmula que acumula el valor de una sumatoria más el producto entre el residuo por 10 elevado a la potencia de n */</td></tr>
                 </table> <br>
 
                 <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                 <p>En la Figura 2.20.3 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘num’; b) Salidas: la variable ‘numeroCifras’; la variable ‘numInvertido’; un mensaje de información que indica que el número ingresado es palíndromo o no es palíndromo; c) Auxiliares: la variable ‘cont’; la variable ‘D’; la variable ‘c’; la variable ‘R’; la variable ‘sum’; la variable ‘i’.
 </p>
                 <img src="./assets/images/Capitulos/II/media/Figura 2.20.3.png" style="display:block; margin:auto; "><br>
                 <h5 style="text-align:center"><b>Figura 2.20.3. </b>Diagrama de Entrada-Salida del Programa.</h5>
                 <h2><b>C) Diseño</b></h2>
                 <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                 
       <p><b>Algoritmo</b></p>
                 <ol type="1">
                   <li>Imprimir el mensaje de información: Analizar si un número es palíndromo.</li>
                   <li>Leer el valor de un número entero.</li>
     <li>Asignar a la variable Dividendo el valor del número entero.</li>
     <li>Inicializar el contador ‘cont’ con el valor de cero.</li>                  
     <li>Hacer:</li>
                   <ol type="1" start="5">
                     <li>1. Calcular el valor del cociente entre el Dividendo y el valor de 10.</li>
                   </ol><ol type="1" start="5">
                     <li>2. Calcular el valor del Residuo entre el Dividendo y el valor de 10.</li>
                   </ol><ol type="1" start="5">
                     <li>3. Asignar a la variable Dividendo el valor del cociente.</li>
                   </ol><ol type="1" start="5">
                     <li>4. Incrementar el valor del contador ‘i’ en uno.</li>
     Mientras el cociente de la división sea diferente de cero.
                   </ol>
                   <li>Asignar a la variable 'numeroCifras' el valor del contador 'cont' que corresponde al valor del número de cifras del número entero ingresado.</li>
     <li>Imprimir el número de cifras del número entero ingresado por teclado.</li>
     <li>Asignar a la variable Dividendo el valor del número entero.</li>
     <li>Inicializar la variable sumatoria con el valor de cero.</li>
     <li>Inicializar el contador 'i' con el valor del número de cifras menos uno.</li>
     <li>Hacer:</li>
                   <ol type="1" start="11">
                     <li>1. Calcular el valor del cociente entre el Dividendo y el valor de 10.</li>
                   </ol><ol type="1" start="11">
                     <li>2. Calcular el valor del Residuo entre el Dividendo y el valor de 10.</li>
                   </ol><ol type="1" start="11">
                     <li>3. 11.3.	Asignar a la sumatoria el valor que tiene acumulado ás el producto entre el Residuo con el valor de 10 elevado a la potencia de ‘i’.</li>
                   </ol><ol type="1" start="11">
                     <li>4. Asignar a la variable Dividendo el valor del cociente.</li>
                   </ol><ol type="1" start="11">
                     <li>5. Decrementar el valor del contador ‘i’ en uno.</li>
      Mientras el cociente de la división sea diferente de cero.
                   </ol>
     <li>Asignar a la variable 'numInvertido' el valor de la sumatoria 'sum' que corresponde al valor del número entero invertido.</li>                  
     <li>Imprimir el número entero invertido.</li>
     <li>Si el valor de la variable 'num' que tiene el valor del número entero original es igual al valor de la variable 'numInvertido' que tiene el valor del número entero invertido.</li>
     <ol type="1" start="14">
                     <li>1. Imprimir el mensaje: El número ingresado es palíndromo.</li>
                   </ol>
     <li>Caso contrario, el valor de la variable 'num' es diferente del valor de la variable 'numInvertido'.</li>
     <ol type="1" start="15">
                     <li>1. Imprimir el mensaje: El número ingresado no es palíndromo.</li>
                   </ol>
                 </ol>
 
                 <h2><b>D) Implementación</b></h2>
                 <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.20.1 se muestra el código del programa en C/C++.</p>
                 <h5><b>Tabla 2.19.1. </b>Programa que analiza si un número leído es palíndromo.</h5>
                 <pre><code [highlight]="prefTab2[0].tabla2_20_1"  [lineNumbers]="true"></code></pre> <br>
                 <h2>E) Pruebas</h2>
                 <p>En la Tabla 2.20.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                 <p>En la salida de la Tabla 2.20.2 se puede ver que, al ingresar el número 55555, el programa indica que este número tiene 5 cifras decimales. Luego, se obtiene el número invertido que en este caso resulta ser el mismo número, y por lo tanto el número ingresado es palíndromo.
 </p>
                 <h5><b>Tabla 2.20.2.</b> Salida del programa</h5>
                 <img src="./assets/images/Capitulos/II/media/Tabla 2.20.2.png" style="display:block; margin:auto; "><br>
                 <p>En la Tabla 2.20.3, se muestra la prueba de escritorio del primer bucle do-while() del programa que cuenta el número de cifras que tiene el número ingresado por el teclado que en este caso es el número 55555 cuyo número de cifras es 5.  
 </p>
                <h5><b>Tabla 2.20.3. </b>Prueba de escritorio del programa del primer bucle do-while() del programa.</h5>
                 <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                 <tr style="color:red"><td>num</td><td>D</td><td>cont</td><td>C</td><td>c!=0</td></tr>
                 <tr><td>55555</td><td>55555</td><td>0</td><td></td><td></td></tr>
                 <tr><td></td><td>5555</td><td>1</td><td>5555</td><td>5555 != 0 (V)</td></tr>
                  <tr><td></td><td>555</td><td>2</td><td>555</td><td>555 != 0 (V)</td></tr>
                  <tr><td></td><td>55</td><td>3</td><td>55</td><td>55 != 0 (V)</td></tr>
                  <tr><td></td><td>5</td><td>4</td><td>5</td><td>5 != 0 (V)</td></tr>
                  <tr><td></td><td>0</td><td>5</td><td>0</td><td style="color:rgb(33, 15, 201)">0!= 0 (F)</td></tr>
                </table> <br>
                <p>En la Tabla 2.20.4, se muestra la prueba de escritorio del segundo bucle do-while() del programa que invierte el número original que es el 55555 y se obtiene nuevamente el mismo número 55555. En cada división sucesiva el cociente de una división pasa a ser el dividendo de la siguiente división. También, se puede comprobar que el resultado de la sumatoria es el número invertido calculado mediante la suma de cada residuo multiplicado por una potencia de diez comenzando con la potencia igual al número de cifras menos uno hasta llegar al valor de cero. Finalmente, la ejecución de la sentencia do-while() termina cuando la condición del bucle se hace falsa. En este caso el número 55555 resulta ser palíndromo.</p>
                <h5><b>Tabla 2.20.4. </b>Prueba de escritorio del programa del segundo bucle do-while() del programa.</h5>
                <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                <tr style="color:red"><td>num</td><td>D</td><td>Sum</td><td>i</td><td>C</td><td>R</td><td>c!=0</td></tr>
                <tr><td>55555</td><td>55555</td><td>0</td><td>4</td><td></td><td></td><td></td></tr>
                <tr><td></td><td>5555</td><td>0+50&#88;10<sup>4</sup>=50000</td><td>3</td><td>5555</td><td>5</td><td>5555 != 0 (V)</td></tr>
                 <tr><td></td><td>555</td><td>50000+5&#88;10<sup>3</sup>=55000</td><td>2</td><td>555</td><td>5</td><td>555 != 0 (V)</td></tr>
                 <tr><td></td><td>55</td><td>55000+5&#88;10<sup>2</sup>=55500</td><td>1</td><td>55</td><td>5</td><td>55 != 0 (V)</td></tr>
                 <tr><td></td><td>5</td><td>55500+5&#88;10<sup>1</sup>=55550</td><td>0</td><td>5</td><td>5</td><td>5 != 0 (V)</td></tr>
                 <tr><td></td><td>0</td><td>55550+5&#88;10<sup>0</sup>=55555</td><td>-1</td><td>0</td><td></td><td style="color:rgb(33, 15, 201)">0!= 0 (F)</td></tr>
               </table> <br>
               <p>En la Tabla 2.20.5, se muestra otro ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
              <p>En la salida de la Tabla 2.20.5 se puede ver que, al ingresar el número 1234, el programa indica que este número tiene 4 cifras decimales. Luego, se obtiene el número invertido que en este caso no resulta ser el mismo número, y por lo tanto el número ingresado no es palíndromo.</p>
            
            


              
              <h5><b>Tabla 2.20.5.</b> Salida del programa</h5>
              <img src="./assets/images/Capitulos/II/media/Tabla 2.20.5.png" style="display:block; margin:auto; "><br>
             <p>En la Tabla 2.20.6, se muestra la prueba de escritorio del primer bucle do-while() del programa que cuenta el número de cifras que tiene el número ingresado por el teclado que en este caso es el número 1234 cuyo número de cifras es 4.  </p>
             <h5><b>Tabla 2.20.6. </b>Prueba de escritorio del programa del primer bucle do-while() del programa.</h5>
              <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
              <tr style="color:red"><td>num</td><td>D</td><td>cont</td><td>C</td><td>c!=0</td></tr>
              <tr><td>1234</td><td>1234</td><td>0</td><td></td><td></td></tr>
              <tr><td></td><td>123</td><td>1</td><td>123</td><td>123 != 0 (V)</td></tr>
               <tr><td></td><td>12</td><td>2</td><td>12</td><td>12 != 0 (V)</td></tr>
               <tr><td></td><td>1</td><td>3</td><td>1</td><td>1 != 0 (V)</td></tr>
               <tr><td></td><td>0</td><td>4</td><td>0</td><td style="color:rgb(33, 15, 201)">0!= 0 (F)</td></tr>
             </table> <br>
             <p>En la Tabla 2.20.7, se muestra la prueba de escritorio del segundo bucle do-while() del programa que invierte el número original que es el número 1234 y se obtiene el número invertido 4321. En cada división sucesiva el cociente de una división pasa a ser el dividendo de la siguiente división. También, se puede comprobar que el resultado de la sumatoria es el número invertido calculado mediante la suma de cada residuo multiplicado por una potencia de diez comenzando con la potencia igual al número de cifras menos uno hasta llegar al valor de cero. Finalmente, la ejecución de la sentencia do-while() termina cuando la condición del bucle se hace falsa. En este caso el número 1234 resulta no ser palíndromo.</p>
             <h5><b>Tabla 2.20.7. </b>Prueba de escritorio del programa del segundo bucle do-while() del programa.</h5>
             <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
             <tr style="color:red"><td>num</td><td>D</td><td>Sum</td><td>i</td><td>C</td><td>R</td><td>c!=0</td></tr>
             <tr><td>1234</td><td>1234</td><td>0</td><td>3</td><td></td><td></td><td></td></tr>
             <tr><td></td><td>123</td><td>0+4&#88;10<sup>3</sup>=4000</td><td>2</td><td>123</td><td>4</td><td>5555 != 0 (V)</td></tr>
              <tr><td></td><td>12</td><td>4000+3&#88;10<sup>2</sup>=4300</td><td>1</td><td>12</td><td>3</td><td>555 != 0 (V)</td></tr>
              <tr><td></td><td>1</td><td>4300+2&#88;10<sup>1</sup>=4320</td><td>0</td><td>1</td><td>2</td><td>55 != 0 (V)</td></tr>
              <tr><td></td><td>0</td><td>4320+1&#88;10<sup>0</sup>=4321</td><td>-1</td><td>0</td><td>1</td><td style="color:rgb(33, 15, 201)">0!= 0 (F)</td></tr>
            </table> <br>
            
            </ng-template>
            </mat-tab>

            <mat-tab  label="2.4.3. La sentencia for">
              <ng-template matTabContent>
                <br><h1>La sentencia for()</h1>
                <p>El bucle for() es el bucle más potente que tiene el lenguaje C/C++, ya que agrupa en un solo lugar tres acciones: a) inicializar uno o varios contadores; b) manejar una expresión lógica y c) incrementar o decrementar el contador o contadores. Este bucle es ideal para implementar bucles controlados por contador que son bucles en los que un conjunto de sentencias se ejecuta una vez por cada valor de un rango especificado, de acuerdo al algoritmo que resuelve un problema. El formato de esta sentencia tiene la siguiente sintaxis:</p>

                <p><b>Sintaxis 1:</b></p>
<pre><code align="left">for(Inicialización; Condición_Bucle; Incremento/Decremento) 
      sentencia;</code></pre>
                    <table>
                      <tr VALIGN=top><td><code>Inicialización</code></td>
                        <td>Sección donde se inicializan las variables de control del bucle.</td></tr>
                        
                      <tr VALIGN=top><td><code>Condición_Bucle</code></td>
                        <td>Sección que contiene una expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva, mientras sea verdadera.</td></tr>
                        <tr VALIGN=top><td><code>Incremento/Decremento</code></td>
                          <td>Sección donde se incrementan o se decrementan las variables de control del bucle.</td></tr>
                      <tr VALIGN=top><td><code>sentencia</code></td>
                        <td>La sentencia o acción se ejecuta si la expresión lógica es verdadera dentro del bucle.</td></tr>
                    </table>
                    <br>
                    <table border="1" CELLPADDING=5 CELLSPACING=0>
                      <tr VALIGN=top><td width="50"><b> Nota:</b></td><td>  En esta sintaxis no es necesario utilizar llaves ya que se tiene una sola sentencia o instrucción.</td></tr>
                    </table>
                    <br>
                    <p><b>Sintaxis 2:</b></p>
                  <pre><code align="left">for(Inicialización; Condición_Bucle; Incremento/Decremento)
&#65371;
        sentencia<sub>1</sub>;
        sentencia<sub>2</sub>;
        ...
        sentencia<sub>n</sub>;
&#65373; 
  </code></pre>
  <table>
    <tr VALIGN=top><td><code>Inicialización</code></td>
      <td>Sección donde se inicializan las variables de control del bucle.</td></tr>
      
    <tr VALIGN=top><td><code>Condición_Bucle</code></td>
      <td>Sección que contiene una expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva, mientras sea verdadera.</td></tr>
      <tr VALIGN=top><td><code>Incremento/Decremento</code></td>
        <td>Sección donde se incrementan o se decrementan las variables de control del bucle.</td></tr>
    <tr VALIGN=top><td><code>sentencias</code></td>
      <td>Las sentencias o acciones se ejecutan si la expresión lógica es verdadera dentro del bucle.</td></tr>
  </table>
  <br>
  <h4><b>Ejercicio 2.25: </b>Escribir un programa que permita imprimir de manera ascendente los números del 1 al 10 utilizando un bucle for().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR><td>2</td> <td><p>Para:</p><p>1. Inicializar el valor del contador 'i' en uno.</p>
			<p>2. Mientras la condición sea verdadera, ejecutar las sentencias del bucle.</p>
			<p>3. Luego de cada ciclo incrementar el valor del contador en uno</p> </td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font>
                          (i = 1; i &gt;= 10; i++) &#65371;</td> </TR>
                      <TR><td>3</td><td>Imprimir el valor del contador. "</td>
                        <td><p>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</p><p>&#65373; </p></td></TR>
    
                    </TABLE> <br>
                    <h5><b>Programa 2.25: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_25"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.25 se puede ver la impresión del 1 al 10 de manera creciente.</p>
                    <h5><b>Ejecución 2.25 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.25.png" style="display:block; margin:auto; "><br>
                    <p>En la Tabla 2.25 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se incrementa en uno, mientras la condición del bucle sea verdadera.</p>
                    <h5><b>Tabla 2.25: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>1</td><td>1 &gt;=10 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>2</td><td>2 &gt;=10 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>3</td><td>3 &gt;=10 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>4</td><td>4 &gt;=10 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>5</td><td>5 &gt;=10 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>6</td><td>6 &gt;=10 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>7</td><td>7 &gt;=10 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>8</td><td>8 &gt;=10 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>9</td><td>9 &gt;=10 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>10</td><td>10 &gt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>11</td><td style="color:rgb(33, 15, 201)">11 &gt;=10 (F)</td><td> </td></tr>
                      
                    </table>
                    <br>
                    <h4><b>Ejercicio 2.26: </b>Escribir un programa que permita imprimir de manera descendente los números del 10 al 1 utilizando un bucle for().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR><td>2</td><td><p>Para:</p><p>1. Inicializar el valor del contador 'i' en diez.</p><p>2. Mientras la condición sea verdadera, ejecutar las sentencias del bucle.</p><p>3. Luego de cada ciclo decrementar el valor del contador en uno.</p></td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for</font>
                          (i = 10; i &lt;= 1; i--) &#65371;</td> </TR>
                      <TR><td>3</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;<p> &#65373;</p></td></TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.26: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_26"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.26 se puede ver la impresión del 10 al 1 de manera decreciente.</p>
                    <h5><b>Ejecución 2.26 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.26.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.26 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en uno, mientras la condición del bucle sea verdadera.</p>
                    <h5><b>Tabla 2.26: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &lt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>10</td><td>10 &lt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>9</td><td>9 &lt;=1 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>8</td><td>8 &lt;=1 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>7</td><td>7 &lt;=1 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>6</td><td>6 &lt;=1 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>5</td><td>5 &lt;=1 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>4</td><td>4 &lt;=1 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>3</td><td>3 &lt;=1 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>2</td><td>2 &lt;=1 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>1</td><td>1 &lt;=1 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>0</td><td style="color:rgb(33, 15, 201)">0 &lt;=1 (F)</td><td> </td></tr>
                      
                    </table><br>
                    <h4><b>Ejercicio 2.27: </b>Escribir un programa que permita imprimir de manera ascendente los números pares del 2 al 10 utilizando un bucle for().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      
                      <TR><td>2</td> <td><p>Para:</p><p>1. Inicializar el valor del contador 'i' en dos.</p><p>2. Mientras la condición sea verdadera, ejecutar las sentencias del bucle.</p><p>3. Luego de cada ciclo incrementar el valor del contador en dos.</p></td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font>
                          (i = 2; i &gt;=10; i=i+2) &#65371;</td> </TR>
                      <TR><td>3</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;<p>&#65373; </p></td></TR>
                    
                    </TABLE> <br>
                    <h5><b>Programa 2.27: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_27"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.27 se puede ver la impresión de los números pares del 2 al 10 de manera creciente.</p>
                    <h5><b>Ejecución 2.27 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.27.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.27 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se incrementa en dos, mientras la condición del bucle sea verdadera.
</p>
                    <h5><b>Tabla 2.27: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>2</td><td>2 &gt;=10 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>4</td><td>4 &gt;=10 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>6</td><td>6 &gt;=10 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>8</td><td>8 &gt;=10 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>10</td><td>10 &gt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>12</td><td>12 &gt;=10 (F)</td><td> </td></tr>                      
                    </table> <br>
 <h4><b>Ejercicio 2.28: </b>Escribir un programa que permita imprimir de manera descendente los números impares del 9 al 1 utilizando un bucle for().
</h4>
                    <br>
                     <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      
                      <TR><td>2</td> <td><p>Para:</p><p>1. Inicializar el valor del contador 'i' en nueve.</p><p>2. Mientras la condición sea verdadera, ejecutar las sentencias del bucle.</p><p>3. Luego de cada ciclo decrementar el valor del contador en dos.</p></td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font>
                          (i = 9; i &lt;=10; i=i-2) &#65371;</td> </TR>
                      <TR><td>3</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;<p>&#65373; </p></td></TR>
                    
                    </TABLE> <br>
                    <h5><b>Programa 2.28: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_28"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.28 se puede ver la impresión del 9 al 1 de manera decreciente.
</p>
                    <h5><b>Ejecución 2.28 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.28.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.28 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en dos, mientras la condición del bucle sea verdadera.

</p>
                    <h5><b>Tabla 2.28: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=1</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>9</td><td>9 &gt;=1 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>7</td><td>7 &gt;=1 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>5</td><td>5 &gt;=1 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>3</td><td>3 &gt;=1 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>1</td><td>1 &gt;=1 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>-1</td><td>-1 &gt;=1 (F)</td><td> </td></tr>                      
                    </table> <br>
            
                    <h1><b>Caso de Estudio 2.21: Sumatoria de una sucesión.</b></h1>
                    <h2><b>A) Problema</b></h2>
                    <p>Dada la sucesión:</p>
                     <table align="right">
                      <td width="350"><em>S <sub>n</sub> = (1,2,3,4,5,6, ...,n) </em></td>
                    <td align="right">(1)</td>
                    </table>
                    <br><br>

                    <p>Donde la fórmula de la sumatoria de los n-términos es:</p>
                    
                    <table align="right">
                      <td width="350"><em> S<sub>n</sub> = &Sigma; <sup><font size="2">&#x221e;</font></sup><sub><font size="2">n=1</font></sub>
                         n</em></td>
                    <td align="right">(2)</td>
                    </table><br>
                    <h2><b>B) Análisis</b></h2>
                    <p>Claramente se puede ver que la única entrada del problema es el número de términos de la sucesión. Se requiere una sola salida que es el valor de la sumatoria de la sucesión. El proceso de cálculo requiere que la sucesión numérica infinita de la ecuación (2), se convierta a una sucesión numérica finita, donde el valor de ‘n’ se convierte en el valor de ‘i’ y el valor de infinito pasa a ser el valor de ‘n’, ya que si se quiere calcular la sumatoria de los cinco primeros términos de la sucesión, la sumatoria iría desde el valor de i = 1 hasta el valor de i = 5, como se puede ver en la ecuación (3):</p>
          
          <table align="right">
            <td width="350"><em> S<sub>n</sub> = &Sigma; <sup><font size="2">&#x221e;</font></sup><sub><font size="2">i=1</font></sub>
               i</em></td>
          <td align="right">(3)</td>
          </table><br>
          <p>Como se puede ver en la ecuación (3) se requiere utilizar un solo bucle para calcular la sumatoria de la sucesión.</p> 
        <h3><b>B.1) Requerimiento de los Datos</b></h3>
                    <p><b>Entradas del Programa</b></p>
                        
          <table>
                        <tr><td width="200"> n </td><td width="200">/* número de términos de la sucesión */</td></tr>
                      </table><br>
                      <p><b>Salidas del Problema</b></p>
                      <table>
                        <tr><td width="200"> sum </td><td width="200">/* Acumulador de sumas  */</td></tr>
                      </table><br>
          <p><b>Auxiliares del Problema</b></p>
                    <table>
          <tr><td width="200">i</td><td width="200">/* Contador para controlar la sumatoria */</td></tr>
                   </table><br>
                      <p><b>Fórmulas Relevantes</b></p>
                      <table>
                    <tr><td width="120"><em>sum = sum + valor</em></td><td width="30"> (1) </td><td width="280">/* Fórmula que representa el acumulador de una sumatoria */</td></tr>
                      <tr><td width="120"><em> S<sub>n</sub> = &Sigma; <sup><font size="2">&#x221e;</font></sup><sub><font size="2">i=1</font></sub>
                        i</em></td><td width="30"> (2) </td><td width="280">/* Fórmula que representa la sumatoria de la sucesión finita  */</td></tr>
                      </table> <br>
      
                      <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                      <p>En la Figura 2.21.1 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘n’; b) Salidas: la variable ‘sum’; c) Auxiliares: el contador ‘i’.</p>
                      <img src="./assets/images/Capitulos/II/media/Figura 2.21.1.png" style="display:block; margin:auto; "><br>
                      <h5 style="text-align:center"><b>Figura 2.20.3. </b>Diagrama de Entrada-Salida del Programa.</h5>
                      <h2><b>C) Diseño</b></h2>
                      <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                      
            <p><b>Algoritmo</b></p>
                      <ol type="1">
                        <li>1.	Imprimir el mensaje de información: Sn = (1, 2, 3, 4, 5, 6, 7, ..., n).</li>
                        <li>2.	Leer el número de términos de la serie, utilizando la variable ‘n’.</li>
                       <li>3.	Inicializar con el valor de cero el acumulador de sumas cuya variable utilizada es ‘sum’.</li>                  
          <li>Para el bucle, hacer:</li>
                        <ol type="1" start="4">
                          <li>1. Inicializar el valor del contador ‘i’ en uno. </li>
                        </ol><ol type="1" start="4">
                          <li>2. Mientras el valor de la condición (i &gt;= n), sea verdadera, ejecutar las sentencias del bucle.</li>
                        </ol><ol type="1" start="4">
                          <li>3. Luego de cada iteración incrementar en uno el valor del contador ‘i’. </li>
                        </ol><ol type="1" start="5">
                          <li>4. Asignar al acumulador 'sum' lo que tiene sumado más el valor del contador 'i'.</li>
                        </ol>
                        <li>Imprimir el valor de la sumatoria utilizando la variable ‘sum’.</li>
                      </ol>
      
                      <h2><b>D) Implementación</b></h2>
                      <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.21.1 se muestra el código del programa en C/C++.</p>
                      <h5><b>Tabla 2.21.1. </b>Programa que analiza si un número leído es palíndromo.</h5>
                      <pre><code [highlight]="prefTab2[0].tabla2_21_1"  [lineNumbers]="true"></code></pre> <br>
                      <h2>E) Pruebas</h2>
                      <p>En la Tabla 2.21.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                      <p>En la salida de la Tabla 2.21.2 se puede ver que, al ingresar el número de términos igual a 5, se obtiene la sumatoria de los primeros cinco números, es decir, 1+2+3+4+5, cuyo resultado es 15.</p>
                      <h5><b>Tabla 2.21.2.</b> Salida del programa</h5>
                      <img src="./assets/images/Capitulos/II/media/Tabla 2.21.2.png" style="display:block; margin:auto; "><br>
                     <p>En la Tabla 2.21.3, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada iteración del bucle for() se utiliza un acumulador de sumas donde se acumulan los valores parciales de la sucesión. Finalmente, la ejecución del bucle termina cuando la condición de esta sentencia se hace falsa.</p>
                     <h5><b>Tabla 2.21.3. </b>Prueba de escritorio del programa.</h5>
                      <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>n</td><td>i</td><td>i &gt= n</td><td>sum</td></tr>
                      <tr><td>5</td><td>1</td><td>1 &gt= 5 (V)</td><td>0</td></tr>
                      <tr><td></td><td>2</td><td>2 &gt= 5 (V)</td><td>0 + 1 = 1</td></tr>
                      <tr><td></td><td>3</td><td>3 &gt= 5 (V)</td><td>1 + 2 = 3</td></tr>
                      <tr><td></td><td>4</td><td>4 &gt= 5 (V)</td><td>3 + 3 = 6</td></tr>
                      <tr><td></td><td>5</td><td>5 &gt= 5 (V)</td><td>6 + 4 = 10</td></tr>
                      <tr><td></td><td>6</td><td style="color:(33, 15, 201)">6 &gt= 5 (F)</td><td>10 + 5 = 15</td></tr>
                      
                     </table> <br>


            <h1><b>Caso de Estudio 2.22: Factorial de un Número.</b></h1>
                     <h2><b>A) Problema</b></h2>
                     <p>El factorial de un número se define como el producto de todos los enteros positivos desde 1 hasta n:</p>
                     <table align="right">
                      <td width="350"><em>n! = 1∙2∙3∙4∙5∙6∙7∙...∙n</em></td>
                    <td align="right">(1)</td>
                    </table><br>
                     <p>Por ejemplo: 5!=1∙2∙3∙4∙5=120</p>
                     <p>Donde la fórmula del factorial de un número se puede representar como un producto de números de una sucesión, como se puede ver a continuación:</p>
                     <table align="right">
                      <td width="350"><em> n! = &prod; <sup><font size="2">&#x221e;</font></sup><sub><font size="2">n=1</font></sub> 
                         n</em></td>
                    <td align="right">(2)</td>
                    </table><br>
                    <p>Escribir un programa que permita calcular el factorial de un número, utilizando un bucle.</p>

                     <h2><b>B) Análisis</b></h2>
                     <p>Claramente se puede ver que la única entrada del problema es un número entero positivo. Se requiere una sola salida que es el valor del producto de la sucesión o el factorial de un número. El proceso de cálculo requiere que la sucesión numérica infinita de la ecuación (2), se convierta a una sucesión numérica finita, donde el valor de ‘n’ se convierte en el valor de ‘i’ y el valor de infinito pasa a ser el valor de ‘n’, ya que si se quiere calcular el producto de los cinco primeros términos de la sucesión o el factorial de 5, es decir, 5!, el producto iría desde el valor de i = 1 hasta el valor de i = 5, como se puede ver en la ecuación (3):</p>
                     <table align="right">
                      <td width="350"><em> n! = &prod; <sup><font size="2">&#x221e;</font></sup><sub><font size="2">i=1</font></sub> 
                         i</em></td>
                    <td align="right">(3)</td>
                    </table><br>
                     <p>Como se puede ver en la ecuación (3) se requiere utilizar un solo bucle para calcular el producto de la sucesión.</p>
                     
         <h3><b>B.1) Requerimiento de los Datos</b></h3>
                     <p><b>Entradas del Programa</b></p>
                         
           <table>
                         <tr><td width="200"> n </td><td width="200">/* número entero positivo a calcular */</td></tr>
                       </table><br>
                       <p><b>Salidas del Problema</b></p>
                       <table>
                         <tr><td width="200"> prod </td><td width="200">/* Acumulador de productos */</td></tr>
                      </table><br>
           <p><b>Auxiliares del Problema</b></p>
                     <table>
                       
           <tr><td width="200">i</td><td width="200">/* Contador para controlar el producto */</td></tr>
                    </table><br>
                       <p><b>Fórmulas Relevantes</b></p>
                       <table>
           <tr><td width="120"><em>prod = prod x valor</em></td><td> (1) </td><td>/* Fórmula que representa el acumulador de un producto  */</td></tr>
                       <tr><td width="120"><em>n! = &prod; <sup><font size="2">&#x221e;</font></sup><sub><font size="2">i=1</font></sub> 
                        i</em></td><td width="30"> (2) </td><td width="280">/* Fórmula que representa el producto de la sucesión finita o el factorial de un número */</td></tr>
                        </table> <br>
       
                       <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                       <p>En la Figura 2.22.1 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘n’; b) Salidas: la variable ‘prod’; c) Auxiliares: el contador ‘i’.</p>
                       <img src="./assets/images/Capitulos/II/media/Figura 2.22.1.png" style="display:block; margin:auto; "><br>
                       <h5 style="text-align:center"><b>Figura 2.22.1. </b>Diagrama de Entrada-Salida del Programa.</h5>
                       <h2><b>C) Diseño</b></h2>
                       <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                       
             <p><b>Algoritmo</b></p>
                       <ol type="1">
                         <li>Imprimir el mensaje de información: n! = 1∙2∙3∙4∙5∙6∙7∙…∙n.</li>
                         <li>Leer un número entero positivo, utilizando la variable ‘n’.</li>
           <li>Inicializar con el valor de uno el acumulador de productos cuya variable utilizada es ‘prod’.</li>
          <li>Para el bucle, hacer:</li>
                         <ol type="1" start="4">
                           <li>1. Inicializar el valor del contador ‘i’ en uno. </li>
                         </ol><ol type="1" start="4">
                           <li>2. Mientras el valor de la condición (i <= n), sea verdadera, ejecutar las sentencias del bucle. </li>
                         </ol><ol type="1" start="4">
                           <li>3. Luego de cada iteración incrementar en uno el valor del contador ‘i’. </li>
                         </ol><ol type="1" start="4">
                           <li>4. Asignar al acumulador 'prod' lo que tiene multiplicado por el valor del contador 'i'.</li>
                           </ol>
                         <li>5.	Imprimir el valor del producto calculado o del factorial de un número, utilizando la variable ‘prod’.</li>
                       </ol>
       
                       <h2><b>D) Implementación</b></h2>
                       <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.22.1 se muestra el código del programa en C/C++.</p>
                       <h5><b>Tabla 2.22.1. </b>Programa que calcula el factorial de un número entero positivo.</h5>
                       <pre><code [highlight]="prefTab2[0].tabla2_22_1"  [lineNumbers]="true"></code></pre> <br>
                       <h2>E) Pruebas</h2>
                       <p>En la Tabla 2.22.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                       <p>En la salida de la Tabla 2.22.2 se puede ver que, al ingresar el número de términos igual a 5, se obtiene el producto de los primeros cinco números, es decir, 1*2*3*4*5, cuyo resultado es 120, que corresponde al factorial de 5 (5!).</p>
                       <h5><b>Tabla 2.22.2.</b> Salida del programa</h5>
                       <img src="./assets/images/Capitulos/II/media/Tabla 2.22.2.png" style="display:block; margin:auto; "><br>
                       <p>En la Tabla 2.22.3, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada iteración del bucle for() se utiliza un acumulador de productos donde se acumulan los valores parciales de la sucesión o del factorial de un número. Finalmente, la ejecución del bucle termina cuando la condición de esta sentencia se hace falsa.</p>
                      <h5><b>Tabla 2.22.3. </b>Prueba de escritorio del programa.</h5>
                      <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                        <tr style="color:red"><td>n</td><td>i</td><td>i &gt= n</td><td>prod</td></tr>
                        <tr><td>5</td><td>1</td><td>1 &gt= 5 (V)</td><td>0</td></tr>
                        <tr><td></td><td>2</td><td>2 &gt= 5 (V)</td><td>0 x 1 = 1</td></tr>
                        <tr><td></td><td>3</td><td>3 &gt= 5 (V)</td><td>1 x 2 = 2</td></tr>
                        <tr><td></td><td>4</td><td>4 &gt= 5 (V)</td><td>2 x 3 = 6</td></tr>
                        <tr><td></td><td>5</td><td>5 &gt= 5 (V)</td><td>6 x 4 = 24</td></tr>
                        <tr><td></td><td>6</td><td><font color="blue"> 6 &gt= 5 (F)</font></td><td>24 x 5 = 120</td></tr>
                        
                       </table> <br>
                       <h1><b>Caso de Estudio 2.23: Sucesión de Fibonacci Iterativa.</b></h1>
                       <h2><b>A) Problema</b></h2>
                       <p>La sucesión o serie de Fibonacci es una sucesión infinita de números naturales que comienza con los números 0 y 1, donde a partir de estos números cada término es la suma de los dos anteriores:</p>
                       <p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …</p>
                       <p>A los elementos de esta sucesión se los llama los números de Fibonacci en honor a Leonardo de Pisa, matemático italiano del siglo XIII (Vorobiov, N.N.; 1974). Esta sucesión tiene muchas aplicaciones en varias áreas como las Matemáticas, Computación, Teoría de Juegos, Biología, entre otras. Como, por ejemplo: las ramas de los árboles, la disposición de las hojas en el tallo de un árbol, en las flores de alcachofas, en las flores de los girasoles, en la configuración de las piñas coníferas, en los números de parejas de conejos, etc.</p>
                       <p>Los números de Fibonacci quedan definidos por las ecuaciones:</p>
                       <table align="right">
                        <tr><td width="350"><em> f<sub>0</sub> = 0 <p>f<sub>1</sub>=1</p></em></td>
                          <td align="right">Ec. 2.23.1</td></tr>
                      <tr><td><em>f<sub>n</sub> = f<sub>n-2</sub> + f <sub>n-1</sub></em></td><td>Ec. 2.23.2</td></tr>
                      </table><br><br><br><br><br>
                      <p>Esto produce los siguientes números:</p>
                      <table align="center">
                          <tr><td><em>f<sub>0</sub> = 0</em></td></tr>
                          <tr><td><em>f<sub>1</sub> = 1</em></td></tr>
                          <tr><td><em>f<sub>2</sub> = 1</em></td></tr>
                          <tr><td><em>f<sub>3</sub> = 2</em></td></tr>
                          <tr><td><em>f<sub>4</sub> = 3</em></td></tr>
                          <tr><td><em>f<sub>5</sub> = 5</em></td></tr>
                          <tr><td><em>f<sub>6</sub> = 8</em></td></tr>
                          <tr><td><em>f<sub>7</sub> = 13</em></td></tr>
                          <tr><td><em>f<sub>8</sub> = 21</em></td></tr>
                          <tr><td><em>f<sub>9</sub> = 34</em></td></tr>
                          <tr><td>...</td></tr>
                      </table><br>
                      <p>Esta manera de definir la sucesión se la considera algorítmica y es parte del estudio en las Matemáticas Discretas.</p>
                       <h2><b>B) Análisis</b></h2>
                       <p>Claramente se puede ver que la única entrada del problema es el número de Fibonacci que se desea calcular. Hay una sola salida requerida que es el n-ésimo término de la serie. Para resolver este ejercicio, se va a utilizar tres sentencias if-else anidadas y un bucle for(), que es una solución iterativa muy eficiente. De acuerdo con la Ec. 2.23.2 (caso general), la serie de Fibonacci se puede representar por una sucesión recurrente donde el n-ésimo término se obtiene sumando los dos anteriores términos de la sucesión, partiendo de los casos simples de la Ec. 2.23.1. </p>
           <h3><b>B.1) Requerimiento de los Datos</b></h3>
                       <p><b>Entradas del Programa</b></p>
                           
             <table>
                           <tr><td width="200"> n</td><td width="200">/* término de la sucesión a calcular */</td></tr>
                         </table><br>
                         <p><b>Salidas del Problema</b></p>
                         <table>
                           <tr><td width="200"> c </td><td width="200">/* n-ésimo término de la sucesión calculado */</td></tr>
                            </table><br>
             <p><b>Auxiliares del Problema</b></p>
             <table>
              <tr><td width="200"> a </td><td width="200">/* primer término de la sucesión recurrente */</td></tr>
              <tr><td width="200"> b </td><td width="200">/* segundo término de la sucesión recurrente */</td></tr>
              <tr><td width="200"> i </td><td width="200">/* contador que controla el bucle for() */</td></tr>
            </table><br>
                         <p><b>Fórmulas Relevantes</b></p>
                         <table>
             <tr><td ><em>f<sub>0</sub>=0</em><p><em>f<sub>1</sub>=1</em></p></td><td> (1) </td><td>/* Condiciones iniciales del problema (casos especiales) */</td></tr>
                         <tr><td width="120"><em>f<sub>n</sub> = f<sub>n-2</sub> + f <sub>n-1</sub></em></td><td width="30"> (2) </td><td width="280">/* Fórmula general que calcula el n-ésimo término de la sucesión de Fibonacci */</td></tr>
                            </table> <br>
         
                         <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                         <p>En la Figura 2.23.1 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘n’; b) Salidas: la variable ‘c’; c) Auxiliares: el contador ‘i’; la variable ‘a’; la variable ‘b’.</p>
                         <img src="./assets/images/Capitulos/II/media/Figura 2.23.1.png" style="display:block; margin:auto; "><br>
                         <h5 style="text-align:center"><b>Figura 2.23.1. </b>Diagrama de Entrada-Salida del Programa.</h5>
                         <h2><b>C) Diseño</b></h2>
                         <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                         
               <p><b>Algoritmo</b></p>
                         <ol type="1">
                           <li>Imprimir el mensaje de información: <p>f(n) = 0+1+1+2+3+5+8+13+21+34+55+89+...</p></li>
                           <li>Leer el término de la sucesión recurrente a calcular, utilizando la variable ‘n’.</li>
             <li>Asignar a la variable 'a' el valor de cero.</li>
             <li>Asignar a la variable 'b' el valor de uno.</li> 
             <li>Si el valor de 'n' es igual a cero.</li>   
             <ol type="1" start="5">
              <li>1. Asignar a la la variable 'c' el valor de la variable 'a'.</li>
            </ol>
            <li>Caso contrario, si el valor de 'n' es igual a uno.</li>
            <ol type="1" start="6">
              <li>1. Asignar a la la variable 'c' el valor de la variable 'b'.</li>
            </ol>
             <li>7.	Caso contrario, si el valor de 'n' es mayor o igual a dos.</li>
             <ol type="1" start="7">
              <li>1. Para el bucle, hacer: </li>
            
            <ol type="1" start="7">
             <li>1.1.	Inicializar el valor del contador 'i' en dos. </li>
            </ol><ol type="1" start="7">
                             <li>1.2.	Mientras el valor de la condición (i &gt;= n) sea verdadera, ejecutar las sentencias del bucle. </li>
                           </ol><ol type="1" start="7">
                             <li>1.3.	Luego de cada iteración incrementar en uno el valor del contador ‘i’. </li>
                           </ol><ol type="1" start="7">
                             <li>1.4.	Asignar a la la variable 'c' la suma de a + b.</li>
                             </ol><ol type="1" start="7">
                              <li>1.5.	Asignar a la la variable 'b' el valor de la variable 'c'.</li>
                              </ol></ol> 
                           <li>8.	Imprimir el valor de la variable 'n' y de la variable 'c'.</li>        
                         </ol>
         
                         <h2><b>D) Implementación</b></h2>
                         <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.23.1 se muestra el código del programa en C/C++.</p>
                         <h5><b>Tabla 2.23.1. </b>Programa que analiza si un número leído es palíndromo.</h5>
                         <pre><code [highlight]="prefTab2[0].tabla2_23_1"  [lineNumbers]="true"></code></pre> <br>
                         <h2>E) Pruebas</h2>
                         <p>En la Tabla 2.23.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                         <p>En la salida de la Tabla 2.23.2 se puede ver que, al ingresar el valor de ‘n’ igual a 6, se otiene el sexto término de la sucesión de Fibonacci que es el valor de 8.</p>
                         <h5><b>Tabla 2.23.2.</b> Salida del programa</h5>
                         <img src="./assets/images/Capitulos/II/media/Tabla 2.23.2.png" style="display:block; margin:auto; "><br>
                         <p>En la Tabla 2.23.3, se muestra la prueba de escritorio del programa, donde se puede comprobar que se utilizan tres sentencias if-else anidadas, donde en este caso se evalúa la sentecia if-else cuya condición (n>=2) es verdadera. Luego, se utiliza un bucle for() que comienza con el contador igual a 2 y se ejecuta mientras la condición (n>=2) es verdadera. En cada iteración del bucle, la variable ‘a’ toma el valor de la variable ‘b’ y la variable ‘b’ toma el valor de la variable ‘c’. Finalmente, la ejecución del bucle termina cuando la condición de esta sentencia se hace falsa y se imprime el valor de la variable ‘c’ que corresponde al sexto termino de la sucesión de Fibonacci que es igual al valor de 8.</p>
                        <h5><b>Tabla 2.23.3. </b>Prueba de escritorio del programa.</h5>
                         <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                         <tr style="color:red"><td>n</td><td>a</td><td>b</td><td>c</td><td>n == 0</td><td>n==1</td><td>n &lt;= 2</td><td>i</td><td>i &gt;= n</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          <font color="#900C3F">"f("</font>
                          <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          <font color="black">n</font> 
                          <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          <font color="#900C3F">")="</font>
                          <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          <font color="black">c</font> 
                          <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          <font color="black"> endl;</font>
                        </td></tr>
                        <tr><td>6</td><td>0</td><td>1</td><td>1</td><td>6 == 0 (F)</td><td>6 == 1 (F)</td><td>6 &lt;= 2 (V)</td><td>2</td><td>2 &gt;= 6 (V)</td><td></td></tr>
                        <tr><td></td><td>1</td><td>1</td><td>2</td><td></td><td></td><td></td><td>3</td><td>3 &gt;= 6 (V)</td><td></td></tr>
                        <tr><td></td><td>1</td><td>2</td><td>3</td><td></td><td></td><td></td><td>4</td><td>4 &gt;= 6 (V)</td><td></td></tr>
                        <tr><td></td><td>2</td><td>3</td><td>5</td><td></td><td></td><td></td><td>5</td><td>5 &gt;= 6 (V)</td><td></td></tr>
                        <tr><td></td><td>3</td><td>5</td><td>8</td><td></td><td></td><td></td><td>6</td><td>6 &gt;= 6 (V)</td><td></td></tr>
                        <tr><td></td><td>5</td><td>8</td><td>0</td><td></td><td></td><td></td><td>7</td><td><font color="blue"> 7 &gt;= 6 (F)</font></td><td>f(6) = 8</td></tr>
                         
                        </table> <br>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.4.4. Bucles anidados">
              <ng-template matTabContent>
               <br>
               <h1>Bucles anidados</h1>
                <p>En el lenguaje C/C++ es posible anidar bucles, donde estos bucles anidados constan de un bucle externo con uno o más bucles internos. Cada vez que se repite el bucle externo, los bucles internos se repiten y se ejecutan las sentencias de estos bucles. Se pueden combinar bucles for() entre sí, pero también se pueden combinar bucles for() con bucles while() y do-while() en diferente orden, por ejemplo:</p>
                <p><b>Ejemplo 1:</b>Combinación de un bucle do-while() anidado con un bucle for().</p>
 <pre><code align="left">do &#65371;
      for()
      &#65371;
          sentencia<sub>1</sub>;
          sentencia<sub>2</sub>;
          ...
          sentencia<sub>n</sub>;
      &#65373;
&#65373; while();</code></pre>
                <p><b>Ejemplo 2:</b>Combinación de un bucle for() anidado con un bucle while().</p>
 <pre><code align="left">for() 
&#65371;
      while()
      &#65371;
          sentencia<sub>1</sub>;
          sentencia<sub>2</sub>;
          ...
          sentencia<sub>n</sub>;
      &#65373;
&#65373;</code></pre>
              <p><b>Ejemplo 3:</b>Combinación de tres bucles for() anidados.</p>
<pre><code align="left">for() 
&#65371;
     for()
     &#65371;
          for()
          &#65371;
                sentencia<sub>1</sub>;
                sentencia<sub>2</sub>;
                ...
                sentencia<sub>n</sub>;
          &#65373;
     &#65373;
&#65373;</code></pre>
          <p><b>Ejemplo 4:</b>Combinación de un bucle for() anidado con otros dos bucles for().</p>
<pre><code align="left">for() 
&#65371;
    for()
    &#65371;
          sentencia<sub>1.1</sub>;
          sentencia<sub>1.2</sub>;
          ...
          sentencia<sub>1.n</sub>;
    &#65373;
    for()
    &#65371;
          sentencia<sub>1</sub>;
          sentencia<sub>2</sub>;
          ...
          sentencia<sub>n</sub>;
    &#65373;
&#65373;</code></pre><br>
                 <h4><b>Ejercicio 2.29: </b>Escribir un programa que permita visualizar un triángulo rectángulo isósceles de asteriscos. Así, por ejemplo, si el valor del lado del triángulo es igual a 5, se obtendrá la siguiente figura:</h4>
                   <table border="1" align="center" cellspacing="0" cellpadding="5" >
                     <tr><td width="100"><p>*</p><p>**</p><p>***</p><p>****</p><p>*****</p></td></tr>
                   </table><br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5" >
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="350"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : lado</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          lado;</td>
                      </TR>
                      <TR> <td>2</td>  <td>entero : f</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          f;</td>
                      </TR>
                      <TR> <td>3</td>  <td>entero : a</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          a;</td>
                      </TR>
                      <TR>
                        <td>4</td>
                        <td>Leer el valor del lado</td>
                        <td>cin <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> lado</td>
                      </TR>
                      <TR><td>5</td> <td>Para: <p>1. Inicializar el valor del contador de las filas ‘f’ en uno.</p>
                      <p>2. Mientras la condición (f &lt;= lado) sea verdadera, ejecutar las sentencias del bucle externo.</p>
                    <p>3. Luego de cada ciclo incrementar el valor del contador de las filas ‘f’ en uno</p></td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font> (f = 1; f &lt;= lado; f++) 
                         &#65371;</td> </TR>
                      <TR><td>6</td><td>Para: <p>1. Inicializar el valor del contador de las columnas de asteriscos ‘a’ en uno.</p>
                      <p>2. Mientras la condición (a &lt;= f) sea verdadera, ejecutar las sentencias del bucle interno.</p>
                    <p>3. Luego de cada ciclo incrementar el valor del contador de las columnas de asteriscos ‘a’ en uno.</p></td>
                    <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font> (a = 1; a &lt;= f; a++) &#65371;</td> </TR>   
                    <tr><td>7</td><td>Imprimir un asterisco por columna.</td> <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font>
                          <font color="red">"*"</font>;<p>&#65373;</p></td></tr>
                  <tr><td>8</td><td>Imprimir un salto de línea (INTRO).</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font>
                        endl;<p>&#65373;</p></td></tr>
                        
                    </TABLE> <br>

                    <h5><b>Programa 2.29: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_29"  [lineNumbers]="true"></code></pre>
                   <p>En la salida de la Ejecución 2.29 se puede ver la impresión del triángulo rectángulo isósceles de asteriscos de lado igual a 5.</p>
                    <h5><b>Ejecución 2.29 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.29.png" style="display:block; margin:auto; "><br>
                    <p>En la Tabla 2.29 se puede ver la prueba de escritorio del programa, donde la impresión del triángulo rectángulo isósceles se realiza mediante un bucle externo y un bucle interno. Cada vez que se repite el bucle externo, se ejecuta el bucle interno. </p>
                    <p>El bucle externo se repite cinco veces en este caso, según la condición que depende del valor del lado del triangulo rectángulo y se controla con el contador de las filas ‘f’. El número de repeticiones realizadas por el bucle interno se controla con el contador de los asteriscos ‘a’ cuya condición depende del valor de las filas ‘f’ del triángulo rectángulo, donde este bucle se encarga de manejar la impresión de los asteriscos.</p>
                    <h5><b>Tabla 2.29: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5" style="font-size:x-small"> 
                      <tr style="color:red"><td>lado</td><td>f</td><td>f &lt;= lado</td><td>a</td><td>a &lt;= f</td><td>cout &lt;&lt; "*"; </td><td>cout &lt;&lt; endl;</td></tr>
                      <tr><td HEIGHT="50">5</td><td>1</td><td>1 &lt;= 5 (V)</td><td>1</td><td>1 &lt;= 1 (V)</td><td>*</td><td></td></tr>
                      <tr><td HEIGHT="30"></td><td></td><td></td><td>2</td><td style="color:rgb(33, 15, 201)">2 &lt;= 1 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td>1</td><td>1 &lt;= 2 (V)</td><td>**</td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>3</td><td>2 &lt;= 2 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>3</td><td style="color:rgb(33, 15, 201)">3 &lt;= 2 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td>1</td><td>1 &lt;= 3 (V)</td><td>***</td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>2</td><td>2 &lt;= 3 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>3</td><td>3 &lt;= 3 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>4</td><td style="color:rgb(33, 15, 201)">4 &lt;= 3 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td>1</td><td>1 &lt;= 4 (V)</td><td>****</td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>2</td><td>2 &lt;= 4 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>3</td><td>3 &lt;= 4 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>4</td><td>4 &lt;= 4 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>5</td><td style="color:rgb(33, 15, 201)">5 &lt;= 4 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td>1</td><td>1 &lt;= 5 (V)</td><td>*****</td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>6</td><td style="color:rgb(33, 15, 201)">2 &lt;= 5 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td>6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (V)</td><td></td><td></td><td></td><td></td></tr>
                       
                    </table>
                    <br>
                   <h4><b>Ejercicio 2.30: </b>Escribir un programa que permita visualizar un rectángulo de asteriscos. Así, por ejemplo, si el valor del lado del triángulo es igual a 5, se obtendrá la siguiente figura:</h4>
                   
		<table border="1" align="center" cellspacing="0" cellpadding="5">
                     <tr><td width="100"><p>*****</p><p>*****</p><p>*****</p><p>*****</p></td></tr>
                   </table><br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : ancho</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          ancho;</td>
                      </TR>
			<TR> <td>2</td>  <td>entero : largo</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          largo;</td>
                      </TR>
                      <TR> <td>3</td>  <td>entero : f</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          f;</td>
                      </TR>
                      <TR> <td>4</td>  <td>entero : a</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          a;</td>
                      </TR>
                      <TR>
                        <td>5</td>
                        <td>Leer el valor del ancho</td>
                        <td>cin <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> ancho</td>
                      </TR>
			<TR>
                        <td>6</td>
                        <td>Leer el valor del largo</td>
                        <td>cin <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> largo</td>
                      </TR>
                      <TR><td>7</td> <td>Para: <p>1. Inicializar el valor del contador de las filas ‘f’ en uno.</p>
                      <p>2. Mientras la condición (f &lt;= largo) sea verdadera, ejecutar las sentencias del bucle externo.</p>
                    <p>3. Luego de cada ciclo incrementar el valor del contador de las filas ‘f’ en uno</p></td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font> (f = 1; f &lt;= largo; f++) 
                         &#65371;</td> </TR>
                      <TR><td>8</td><td>Para: <p>1. Inicializar el valor del contador de las columnas de asteriscos ‘a’ en uno.</p>
                      <p>2. Mientras la condición (a &lt;= ancho) sea verdadera, ejecutar las sentencias del bucle interno.</p>
                    <p>3. Luego de cada ciclo incrementar el valor del contador de las columnas de asteriscos ‘a’ en uno.</p></td>
                    <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font> (a = 1; a &lt;= ancho; a++) &#65371;</td> </TR>   
                    <tr><td>7</td><td>Imprimir un asterisco por columna.</td> <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font>
                          <font color="red">"*"</font>;<p>&#65373;</p></td></tr>
                  <tr><td>8</td><td>Imprimir un salto de línea (INTRO).</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font>
                        endl;<p>&#65373;</p></td></tr>
                        
                    </TABLE> <br>

                    <h5><b>Programa 2.30: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_30"  [lineNumbers]="true"></code></pre>
                   <p>En la salida de la Ejecución 2.30 se puede ver la impresión del rectángulo de asteriscos de ancho igual a 5 y de largo igual a 4.</p>
                    <h5><b>Ejecución 2.30 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.30.png" style="display:block; margin:auto; "><br>
                    <p>En la Tabla 2.30 se puede ver la prueba de escritorio del programa, donde la impresión del rectángulo se realiza mediante un bucle externo y un bucle interno. </p>
			<p>Cada vez que se repite el bucle externo, se ejecuta el bucle interno. El bucle externo se repite cinco veces en este caso, según la condición que depende del valor del largo del rectángulo y se controla con el contador de las filas ‘f’. El número de repeticiones realizadas por el bucle interno se controla con el contador de los asteriscos ‘a’ cuya condición depende del valor del ancho del rectángulo, donde este bucle se encarga de manejar la impresión de los asteriscos.</p>
		<h5><b>Tabla 2.30: </b>Prueba de escritorio del programa.</h5>

                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5" style="font-size:x-small" HEIGHT="50"> 
                      <tr style="color:red"><td>ancho</td><td>largo</td><td>f</td><td>f &lt;= lado</td><td>a</td><td>a &lt;= f</td><td>cout &lt;&lt; "*"; </td><td>cout &lt;&lt; endl;</td></tr>
                      <tr><td>5</td><td>4</td><td>1</td><td>1 &lt;= 4 (V)</td><td>1</td><td>1 &lt;= 5 (V)</td><td>*****</td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td></td><td>2</td><td>2 &lt;= 4 (V)</td><td>1</td><td>1 &lt;= 5 (V)</td><td>*****</td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td></td><td>3</td><td>3 &lt;= 4 (V)</td><td>1</td><td>1 &lt;= 5 (V)</td><td>*****</td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td></td><td>4</td><td>4 &lt;= 4 (V)</td><td>1</td><td>1 &lt;= 5 (V)</td><td>*****</td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td></td><td>5</td><td style="color:rgb(33, 15, 201)">5 &lt;= 4 (F)</td><td></td><td></td><td></td><td></td></tr>
 
                    </table>
                    <br>
               
                 <h4><b>Ejercicio 2.31: </b>Escribir un programa que permita visualizar un triángulo isósceles de asteriscos. Así, por ejemplo, si el valor de la altura del triángulo es igual a 5, se obtendrá la siguiente figura:</h4>
                   
		<table border="1" align="center" cellspacing="0" cellpadding="5">
                     <tr><td width="100"><p>&#9633;&#9633;&#9633;&#9633;*</p><p>&#9633;&#9633;&#9633;***</p><p>&#9633;&#9633;*****</p><p>&#9633;*******</p><p>**********</p></td></tr>
                   </table><br>

<table border="1" CELLPADDING=5 CELLSPACING=0>
                    <tr VALIGN=top><td width="50"><b> Nota:</b></td><td> Como se puede ver en la figura anterior, en cada fila mientras se reduce el número de espacios en blanco, aumenta el número de asteriscos. Con fines didácticos, el símbolo &#9633; equivale a un espacio en blanco (“ ”).</td></tr>
                  </table>
<br><br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="350"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : altura</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          altura;</td>
                      </TR>
			
                      <TR> <td>2</td>  <td>entero : f</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          f;</td>
                      </TR>

                      <TR> <td>3</td>  <td>entero : b</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          b;</td>
                      </TR>
                      <TR> <td>4</td>  <td>entero : a</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          a;</td>
                      </TR>
                      <TR>
                        <td>5</td>
                        <td>Leer el valor de la altura del triángulo isósceles</td>
                        <td>cin <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> altura</td>
                      </TR>
                      <TR><td>6</td> <td>Para: <p>1. Inicializar el valor del contador de las filas ‘f’ en uno.</p>
                      <p>2. Mientras la condición (f &lt;= altura) sea verdadera, ejecutar las sentencias del bucle externo.</p>
                    <p>3. Luego de cada ciclo incrementar el valor del contador de las filas ‘f’ en uno</p></td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font> (f = 1; f &lt;= altura; f++) 
                         &#65371;</td> </TR>
			<TR><td>7</td> <td>Para: <p>1. Inicializar el valor del contador de las columnas de blancos ‘b’ con el valor de la altura menos el número de filas.</p>
                      <p>2. Mientras la condición (b &gt;= 1) sea verdadera, ejecutar las sentencias del bucle externo.</p>
                    <p>3. Luego de cada ciclo decrementar el valor del contador de las columnas de blanco ‘b’ en uno</p></td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font> (b = altura - f; b &gt;= 1; b--) 
                         &#65371;</td> </TR>
			<TR><td>8</td><td>Imprimir un espacio en blanco por columna.</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font>  
        <font color="red"> " "</font>;<p>&#65373;</p></td></TR>
                      <TR><td>9</td><td>Para: <p>1. Inicializar el valor del contador de las columnas de asteriscos ‘a’ en uno.</p>
                      <p>2. Mientras la condición (a &lt;= ancho * f - 1) sea verdadera, ejecutar las sentencias del bucle interno.</p>
                    <p>3. Luego de cada ciclo incrementar el valor del contador de las columnas de asteriscos ‘a’ en uno.</p></td>
                    <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font> (a = 1; a &lt;= 2 * f - 1; a++) &#65371;</td> </TR>   
                    <tr><td>10</td><td>Imprimir un asterisco por columna.</td> <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font>
                          <font color="red">"*"</font>;<p>&#65373;</p></td></tr>
                  <tr><td>11</td><td>Imprimir un salto de línea (INTRO).</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font>
                        endl;<p>&#65373;</p></td></tr>
                        
                    </TABLE> <br>
                    <h5><b>Programa 2.31: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_31"  [lineNumbers]="true"></code></pre>
                   <p>En la salida de la Ejecución 2.31 se puede ver la impresión del triángulo isósceles de asteriscos de altura igual a 5.</p>
                    
<h5><b>Ejecución 2.31 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.31.png" style="display:block; margin:auto; "><br>
                   <p>En la Tabla 2.31 se puede ver la prueba de escritorio del programa, donde la impresión del triángulo isósceles se realiza mediante un bucle externo y dos bucles internos. Cada vez que se repite el bucle externo, se ejecutan los dos bucles internos. </p>
<p>El bucle externo se repite cinco veces en este caso, según la altura del triángulo y se controla con el contador de las filas ‘f’. El número de repeticiones realizadas por los bucles internos se basan en el valor del contador de las filas ‘f’. El primer bucle interno controla la impresión de los espacios en blanco con el contador ‘b’ y el segundo bucle interno controla la impresión de los asteriscos con el contador ‘a’. </p>
<h5><b>Tabla 2.31: </b>Prueba de escritorio del programa.</h5>

<table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5" style="font-size:x-small" HEIGHT="50"> 
  <tr style="color:red"><td>altura</td><td>f</td><td>f &lt;= altura</td><td>b</td><td>b &gt;= 1</td><td>cout &lt;&lt;= " ";</td><td>a</td><td>a &lt;= 2 * f - 1</td><td>cout &lt;&lt; "*"; </td><td>cout &lt;&lt; endl;</td></tr>
  <tr><td>5</td><td>1</td><td>1 &lt;= 5 (V)</td><td>4</td><td>4 &gt;= 1 (V)</td><td>&#9633;&#9633;&#9633;&#9633;</td><td>1</td><td>1 &lt;= 1 (V)</td><td>*</td><td></td></tr>
  <tr><td></td><td></td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td style="color:rgb(33, 15, 201)">2</td><td style="color:rgb(33, 15, 201)">2 &lt;= 1 (F)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td><td></td><td></td><td>INTRO</td></tr>

  <tr><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td>3</td><td>3 &gt;= 1 (V)</td><td>&#9633;&#9633;&#9633;</td><td>1</td><td>1 &lt;= 3 (V)</td><td>***</td><td></td></tr>
  <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td>2</td><td></td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>3</td><td></td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td style="color:rgb(33, 15, 201)">4</td><td style="color:rgb(33, 15, 201)"> 4 &lt;= 3 (F)</td><td></td><td>INTRO</td></tr>

  <tr><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td>2</td><td> 2 &gt;= 1 (V)</td><td>&#9633;&#9633;</td><td>1</td><td>1 &lt;= 5 (V)</td><td>*****</td><td></td></tr>
  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td>INTRO</td></tr>
  
  <tr><td></td><td>4</td><td>4 &lt;= 4 (V)</td><td>1</td><td>1 &gt;= 1 (V)</td><td>&#9633;</td><td>1</td><td>1 &lt;= 7 (V)</td><td>*******</td><td></td></tr>
  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>2</td><td>2&lt;= 7 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 7 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 7 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 7 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>6</td><td>6 &lt;= 7 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>7</td><td>7 &lt;= 7 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">8</td><td style="color:rgb(33, 15, 201)">8 &lt;= 7 (F)</td><td></td><td>INTRO</td></tr>
  
  <tr><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>1</td><td>1 &lt;= 9 (V)</td><td>*********</td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>2</td><td>2 &lt;= 9 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 9 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 9 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 9 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>6</td><td>6 &lt;= 9 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>7</td><td>7 &lt;= 9 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>8</td><td>8 &lt;= 9 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>9</td><td>9 &lt;= 9 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">10</td><td style="color:rgb(33, 15, 201)">10 &lt;= 9 (F)</td><td></td><td>INTRO</td></tr>
  
  <tr><td></td><td style="color:rgb(33, 15, 201)">6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</table>
<br>
<h1><b>Caso de Estudio 2.24: Visualización de un Rombo con Asteriscos.</b></h1>
              <h2><b>A) Problema</b></h2>
              <p>Escribir un programa que permita visualizar un rombo de asteriscos. Así, por ejemplo, si el valor de la Diagonal mayor es igual a 9 o a 10, se obtendrá la siguiente figura:</p>
              <table border="1" align="center" cellspacing="0" cellpadding="5">
                <tr><td width="200"><p>bbbb*</p><p>bbb***</p><p>bb*****</p><p>b*******</p><p>**********</p>
              <p>b*******</p><p>bb*****</p><p>bbb***</p><p>bbbb*</p>	</td></tr>
              </table><br>
              
              <table border="1" CELLPADDING=5 CELLSPACING=0>
                <tr VALIGN=top><td width="50"><b> Nota:</b></td><td>Como se puede ver en la figura anterior, en cada fila mientras se reduce el número de espacios en blanco, aumenta el número de asteriscos, tanto de arriba hacia abajo, como de abajo hacia arriba. Con fines didácticos, la letra ‘b’ en color plomo equivale a un espacio en blanco (“ ”).</td></tr>
              </table><br>
              <h2><b>B) Análisis</b></h2>
              <p>Claramente se puede ver que la única entrada del problema es el valor de la diagonal mayor del rombo. Se requieren dos salidas que son los espacios en blanco y los asteriscos de la figura geométrica controlados por los contadores ‘b’ y ‘a’ respectivamente. Se requiere una variable auxiliar llamada ‘aux’ que tiene el valor de la mitad de la diaginal del rombo. El proceso de cálculo y visualización del rombo con asteriscos requiere la utilización de bucles anidados.</p>
        	<h3><b>B.1) Requerimiento de los Datos</b></h3>
              <p><b>Entradas del Problema</b></p>		
		<table>
                  <tr><td width="200"> diagonalMayor </td><td width="200">/* Tamaño de la diagonal mayor del rombo  */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200"> Mensaje1 </td><td width="200">/* Mensaje que imprime un espacio en blanco */</td></tr>
                  <tr><td width="200"> Mensaje2 </td><td width="200">/* Mensaje que imprime un asterisco */</td></tr>
                  <tr><td width="200"> Mensaje3 </td><td width="200">/* Mensaje que imprime un INTRO */</td></tr>
                </table><br>
		<p><b>Auxiliares del Problema</b></p>
              <table>
    <tr><td width="200">altura</td><td width="200">/* Altura que representa la mitad de la diagonal mayor del rombo */</td></tr>
		<tr><td width="200">f</td><td width="200">/* Número de filas */</td></tr>
		<tr><td width="200">b</td><td width="200">/* Contador para controlar el número de espacios en blanco */</td></tr>
		<tr><td width="200">a</td><td width="200">* Contador para controlar el número de asteriscos */</td></tr>
             </table><br>
                <p><b>Fórmulas Relevantes</b></p>
                <table>
                  <tr><td><em>num = num % 2</em></td><td>(1)</td><td>/* Fórmula que calcula si un número es par */</td></tr>
                  <tr><td ><em>num = (num = 1)/2</em></td><td> (2) </td><td>/* Fórmula que obtiene la mitad de un valor impar y lo convierte a un valor par */</td></tr>
                <tr><td width="120"><em>num = num/2</em></td><td width="30"> (3) </td><td width="280">/* Fórmula que obtiene la mitad de un valor par */</td></tr>
                  <tr><td ><em>b = h - f</em></td><td> (4) </td><td>/* Fórmula que obtiene un número definido de  espacios en blanco de acuerdo al valor de la altura del triánguo isósceles y al valor de la fila */</td></tr>
                <tr><td><em>a = 2 * f - 1</em></td><td>(5)</td><td>/* Fórmula que obtiene un número impar de  asteriscos de acuerdo al valor de la fila */</td></tr>
                </table> <br>

                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.24.1 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘diagonalMayor’; b) Salidas: Mensaje1 que imprime un espacio en blanco; Mensaje2 que imprime un asterisco; Mensaje3 que imprime un INTRO; c) Auxiliares: la variable ‘altura’; la variable ‘f’; la variable ‘b’; la variable ‘a’.</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.24.1.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.24.1. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                
			<p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el valor de la diagonal mayor del rombo.</li>
                  <li>Si el valor de la diagonal mayor es impar, entonces</li>
                  <ol type="1" start="2">
                    <li>1. Asignar a la variable ‘altura’ el valor de la diagonal mayor más uno dividido para dos.</li>
                  </ol>
		<li>Caso contrario,</li>
    <ol type="1" start="3">
      <li>Asignar a la variable ‘altura’ el valor de la mitad de la diagonal mayor.</li>
    </ol>
		<li>Para el bucle externo, hacer: </li>                  
                  <ol type="1" start="4">
                    <li>1. Inicializar el valor del contador de las filas ‘f’ en uno. </li>
                  </ol><ol type="1" start="4">
                    <li>2. Mientras el valor de la condición (f &lt;= altura), sea verdadera, ejecutar las sentencias del bucle. </li>
                  </ol><ol type="1" start="4">
                    <li>3. Luego de cada iteración incrementar en uno el valor del contador de las filas ‘f’. </li>
                  </ol><ol type="1" start="4">
                    <li>4. Para el bucle interno, hacer: </li>
                    <ol type="1" start="4">
                      <li>4.1.	Inicializar el valor de las columnas de blancos ‘b’ con el valor de la variable 'altura' menos el número de filas.  </li></ol>
                      <ol type="1" start="4">
                        <li>4.2.	Mientras la condición (b &gt;= 1) sea verdadera, ejecutar las sentencias del bucle interno.  </li></ol>
                        <ol type="1" start="4">
                          <li>4.3.	Luego de cada iteración decrementar el valor de las columnas de blancos ‘b’ en uno. </li></ol>
                          <ol type="1" start="4">
                            <li>4.4.	Imprimir un espacio en blanco por columna. </li></ol>
                  </ol><ol type="1" start="4">
                    <li>5.	Para el bucle interno, hacer:  </li>
                    <ol type="1" start="4">
                      <li>5.1.	Inicializar el valor de las columnas de asteriscos ‘a’ en uno. </li></ol>
                      <ol type="1" start="4">
                        <li>5.2.	Mientras la condición (a &lt;= 2 * f - 1) sea verdadera, ejecutar las sentencias del bucle interno. </li></ol>
                        <ol type="1" start="4">
                          <li>5.3.	Luego de cada iteración incrementar el valor de las columnas de asteriscos ‘a’ en uno. </li></ol>
                          <ol type="1" start="4">
                            <li>5.4.	Imprimir un asterisco por columna. </li></ol>
                    </ol><ol type="1" start="4">
                    <li>6.	Imprimir un salto de línea (INTRO). </li></ol>
                 <li>Para el bucle externo, hacer: </li>
                 <ol type="1" start="5">
                  <li>1. Inicializar el valor de las filas ‘f’ con el valor de la variable ‘altura’ menos uno. </li>
                </ol><ol type="1" start="5">
                  <li>2. Mientras el valor de la condición (f &gt;= altura), sea verdadera, ejecutar las sentencias del bucle externo. </li>
                </ol><ol type="1" start="5">
                  <li>3. Luego de cada iteración decrementar en uno el valor del contador de las filas ‘f’. </li>
                </ol><ol type="1" start="5">
                  <li>4. Para el bucle interno, hacer: </li>
                  <ol type="1" start="5">
                    <li>4.1.	Inicializar el valor de las columnas de blancos ‘b’ con el valor de la variable 'altura' menos el número de filas.  </li></ol>
                    <ol type="1" start="5">
                      <li>4.2.	Mientras la condición (b &gt;= 1) sea verdadera, ejecutar las sentencias del bucle interno.  </li></ol>
                      <ol type="1" start="5">
                        <li>4.3.	Luego de cada iteración decrementar el valor de las columnas de blancos ‘b’ en uno. </li></ol>
                        <ol type="1" start="5">
                          <li>4.4.	Imprimir un espacio en blanco por columna. </li></ol>
                </ol><ol type="1" start="5">
                  <li>5.	Para el bucle interno, hacer:  </li>
                  <ol type="1" start="5">
                    <li>5.1.	Inicializar el valor de las columnas de asteriscos ‘a’ en uno. </li></ol>
                    <ol type="1" start="5">
                      <li>5.2.	Mientras la condición (a &lt;= 2 * f - 1) sea verdadera, ejecutar las sentencias del bucle interno. </li></ol>
                      <ol type="1" start="5">
                        <li>5.3.	Luego de cada iteración incrementar el valor de las columnas de asteriscos ‘a’ en uno. </li></ol>
                        <ol type="1" start="5">
                          <li>5.4.	Imprimir un asterisco por columna. </li></ol>
                  </ol><ol type="1" start="5">
                  <li>6.	Imprimir un salto de línea (INTRO). </li></ol>
		
                  </ol>

                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.24.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.24.1. </b>Programa que analiza si un número leído es palíndromo.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_24_1"  [lineNumbers]="true"></code></pre> <br>
                <h2>E) Pruebas</h2>
                <p>En la Tabla 2.24.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los obtenidos en una hoja de cuadros o de papel milimetrado.</p>
	            	<p>En la salida de la Tabla 2.24.2 se puede ver que, al ingresar el valor de la diagonal mayor igual a 9 se obiene el rombo de asteriscos compuesto por dos triángulos isósceles, el uno de altura igual a 5 y el otro de altura igual a 4.</p>
                <h5><b>Tabla 2.24.2.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.24.2.png" style="display:block; margin:auto; "><br>
                  <p>En la Tabla 2.24.3 se puede ver la primera parte de la prueba de escritorio del programa, donde se almacena en la variable ‘diagonalMayor’ el valor de 9. Luego se verifica que este valor es impar utilizando el operador de módulo (%). Como este valor es impar, se suma el valor de uno obteniéndose 10 y ese resultado se divide para 2 obteniéndose el valor de 5 en la variable altura, caso contrario, se dividiría directamente para 2.</p>
               <h5><b>Tabla 2.24.3. </b>Prueba de escritorio del programa (primera parte).</h5>
            		<table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                <tr style="color:red"><td>diagonalMayor</td><td>diagonalMayor % 2 != 0</td><td>altura = (diagonalMayor + 1)/2;</td></tr>
                <tr><td>9</td><td>9 % 2 != 0 (V)</td><td>(9 + 1)/2 = 10/2 = 5</td></tr>                
               </table> <br>
                <br>
                <p>En la Tabla 2.24.4 se puede ver la segunda parte de la prueba de escritorio del programa, donde la impresión de la mitad del rombo de asteriscos es un triángulo isósceles cuyo valor de altura es 5, se realiza mediante un bucle externo y dos bucles internos. Cada vez que se repite el bucle externo incremental, se ejecutan los dos bucles internos. El bucle externo incremental se repite cinco veces en este caso, según la altura del triángulo y se controla con el contador de las filas ‘f’. El número de repeticiones realizadas por los bucles internos se basan en el valor del contador de las filas ‘f’. El primer bucle interno controla la impresión de los espacios en blanco con el contador ‘b’ y el segundo bucle interno controla la impresión de los asteriscos con el contador ‘a’.</p>
                <h5><b>Tabla 2.24.4. </b>Prueba de escritorio del programa (segunda parte).</h5>
                <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5" style="font-size:x-small" HEIGHT="50"> 
                  <tr style="color:red"><td>altura</td><td>f</td><td>f &lt;= altura</td><td>b</td><td>b &gt;= 1</td><td>cout &lt;&lt;= " ";</td><td>a</td><td>a &lt;= 2 * f - 1</td><td>cout &lt;&lt; "*"; </td><td>cout &lt;&lt; endl;</td></tr>
                  <tr><td>5</td><td>1</td><td>1 &lt;= 5 (V)</td><td>4</td><td>4 &gt;= 1 (V)</td><td>bbbb</td><td>1</td><td>1 &lt;= 1 (V)</td><td>*</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td style="color:rgb(33, 15, 201)">2</td><td style="color:rgb(33, 15, 201)">2 &lt;= 1 (F)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td><td></td><td></td><td>INTRO</td></tr>
                
                  <tr><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td>3</td><td>3 &gt;= 1 (V)</td><td>bbb</td><td>1</td><td>1 &lt;= 3 (V)</td><td>***</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td>2</td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>3</td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td style="color:rgb(33, 15, 201)">4</td><td style="color:rgb(33, 15, 201)"> 4 &lt;= 3 (F)</td><td></td><td>INTRO</td></tr>
                
                  <tr><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td>2</td><td> 2 &gt;= 1 (V)</td><td>bb</td><td>1</td><td>1 &lt;= 5 (V)</td><td>*****</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td>INTRO</td></tr>
                  
                  <tr><td></td><td>4</td><td>4 &lt;= 4 (V)</td><td>1</td><td>1 &gt;= 1 (V)</td><td>b</td><td>1</td><td>1 &lt;= 7 (V)</td><td>*******</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>2</td><td>2&lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>6</td><td>6 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>7</td><td>7 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">8</td><td style="color:rgb(33, 15, 201)">8 &lt;= 7 (F)</td><td></td><td>INTRO</td></tr>
                  
                  <tr><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>1</td><td>1 &lt;= 9 (V)</td><td>*********</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>2</td><td>2 &lt;= 9 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 9 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 9 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 9 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>6</td><td>6 &lt;= 9 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>7</td><td>7 &lt;= 9 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>8</td><td>8 &lt;= 9 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>9</td><td>9 &lt;= 9 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">10</td><td style="color:rgb(33, 15, 201)">10 &lt;= 9 (F)</td><td></td><td>INTRO</td></tr>
                  
                  <tr><td></td><td style="color:rgb(33, 15, 201)">6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
                </table><br>
               <p>En la Tabla 2.24.5 se puede ver la tercera parte de la prueba de escritorio del programa, donde la impresión de la mitad del rombo de asteriscos es un triángulo isósceles invertido cuyo valor de altura es 4, se realiza mediante un bucle externo y dos bucles internos. Cada vez que se repite el bucle externo decremental, se ejecutan los dos bucles internos. El bucle externo decremental se repite cuatro veces en este caso, según la altura del triángulo y se controla con el contador de las filas ‘f’. El número de repeticiones realizadas por los bucles internos se basan en el valor del contador de las filas ‘f’. El primer bucle interno controla la impresión de los espacios en blanco con el contador ‘b’ y el segundo bucle interno controla la impresión de los asteriscos con el contador ‘a’.</p>
                <h5><b>Tabla 2.24.5. </b>Prueba de escritorio del programa (tercera parte).</h5>
              
                <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5" style="font-size:x-small" HEIGHT="50"> 
                  <tr style="color:red"><td>altura</td><td>f</td><td>f &gt;= 1</td><td>b</td><td>b &gt;= 1</td><td>cout &lt;&lt;= " ";</td><td>a</td><td>a &lt;= 2 * f - 1</td><td>cout &lt;&lt; "*"; </td><td>cout &lt;&lt; endl;</td></tr>
                  
                  <tr><td>5</td><td>4</td><td>4 &gt;= 1 (V)</td><td>1</td><td>1 &gt;= 1 (V)</td><td>b</td><td>1</td><td>1 &lt;= 7 (V)</td><td>*******</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>2</td><td>2&lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>6</td><td>6 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>7</td><td>7 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">8</td><td style="color:rgb(33, 15, 201)">8 &lt;= 7 (F)</td><td></td><td>INTRO</td></tr>
                                
                  <tr><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td>2</td><td> 2 &gt;= 1 (V)</td><td>bb</td><td>1</td><td>1 &lt;= 5 (V)</td><td>*****</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td>INTRO</td></tr>
                  
                  <tr><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td>3</td><td>3 &gt;= 1 (V)</td><td>bbb</td><td>1</td><td>1 &lt;= 3 (V)</td><td>***</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td>2</td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>3</td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td style="color:rgb(33, 15, 201)">4</td><td style="color:rgb(33, 15, 201)"> 4 &lt;= 3 (F)</td><td></td><td>INTRO</td></tr>
                
                  <tr><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td>4</td><td>4 &gt;= 1 (V)</td><td>bbbb</td><td>1</td><td>1 &lt;= 1 (V)</td><td>*</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td style="color:rgb(33, 15, 201)">2</td><td style="color:rgb(33, 15, 201)">2 &lt;= 1 (F)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td><td></td><td></td><td>INTRO</td></tr>

                  <tr><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
                </table><br>
                <h1><b>Caso de Estudio 2.25: Visualización de un Rombo con Espacios en Blanco.</b></h1>
                <h2><b>A) Problema</b></h2>
                <p>Escribir un programa que permita visualizar un rombo de asteriscos. Así, por ejemplo, si el valor de la Diagonal mayor es igual a 9 o a 10, se obtendrá la siguiente figura:</p>
                <table border="1" align="center" cellspacing="0" cellpadding="5">
                  <tr><td width="200"><p>************</p><p>*****bb*****</p><p>****bbbb****</p><p>***bbbbbb***</p><p>**bbbbbbbb**</p><p>*bbbbbbbbbbb*</p>
                    <p>**bbbbbbbb**</p><p>***bbbbbb***</p><p>****bbbb****</p><p>*****bb*****</p><p>***********</p>	</td></tr>
                </table><br>
                
                <table border="1" CELLPADDING=5 CELLSPACING=0>
                  <tr VALIGN=top><td width="50"><b> Nota:</b></td><td>Como se puede ver en la figura anterior, la primera y la última fila de la figura es un caso especial. Mientras se reduce el número de ateriscos, aumenta el número de espacios en blanco, tanto de arriba hacia abajo, como de abajo hacia arriba. Con fines didácticos, la letra ‘b’ en color plomo equivale a un espacio en blanco (“ ”).</td></tr>
                </table><br>
                
                
                <h2><b>B) Análisis</b></h2>
                <p>Claramente se puede ver que la única entrada del problema es el valor de la diagonal mayor del rombo. Se requieren dos salidas que son los espacios en blanco y los asteriscos de la figura geométrica controlados por los contadores ‘b’ y ‘a’ respectivamente. Se requiere una variable auxiliar llamada ‘aux’ que tiene el valor de la mitad de la diaginal del rombo. El proceso de cálculo y visualización del rombo con asteriscos requiere la utilización de bucles anidados.</p>

    <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Entradas del Problema</b></p>		
                <table>
                              <tr><td width="200"> diagonalMayor </td><td width="200">/* Tamaño de la diagonal mayor del rombo  */</td></tr>
                            </table><br>
                            <p><b>Salidas del Problema</b></p>
                            <table>
                              <tr><td width="200"> Mensaje1 </td><td width="200">/* Mensaje que imprime un espacio en blanco */</td></tr>
                              <tr><td width="200"> Mensaje2 </td><td width="200">/* Mensaje que imprime un asterisco */</td></tr>
                              <tr><td width="200"> Mensaje3 </td><td width="200">/* Mensaje que imprime un INTRO */</td></tr>
                            </table><br>
                <p><b>Auxiliares del Problema</b></p>
                          <table>
                <tr><td width="200">altura</td><td width="200">/* Altura que representa la mitad de la diagonal mayor del rombo */</td></tr>
                <tr><td width="200">f</td><td width="200">/* Número de filas */</td></tr>
                <tr><td width="200">b</td><td width="200">/* Contador para controlar el número de espacios en blanco */</td></tr>
                <tr><td width="200">a</td><td width="200">* Contador para controlar el número de asteriscos */</td></tr>
                         </table><br>
                            <p><b>Fórmulas Relevantes</b></p>
                            <table>
                              <tr><td><em>num = num % 2</em></td><td>(1)</td><td>/* Fórmula que calcula si un número es par */</td></tr>
                              <tr><td ><em>num = (num = 1)/2</em></td><td> (2) </td><td>/* Fórmula que obtiene la mitad de un valor impar y lo convierte a un valor par */</td></tr>
                            <tr><td width="120"><em>num = num/2</em></td><td width="30"> (3) </td><td width="280">/* Fórmula que obtiene la mitad de un valor par */</td></tr>
                              <tr><td ><em>a = h * 2 + 2</em></td><td> (4) </td><td>/* Fórmula que obtiene el número total de asteriscos en la primera y última fila de acuerdo a la altura del triánguo isósceles */</td></tr>
                            <tr><td><em>a = (h + 1) - f</em></td><td>(5)</td><td>/* Fórmula que obtiene un número determinado de  asteriscos de acuerdo al valor de la fila y de la altura del triánguo isósceles */</td></tr>
                          <tr><td><em>b = 2 * f</em></td><td>(6)</td><td>/* Fórmula que obtiene un número par de  espacios en blanco de acuerdo al valor de la fila */</td></tr>  
                          </table> <br>
                  <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                  <p>En la Figura 2.25.1 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘diagonalMayor’; b) Salidas: Mensaje1 que imprime un asterisco; Mensaje2 que imprime un espacio en blanco; Mensaje3 que imprime un INTRO; c) Auxiliares: la variable ‘altura’; la variable ‘f’; la variable ‘b’; la variable ‘a’.</p>
                  <img src="./assets/images/Capitulos/II/media/Figura 2.25.1.png" style="display:block; margin:auto; "><br>
                  <h5 style="text-align:center"><b>Figura 2.25.1. </b>Diagrama de Entrada-Salida del Programa.</h5>
                  <h2><b>C) Diseño</b></h2>
                  <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                  
        <p><b>Algoritmo</b></p>
                  <ol type="1">
                 <li>Leer el valor de la diagonal mayor del rombo.</li>   
                   <li>Si el valor de la diagonal mayor es impar, entonces</li> 
                   <ol type="1" start="2"><li>1.	Asignar a la variable ‘altura’ el valor de la diagonal mayor más uno dividido para dos.</li></ol>          
      <li>Caso contrario,</li>
      <ol type="1" start="3"><li>1.	Asignar a la variable ‘altura’ el valor de la mitad de la diagonal mayor.</li></ol>
      <li>4.	Para el bucle, hacer:</li>            
      <ol type="1" start="4">
                      <li>1.	Inicializar el valor de las columnas de asteriscos 'a' en uno.</li>
                    </ol><ol type="1" start="4">
                      <li>2.	Mientras la condición (a &lt;= altura * 2 + 2) sea verdadera, ejecutar las sentencias del bucle externo.</li>
                    </ol><ol type="1" start="4">
                      <li>3.	Luego de cada ciclo incrementar el valor de las columnas de asteriscos 'a' en uno.</li>
                    </ol><ol type="1" start="4">
                      <li>4.	Imprimir un asterisco por columna.</li>
                      </ol>
      <li>Imprimir un salto de línea o INTRO.</li>
      <li>Para el bucle externo, hacer: </li>
                    <ol type="1" start="6">
                      <li>1.	Inicializar el valor del contador de las filas ‘f’ en uno. </li>
                    </ol><ol type="1" start="6">
                      <li>2.	Mientras el valor de la condición (f &lt;= altura), sea verdadera, ejecutar las sentencias del bucle externo. </li>
                    </ol><ol type="1" start="6">
                      <li>3.	Luego de cada iteración incrementar en uno el valor del contador de las filas ‘f’. </li>
                    </ol><ol type="1" start="6">
                      <li>4.	Para el bucle interno, hacer: </li>
                            <ol type="1" start="6"><li>4.1.	Inicializar el valor de las columnas de asteriscos ‘a’ con el valor de (altura + 1) - f. </li></ol>
                            <ol type="1" start="6"><li>4.2.	Mientras la condición (a &gt;= 1) sea verdadera, ejecutar las sentencias del bucle interno. </li></ol>
                            <ol type="1" start="6"><li>4.3.	Luego de cada iteración decrementar el valor de las columnas de asteriscos ‘a’ en uno.</li></ol>
                            <ol type="1" start="6"><li>4.4.	Imprimir un asterisco por columna.</li></ol>
            </ol><ol type="1" start="6">
         <li>5. Para el bucle interno, hacer</li>
         <ol type="1" start="6"><li>5.1.	Inicializar el valor de las columnas de blancos ‘b’ con el valor de uno. </li></ol>
         <ol type="1" start="6"><li>5.2.	Mientras la condición (b &lt;= 2 * f) sea verdadera, ejecutar las sentencias del bucle interno. </li></ol>
         <ol type="1" start="6"><li>5.3.	Luego de cada iteración incrementar el valor de las columnas de blancos ‘b’ en uno.</li></ol>
         <ol type="1" start="6"><li>6.5.4.	Imprimir un espacio en blanco por columna.</li></ol>
                    </ol><ol type="1" start="6">
         <li>6.	Para el bucle interno, hacer: .</li>
         <ol type="1" start="6"><li>6.1.	Inicializar el valor de las columnas de asteriscos ‘a’ con el valor de (altura + 1) - f. </li></ol>
         <ol type="1" start="6"><li>6.2.	Mientras la condición (a &gt;= 1) sea verdadera, ejecutar las sentencias del bucle interno. </li></ol>
         <ol type="1" start="6"><li>6.3.	Luego de cada iteración decrementar el valor de las columnas de asteriscos ‘a’ en uno.</li></ol>
         <ol type="1" start="6"><li>6.4.	Imprimir un asterisco por columna.</li></ol>
                    </ol>
      <li>Para el bucle externo, hacer: </li>
      <ol type="1" start="7"><li>1.	Inicializar el valor de las filas ‘f’ con el valor de la variable ‘altura’ menos uno</li></ol>
      <ol type="1" start="7"><li>2.	Mientras la condición (f &gt;= 1) sea verdadera, ejecutar las sentencias del bucle externo. </li></ol>
      <ol type="1" start="7"><li>3.	Luego de cada iteración decrementar en uno el valor del contador de las filas ‘f’. </li></ol>
      <ol type="1" start="7"><li>4.	Para el bucle interno, hacer: </li>
        <ol type="1" start="7"><li>4.1.	Inicializar el valor de las columnas de asteriscos ‘a’ con el valor de (altura + 1) - f. </li></ol>
        <ol type="1" start="7"><li>4.2.	Mientras la condición (a &gt;= 1) sea verdadera, ejecutar las sentencias del bucle interno. </li></ol>
        <ol type="1" start="7"><li>4.3.	Luego de cada iteración decrementar el valor de las columnas de asteriscos ‘a’ en uno.</li></ol>
        <ol type="1" start="7"><li>4.4.	Imprimir un asterisco por columna.</li></ol>
      </ol>
      <ol type="1" start="7"><li>5.	Para el bucle interno, hacer: </li>
        <ol type="1" start="7"><li>5.1.	Inicializar el valor de las columnas de blancos ‘b’ con el valor de uno. </li></ol>
        <ol type="1" start="7"><li>5.2.	Mientras la condición (b &lt;= 2 * f) sea verdadera, ejecutar las sentencias del bucle interno. </li></ol>
        <ol type="1" start="7"><li>5.3.	Luego de cada iteración incrementar el valor de las columnas de blancos ‘b’ en uno.</li></ol>
        <ol type="1" start="7"><li>5.4.	Imprimir un espacio en blanco por columna.</li></ol>
      </ol>
      <ol type="1" start="7"><li>6.	Para el bucle interno, hacer: </li>
        <ol type="1" start="7"><li>6.1.	Inicializar el valor de las columnas de asteriscos ‘a’ con el valor de (altura + 1) - f. </li></ol>
        <ol type="1" start="7"><li></li>7.6.2.	Mientras la condición (a &gt;= 1) sea verdadera, ejecutar las sentencias del bucle interno. </ol>
        <ol type="1" start="7"><li>6.3.	Luego de cada iteración decrementar el valor de las columnas de asteriscos ‘a’ en uno.</li></ol>
        <ol type="1" start="7"><li>6.4.	Imprimir un asterisco por columna.</li></ol>
      </ol>
      <ol type="1" start="7"><li>7. Imprimir un salto de línea (INTRO).</li></ol>
      <li>Para el bucle, hacer:</li>
      <ol type="1" start="8"><li>1.	Inicializar el valor de las columnas de asteriscos 'a' en uno.</li></ol>
      <ol type="1" start="8"><li>2.	Mientras la condición (a &lt;= altura * 2 + 2) sea verdadera, ejecutar las sentencias del bucle externo.</li></ol>
      <ol type="1" start="8"><li>3.	Luego de cada ciclo incrementar el valor de las columnas de asteriscos 'a' en uno.</li></ol>
      <ol type="1" start="8"><li>4.	Imprimir un asterisco por columna.</li></ol>
      <li>Imprimir un salto de línea o INTRO.</li>
                  </ol>
  
                  <h2><b>D) Implementación</b></h2>
                  <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.25.1 se muestra el código del programa en C/C++.</p>
                  <h5><b>Tabla 2.25.1. </b>Programa que analiza si un número leído es palíndromo.</h5>
                  <pre><code [highlight]="prefTab2[0].tabla2_25_1"  [lineNumbers]="true"></code></pre> <br>
                  <h2>E) Pruebas</h2>
                  <p>En la Tabla 2.25.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los obtenidos en una hoja de cuadros o de papel milimetrado.</p>
                  <p>En la salida de la Tabla 2.25.2 se puede ver que, al ingresar el valor de la diagonal mayor igual a 9 se obiene el rombo de espacios en blanco compuesto por dos triángulos isósceles, el uno de altura igual a 5 y el otro de altura igual a 4.</p>
                  <h5><b>Tabla 2.25.2.</b> Salida del programa</h5>
                  <img src="./assets/images/Capitulos/II/media/Tabla 2.25.2.png" style="display:block; margin:auto; "><br>
                  <p>En la Tabla 2.25.3 se puede ver la primera parte de la prueba de escritorio del programa, donde se almacena en la variable ‘diagonalMayor’ el valor de 9. Luego se verifica que este valor es impar utilizando el operador de módulo (%). Como este valor es impar, se suma el valor de uno obteniéndose 10 y ese resultado se divide para 2 obteniéndose el valor de 5 en la variable altura, caso contrario, se dividiría directamente para 2.</p>
                 
                 <h5><b>Tabla 2.25.3. </b>Prueba de escritorio del programa (primera parte).</h5>
                 <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                 <tr style="color:red"><td>diagonalMayor</td><td>diagonalMayor % 2 != 0</td><td>altura = (diagonalMayor + 1)/2;</td></tr>
                 <tr><td>9</td><td>9 % 2 != 0 (V)</td><td>(9 + 1)/2 = 10/2 = 5</td></tr>                
                </table> <br>
                 <br>
                 <p>En la Tabla 2.25.4 se puede ver la segunda parte de la prueba de escritorio del programa, donde se imprime la primera fila de asteriscos mediante un bucle for() y al terminar la ejecución de este bucle se imprime un salto de línea (INTRO).</p>
                 <h5><b>Tabla 2.25.4. </b>Prueba de escritorio del programa (segunda parte).</h5>
                 <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                  <tr style="color:red"><td>altura</td><td>a</td><td>a &lt;= altura * 2 + 2</td><td>cout &lt;&lt; "*"; </td><td>cout &lt;&lt; endl;</td></tr>
                  <tr><td>5</td><td>1</td><td>1 &lt;= 12 (V)</td><td>************</td><td></td></tr>
                  <tr><td></td><td>2</td><td>2 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>3</td><td>3 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>4</td><td>4 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>5</td><td>5 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>6</td><td>6 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>7</td><td>7 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>8</td><td>8 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>9</td><td>9 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>10</td><td>10 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>11</td><td>11 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>12</td><td>12 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td style="color:rgb(33, 15, 201)">13</td><td style="color:rgb(33, 15, 201)">13 &lt;= 12 (V)</td><td></td><td>INTRO</td></tr>
                   </table>
                <br>
                 
                <p>En la Tabla 2.25.5 se puede ver la tercera parte de la prueba de escritorio del programa, donde la impresión de la mitad del rombo de espacios en blanco, es un triángulo isósceles cuyo valor de altura es 5, se realiza mediante un bucle externo y tres bucles internos. Cada vez que se repite el bucle externo incremental, se ejecutan los tres bucles internos. El bucle externo incremental se repite cinco veces en este caso, según la altura del triángulo y se controla con el contador de las filas ‘f’. El número de repeticiones realizadas por los bucles internos se basan en el valor del contador de las filas ‘f’ y de la altura del triángulo isósceles. El primer bucle interno controla la impresión del primer grupo de asteriscos con el contador ‘a’. El segundo bucle interno controla la impresión de los espacios en blanco con el contador ‘b’. El tercer bucle interno controla la impresión del segundo grupo de asteriscos con el contador ‘a’. </p>
                <h5><b>Tabla 2.25.5. </b>Prueba de escritorio del programa (tercera parte).</h5>
                 <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5" style="font-size:x-small" HEIGHT="50"> 
                   <tr style="color:red"><td>altura</td><td>f</td><td>f &lt;= altura</td><td>a</td><td>a &gt;= 1</td><td>cout &lt;&lt;= "*";</td><td>b</td><td>b &lt;= 2 * f</td><td>cout &lt;&lt; " "; </td><td>a</td><td>a &gt;= 1</td><td>cout &lt;&lt; "*";</td><td>cout &lt;&lt; endl;</td></tr>
                   <tr><td>5</td><td>1</td><td>1 &lt;= 5 (V)</td><td>5</td><td>5 &gt;= 1 (V)</td><td>*****</td><td>1</td><td>1 &lt; 2 (V)</td><td>bb</td><td>5</td><td>5 &gt;= 1 (V)</td><td>*****</td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>4</td><td>4 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 2 (V)</td><td></td><td>4</td><td>4 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td style="color:rgb(33, 15, 201)">3</td><td style="color:rgb(33, 15, 201)">3 &lt;= 2 (F)</td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>INTRO</td></tr>
                 
                   <tr><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td>4</td><td>4 &gt;= 1 (V)</td><td>****</td><td>1</td><td>1 &lt; 4 (V)</td><td>bbbb</td><td>4</td><td>4 &gt;= 1 (V)</td><td>****</td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 4 (V)</td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td>3</td><td>3 &lt;= 4 (V)</td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>4</td><td>4 &lt;= 4 (V)</td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td style="color:rgb(33, 15, 201)">5</td><td style="color:rgb(33, 15, 201)">5 &lt;= 4 (F)</td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>INTRO</td></tr>
                 
                   <tr><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td>3</td><td>3 &gt;= 1 (V)</td><td>***</td><td>1</td><td>1 &lt; 6 (V)</td><td>bbbbbbbb</td><td>3</td><td>3 &gt;= 1 (V)</td><td>***</td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>2</td><td>4 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 6 (V)</td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>1</td><td>3 &gt;= 1 (V)</td><td></td><td>3</td><td>3 &lt;= 6 (V)</td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>4</td><td>4 &lt;= 6 (V)</td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 6 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">7</td><td style="color:rgb(33, 15, 201)">7 &lt;=6 (F)</td><td></td><td></td><td></td><td></td><td>INTRO</td></tr>
                 
                   <tr><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td>2</td><td>2 &gt;= 1 (V)</td><td>**</td><td>1</td><td>1 &lt; 8 (V)</td><td>bbbbbbbbbb</td><td>2</td><td>2 &gt;= 1 (V)</td><td>**</td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 8 (V)</td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>3</td><td>3 &lt;= 8 (V)</td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>6</td><td>6 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>7</td><td>7 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>8</td><td>8 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">9</td><td style="color:rgb(33, 15, 201)">9 &lt;=8 (F)</td><td></td><td></td><td></td><td></td><td>INTRO</td></tr>
                 
                   <tr><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td>1</td><td>1 &gt;= 1 (V)</td><td>*</td><td>1</td><td>1 &lt; 10 (V)</td><td>bbbbbbbbbbbb</td><td>1</td><td>1 &gt;= 1 (V)</td><td>*</td><td></td></tr>
                   <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>2</td><td>2 &lt;= 10 (V)</td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 10 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 10 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 10 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>6</td><td>6 &lt;= 10 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>7</td><td>7 &lt;= 10 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>8</td><td>8 &lt;= 10 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>9</td><td>9 &lt;= 10 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>10</td><td>10 &lt;= 10 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">11</td><td style="color:rgb(33, 15, 201)">11 &lt;=8 (F)</td><td></td><td></td><td></td><td></td><td>INTRO</td></tr>
                 
                   <tr><td></td><td style="color:rgb(33, 15, 201)">6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
                 </table><br>
                 <p>En la Tabla 2.25.6 se puede ver la cuarta parte de la prueba de escritorio del programa, donde la impresión de la otra mitad del rombo de espacios en blanco es un triángulo isósceles invertido cuyo valor de altura es 4, se realiza mediante un bucle externo y tres bucles internos. Cada vez que se repite el bucle externo decremental, se ejecutan los tres bucles internos. El bucle externo decremental se repite cuatro veces en este caso, según la altura del triángulo y se controla con el contador de las filas ‘f’. El número de repeticiones realizadas por los bucles internos se basan en el valor del contador de las filas ‘f’ y de la altura del triángulo isósceles. El primer bucle interno controla la impresión del primer grupo de asteriscos con el contador ‘a’. El segundo bucle interno controla la impresión de los espacios en blanco con el contador ‘b’. El tercer bucle interno controla la impresión del segundo grupo de asteriscos con el contador ‘a’.</p>

                 <h5><b>Tabla 2.25.6. </b>Prueba de escritorio del programa (cuarta parte).</h5>
                 <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5" style="font-size:x-small" HEIGHT="50"> 
                  <tr style="color:red"><td>altura</td><td>f</td><td>f &gt;= 1</td><td>a</td><td>a &gt;= 1</td><td>cout &lt;&lt;= "*";</td><td>b</td><td>b &lt;= 2 * f</td><td>cout &lt;&lt; " "; </td><td>a</td><td>a &gt;= 1</td><td>cout &lt;&lt; "*";</td><td>cout &lt;&lt; endl;</td></tr>
                  <tr><td>5</td><td>4</td><td>4 &gt;= 1 (V)</td><td>2</td><td>2 &gt;= 1 (V)</td><td>**</td><td>1</td><td>1 &lt; 8 (V)</td><td>bbbbbbbbbb</td><td>2</td><td>2 &gt;= 1 (V)</td><td>**</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 8 (V)</td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>3</td><td>3 &lt;= 8 (V)</td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>6</td><td>6 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>7</td><td>7 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>8</td><td>8 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">9</td><td style="color:rgb(33, 15, 201)">9 &lt;=8 (F)</td><td></td><td></td><td></td><td></td><td>INTRO</td></tr>
                
                  <tr><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td>3</td><td>3 &gt;= 1 (V)</td><td>***</td><td>1</td><td>1 &lt; 6 (V)</td><td>bbbbbbbb</td><td>3</td><td>3 &gt;= 1 (V)</td><td>***</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>2</td><td>4 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 6 (V)</td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>3 &gt;= 1 (V)</td><td></td><td>3</td><td>3 &lt;= 6 (V)</td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>4</td><td>4 &lt;= 6 (V)</td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 6 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">7</td><td style="color:rgb(33, 15, 201)">7 &lt;=6 (F)</td><td></td><td></td><td></td><td></td><td>INTRO</td></tr>
                
                  <tr><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td>4</td><td>4 &gt;= 1 (V)</td><td>****</td><td>1</td><td>1 &lt; 4 (V)</td><td>bbbb</td><td>4</td><td>4 &gt;= 1 (V)</td><td>****</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 4 (V)</td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td>3</td><td>3 &lt;= 4 (V)</td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>4</td><td>4 &lt;= 4 (V)</td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td style="color:rgb(33, 15, 201)">5</td><td style="color:rgb(33, 15, 201)">5 &lt;= 4 (F)</td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>INTRO</td></tr>
                
                  <tr><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td>5</td><td>5 &gt;= 1 (V)</td><td>*****</td><td>1</td><td>1 &lt; 2 (V)</td><td>bb</td><td>5</td><td>5 &gt;= 1 (V)</td><td>*****</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>4</td><td>4 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 2 (V)</td><td></td><td>4</td><td>4 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td style="color:rgb(33, 15, 201)">3</td><td style="color:rgb(33, 15, 201)">3 &lt;= 2 (F)</td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>INTRO</td></tr>
                   <tr><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
                </table><br>
              
                <h1><b>Caso de Estudio 2.26: Serie de la Función Exponencial <em>y = e <sup>x</sup></em>.</b></h1>
                <h2><b>A) Problema</b></h2>
                <p>El valor de la función y=e^x se puede aproximar mediante la siguiente serie de Taylor:</p>
                <table align="right">
                  <td width="350">e<sup>x</sup>= 1 + <sup>x</sup>/<sub>1!</sub> + <sup>x<sup>2</sup></sup>/<sub>2!</sub> + <sup>x<sup>3</sup></sup>/<sub>3!</sub> + ... + <sup>x<sup>n</sup></sup>/<sub>n!</sub></td>
                <td align="right">(1)</td>
                </table><br><br>
                <p>La fórmula de la sumatoria de la función es:</p>
                <table align="right">
                  <td width="350">e<sup>x</sup>= &Sigma;<sup><font size="2">&infin;</font></sup><sub><font size="2">n=0</font></sub>  <sup>x<sup>n</sup></sup>/<sub>n!</sub></td>
                <td align="right">(2)</td>
                </table><br><br>
                <p>Escribir un programa que permita aproximar el valor de la función exponencial y=e^x utilizando la serie de Taylor y bucles anidados.</p>
                <h2><b>B) Análisis</b></h2>
                <p>Claramente se puede ver que las entradas del problema son el número de términos de la serie y el valor del exponente de la función exponencial. Se requiere una sola salida que es el valor de la serie aproximada. El proceso de cálculo requiere que la serie numérica infinita de la ecuación (2), se convierta a una serie numérica finita, donde el valor de ‘n’ se convierte en el valor de ‘i’ y el valor de infinito pasa a ser el valor de n-1, ya que si se quiere calcular la sumatoria de los cinco primeros términos de la serie, la sumatoria iría desde el valor de i = 0 hasta el valor de i = 5 - 1, es decir, i = 4, como se puede ver en la ecuación (3):</p>
                <table align="right">
                  <td width="350">e<sup>x</sup>= &Sigma;<sup><font size="2">n-1</font></sup><sub><font size="2">i=0</font></sub>  <sup>x<sup>i</sup></sup>/<sub>i!</sub></td>
                <td align="right">(3)</td>
                </table><br><br>
                 <p>Para calcular el valor del factorial de la función seno se requiere utilizar la sucesión del factorial de un número cuya ecuación es:</p>
                 <table align="right">
                  <td width="350">n! = &prod;<sup><font size="2">&infin;</font></sup><sub><font size="2">n=1</font></sub>  n </td>
                <td align="right">(4)</td>
                </table><br><br>
                <p>Por lo que, el factorial de (i) es:</p>
                <table align="right">
                  <td width="350">i! = &prod;<sup><font size="2">i</font></sup><sub><font size="2">j=1</font></sub>  j</td>
                <td align="right">(5)</td>
                </table><br><br>
                <p>Reemplazando el valor de la ecuación (5) en la ecuación (3) se tiene:</p>
                <table align="right">
                  <td width="350">e<sup>x</sup>= &Sigma;<sup><font size="2">n-1</font></sup><sub><font size="2">i=0</font></sub>  <sup>x<sup>i</sup></sup>/<sub> [ &prod;<sup><font size="1">i</font></sup><sub><font size="1">j=1</font></sub>  j ]</sub></td>
                <td align="right">(6)</td>
                </table><br><br>  <br>              
              <p>Como se puede ver en la ecuación (6) se requiere utilizar dos bucles anidados; un bucle externo para calcular la sumatoria y un bucle interno para calcular el factorial de un número que básicamente es un producto.</p>
                  
    <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Entradas del Programa</b></p>
                    
      <table>
                    <tr><td width="200"> n </td><td width="200">/* número de términos de la serie */</td></tr>
                    <tr><td>x</td><td>/* Exponente de la función exponencial */</td></tr>
                  </table><br>
                  <p><b>Salidas del Problema</b></p>
                  <table>
                    <tr><td width="200"> serie </td><td width="200">/* Resultado de la serie aproximada  */</td></tr>
                  </table><br>
      <p><b>Auxiliares del Problema</b></p>
                <table>
                 <tr><td width="200">i</td><td width="200">/* Contador para controlar la sumatoria */</td></tr>
                <tr><td width="200">j</td><td width="200">/* Contador para controlar el factorial de un número */</td></tr>
                <tr><td width="200">sum</td><td width="200">/* Acumulador de sumas */</td></tr>
                <tr><td width="200">prod</td><td width="200">/* Acumulador de productos */</td></tr>
               </table><br>
                  <p><b>Fórmulas Relevantes</b></p>
                  <table>
                <tr><td ><i>prod = prod ∙ valor </i></td><td> (1) </td><td>/* Fórmula que representa el acumulador de un producto */</td></tr>
                  <tr><td width="120"><i>sum = sum + valor</i></td><td width="30"> (2) </td><td width="280">/* Fórmula que representa el acumulador de una sumatoria */</td></tr>
                    <tr><td >n! = &prod;<sup><font size="2">&infin;</font></sup><sub><font size="2">n=1</font></sub>  n</td><td> (3) </td><td>/* Fórmula que representa el factorial de un número */</td></tr>
                    <tr><td >e<sup>x</sup>= &Sigma;<sup><font size="2">n-1</font></sup><sub><font size="2">i=0</font></sub>  <sup>x<sup>i</sup></sup>/<sub> [ &prod;<sup><font size="1">i</font></sup><sub><font size="1">j=1</font></sub>  j ]</sub></td><td> (4) </td><td>/* Fórmula que representa la serie de la función exponencial incluido el factorial de un número */</td></tr>
                  </table> <br>
  
                  <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                  <p>En la Figura 2.26.1 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘n’; la variable ‘x’; b) Salidas: la variable ‘serie’; c) Auxiliares: el contador ‘i’; el contador ‘j’; la variable ‘prod’; la variable ‘sum’.</p>
                  <img src="./assets/images/Capitulos/II/media/Figura 2.26.1.png" style="display:block; margin:auto; "><br>
                  <h5 style="text-align:center"><b>Figura 2.20.3. </b>Diagrama de Entrada-Salida del Programa.</h5>
                  <h2><b>C) Diseño</b></h2>
                  <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                  
        <p><b>Algoritmo</b></p>
                  
                  <ol type="1">
                    <li>Imprimir el mensaje de información: Serie de la Función Exponencial y=e <sup>x</sup>.</li>
                    <li>Leer el número de términos de la serie, utilizando la variable ‘n’.</li>
                    <li>Leer el valor del exponente de la función exponencial, utilizando la variable ‘x’.</li>
                    <li>Inicializar con el valor de cero el acumulador de sumas cuya variable utilizada es ‘sum’.</li>
                    <li>Para el bucle externo, hacer: </li>
                    <ol type="1" start="5"><li>1.	Inicializar el valor del contador ‘i’ en cero. </li></ol>
                    <ol type="1" start="5"><li>2.	Mientras el valor de la condición (i &lt;=n-1) sea verdadera ejecutar las sentencias del bucle externo. </li></ol>
                    <ol type="1" start="5"><li>3.	Luego de cada iteración incrementar en uno el valor del contador ‘i’. </li></ol>
                    <ol type="1" start="5"><li>4.	Inicializar el acumulador de productos ‘prod’ con el valor de uno.</li></ol>
                    <ol type="1" start="5"><li>5.	Para el bucle interno, hacer: </li>
                      <ol type="1" start="5"><li>5.1.	Inicializar el valor del contador ‘j’ en uno.</li></ol>
                      <ol type="1" start="5"><li>5.2.	Mientras el valor de la condición (j&lt;=i) sea verdadera ejecutar las sentencias del bucle interno.</li></ol>
                      <ol type="1" start="5"><li>5.3.	Luego de cada iteración incrementar en uno el valor del contador ‘j’.</li></ol>
                      <ol type="1" start="5"><li>5.4.	Asignar al acumulador ‘prod’ lo que tiene multiplicado por el valor del contador ‘j’.</li></ol>
                    </ol>
                    <ol type="1" start="5"><li>6.	Asignar al acumulador ‘sum’ lo que tiene sumado el valor del término e-nésimo de la serie.</li></ol>

                    <li>Asignar a la variable serie el valor del acumulador ‘sum’.</li>
                    <li>Imprimir el valor de la serie aproximada.</li>
                  </ol>
  
                  <h2><b>D) Implementación</b></h2>
                  <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.26.1 se muestra el código del programa en C/C++.</p>
                  <h5><b>Tabla 2.26.1. </b>Programa que calcula la serie de la función exponencial y=e <sup>x</sup>..</h5>
                  <pre><code [highlight]="prefTab2[0].tabla2_26_1"  [lineNumbers]="true"></code></pre> <br>
                  <h2>E) Pruebas</h2>
                  <p>En la Tabla 2.26.2 y en la Tabla 2.26.3, se muestran dos ejemplos de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora científica.</p>
                  <p>En la salida de la Tabla 2.26.2 se puede ver que, al ingresar el número de términos igual a 10 y el valor del exponente igual a 1, se obtiene el valor de la serie aproximada igual a 2.71828.</p>
                  <h5><b>Tabla 2.26.2.</b> Salida del programa.</h5>
                  <img src="./assets/images/Capitulos/II/media/Tabla 2.26.2.png" style="display:block; margin:auto; "><br>
                  <p>En la salida de la Tabla 2.26.3 se puede ver que, al ingresar el número de términos igual a 10 y el valor del exponente igual a 2, se obtiene el valor de la serie aproximada igual a 7.38871.</p>
                 <h5><b>Tabla 2.26.3. </b>Salida del programa.</h5>
                 <img src="./assets/images/Capitulos/II/media/Tabla 2.26.3.png" style="display:block; margin:auto; "><br>
                  <p>En la Tabla 2.26.4, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada iteración del bucle externo for() se inicializa el acumulador del producto en 1 y luego se calcula el factorial de (i) utilizando un bucle interno for(). Luego de ejecutarse el bucle interno for() se utiliza un acumulador de sumas donde se acumulan los valores parciales de la serie de la función y la ejecución del bucle externo termina cuando la condición (i <= n - 1) de esta sentencia se hace falsa.</p>
                  <h5><b>Tabla 2.26.4. </b>Prueba de escritorio del programa.</h5>
                  <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                  <tr style="color:red"><td>n</td><td>x</td><td>Sum</td><td>i</td><td>i &lt;= n - 1</td><td>prod</td><td>j</td><td>i &lt;= i</td></tr>
                    <tr><td>6</td><td>1</td><td>0</td><td>0</td><td>0 &lt;= 5 (V)</td><td>1</td><td style="color:rgb(33, 15, 201)">1</td><td style="color:rgb(33, 15, 201)">1 &lt;= 0 (F)</td></tr>
                    <tr><td></td><td></td><td>0 + (1<sup>0</sup> /1)=1</td><td></td><td></td><td></td><td></td><td></td></tr>
                    <tr><td></td><td></td><td></td><td>1</td><td>1 &lt;= 5 (V)</td><td>1</td><td>1</td><td>1 &lt;= 1 (V)</td></tr>
                    <tr><td></td><td></td><td>1 + (1<sup>1</sup> /1)=2</td><td></td><td></td><td>1*1=1</td><td style="color:rgb(33, 15, 201)">2</td><td style="color:rgb(33, 15, 201)">2 &lt;= 1 (F)</td></tr>
                    <tr><td></td><td></td><td></td><td>1</td><td>1 &lt;= 5 (V)</td><td>1</td><td>1</td><td>1 &lt;= 2 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>1*1=1</td><td>2</td><td>1 &lt;= 2 (V)</td></tr>
                    <tr><td></td><td></td><td>1 + (1<sup>2</sup> /2)=2.5</td><td></td><td></td><td>1*2=2</td><td style="color:rgb(33, 15, 201)">3</td><td style="color:rgb(33, 15, 201)">3 &lt;= 2 (F)</td></tr>
                 
                    <tr><td></td><td></td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td>1</td><td>1</td><td>1 &lt;= 3 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>1*1=1</td><td>2</td><td>2 &lt;= 3 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>1*2=2</td><td>3</td><td>3 &lt;= 3 (V)</td></tr>
                    <tr><td></td><td></td><td>1 + (1<sup>3</sup> /6)=2.66667</td><td></td><td></td><td>2*3=6</td><td style="color:rgb(33, 15, 201)">4</td><td style="color:rgb(33, 15, 201)">4 &lt;= 3 (F)</td></tr>
                 
                    <tr><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td>1</td><td>1</td><td>1 &lt;= 4 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>1*1=1</td><td>2</td><td>2 &lt;= 4 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>1*2=2</td><td>3</td><td>3 &lt;= 4 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>2*3=6</td><td>4</td><td>4 &lt;= 4 (V)</td></tr>
                    <tr><td></td><td></td><td>1 + (1<sup>4</sup> /24)=2.70834</td><td></td><td></td><td>6*4=24</td><td style="color:rgb(33, 15, 201)">5</td><td style="color:rgb(33, 15, 201)">5 &lt;= 4 (F)</td></tr>
                  
                    <tr><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td>1</td><td>1</td><td>1 &lt;= 5 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>1*1=1</td><td>2</td><td>2 &lt;= 5 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>1*2=2</td><td>3</td><td>3 &lt;= 5 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>2*3=6</td><td>4</td><td>4 &lt;= 5 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>6*4=24</td><td>4</td><td>5 &lt;= 5 (V)</td></tr>
                    <tr><td></td><td></td><td>1 + (1<sup>5</sup> /120)=2.71667</td><td></td><td></td><td>24*5=120</td><td style="color:rgb(33, 15, 201)">6</td><td style="color:rgb(33, 15, 201)">5 &lt;= 5 (F)</td></tr>
                  </table> <br>
                  
                  <h1><b>Caso de Estudio 27: Serie de la Función Seno.</b></h1>
                  <h2><b>A) Problema</b></h2>
                  <p>El valor de la función y=sen(x) se puede aproximar mediante la siguiente serie de Taylor:</p>
                 <table align="right">
                  <td width="350"> <i>sen(x)</i>= x - (x<sup>3</sup> /3!) + (x<sup>5</sup> /5!) - (x<sup>7</sup> /!) + ... + (-1<sup>n</sup>)∙(x<sup>2n+1</sup>)/(2n+1)!
                  </td><td align="right">(1)</td></table> 
                   
                  <p>La fórmula de la sumatoria de la función es:</p>
                  <table align="right">
                    <td width="350"> <i>sen(x)</i>= &Sigma;<sup><font size="2">&infin;</font></sup><sub><font size="2">n=1</font></sub>   (-1<sup>n</sup>)∙(x<sup>2n+1</sup>)/(2n+1)!
                    </td><td align="right">(2)</td></table><br><br><br>
                    <p>Escribir un programa que permita aproximar el valor de la función seno utilizando la serie de Taylor y bucles anidados.</p>
                  <h2><b>B) Análisis</b></h2>
                  <p>Claramente se puede ver que las entradas del problema son el número de términos de la serie y el valor del ángulo en grados de la función seno. Se requiere una sola salida que es el valor de la serie aproximada. El proceso de cálculo requiere que la serie numérica infinita de la ecuación (2), se convierta a una serie numérica finita, donde el valor de ‘n’ se convierte en el valor de ‘i’ y el valor de infinito pasa a ser el valor de n-1, ya que si se quiere calcular la sumatoria de los cinco primeros términos de la serie, la sumatoria iría desde el valor de i = 0 hasta el valor de i = 5 - 1, es decir, i = 4, como se puede ver en la ecuación (3):</p>
                  <table align="right">
                    <td width="350"><i>sen(x)</i>= &Sigma;<sup><font size="2">n-1</font></sup><sub><font size="2">i=0</font></sub>   (-1<sup>i</sup>)∙(x<sup>2i+1</sup>)/(2i+1)!
                      
                    </td><td align="right">(3)</td></table>
                    <p>Para calcular el valor del factorial de la función seno se requiere utilizar la sucesión del factorial de un número cuya ecuación es:</p>
                    <table align="right"><td width="350">n! = &prod;<sup><font size="2">&infin;</font></sup><sub><font size="2">n=1</font></sub>  n </td>
                    <td align="right">(4)</td>
                    </table><br><br>
                    <p>Por lo que, el factorial de (2i+1) es:</p>
                    <table align="right">
                      <td width="350">(2i + 1)! = &prod;<sup><font size="2">2i=1</font></sup><sub><font size="2">j=1</font></sub>  j</td>
                    <td align="right">(5)</td>
                    </table><br><br>
                    <p>Reemplazando el valor de la ecuación (5) en la ecuación (3) se tiene:</p>
                    <table align="right">
                      <td width="350"><i>sen(x)</i>= &Sigma;<sup><font size="2">n-1</font></sup><sub><font size="2">i=0</font></sub>   (-1<sup>i</sup>)∙(x<sup>2i+1</sup>)/( &prod;<sup><font size="1">2i=1</font></sup><sub><font size="1">j=1</font></sub>  j)!                  
                      </td><td align="right">(2)</td></table>
                      <p>Como se puede ver en la ecuación (6) se requiere utilizar dos bucles anidados; un bucle externo para calcular la sumatoria y un bucle interno para calcular el factorial de un número que básicamente es un producto. Además, se tiene que convertir el valor del ángulo de grados a radianes para realizar los cálculos respectivos.</p>

    <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Entradas del Programa</b></p>
                    
      <table> <tr><td width="200"> n </td><td width="200">/* número de términos de la serie */</td></tr>
                    <tr><td>x</td><td>/* Ángulo de la función en grados */</td></tr>
                  </table><br>
                  <p><b>Salidas del Problema</b></p>
                  <table>
                    <tr><td width="200"> serie </td><td width="200">/* Resultado de la serie aproximada  */</td></tr>
                  </table><br>
      <p><b>Auxiliares del Problema</b></p>
                <table>
                 <tr><td width="200">i</td><td width="200">/* Contador para controlar la sumatoria */</td></tr>
                <tr><td width="200">j</td><td width="200">/* Contador para controlar el factorial de un número */</td></tr>
                <tr><td width="200">sum</td><td width="200">/* Acumulador de sumas */</td></tr>
                <tr><td width="200">prod</td><td width="200">/* Acumulador de productos */</td></tr>
               </table><br>
                  <p><b>Fórmulas Relevantes</b></p>
                  <table>
                    <tr><td><i>x = (x∙π)/180</i></td><td>1</td><td>Fórmula para convertir de grados a radianes </td></tr>
                <tr><td ><i>prod = prod ∙ valor </i></td><td> (2) </td><td>/* Fórmula que representa el acumulador de un producto */</td></tr>
                  <tr><td width="120"><i>sum = sum + valor</i></td><td width="30"> (3) </td><td width="280">/* Fórmula que representa el acumulador de una sumatoria */</td></tr>
                    <tr><td >n! = &prod;<sup><font size="2">&infin;</font></sup><sub><font size="2">n=1</font></sub>  n</td><td> (4) </td><td>/* Fórmula que representa el factorial de un número */</td></tr>
                    <tr><td ><i>sen(x)</i>= &Sigma;<sup><font size="2">n-1</font></sup><sub><font size="2">i=0</font></sub>   (-1<sup>i</sup>)∙(x<sup>2i+1</sup>)/( &prod;<sup><font size="1">2i=1</font></sup><sub><font size="1">j=1</font></sub>  j)!                  
                    </td><td> (5) </td>
                      <td>/* Fórmula que representa la serie del seno incluido el factorial de un número */</td></tr>
                  </table> <br>
  
                  <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                  <p>En la Figura 2.27.1 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘n’; la variable ‘x’; b) Salidas: la variable ‘serie’; c) Auxiliares: el contador ‘i’; el contador ‘j’; la variable ‘prod’; la variable ‘sum’; la constante PI.</p>
                  <img src="./assets/images/Capitulos/II/media/Figura 2.27.1.png" style="display:block; margin:auto; "><br>
                  <h5 style="text-align:center"><b>Figura 2.27.1. </b>Diagrama de Entrada-Salida del Programa.</h5>
                  <h2><b>C) Diseño</b></h2>
                  <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                  
        <p><b>Algoritmo</b></p>
                  
                  <ol type="1">
                    <li>Imprimir el mensaje de información: Serie del Seno <sup>x</sup>.</li>
                    <li>Leer el número de términos de la serie, utilizando la variable ‘n’.</li>
                    <li>Leer el valor del ángulo en grados de la función seno, utilizando la variable ‘x’..</li>
                    <li>Convertir el valor del ángulo ‘x’ de grados a radianes, utilizando la fórmula (1).</li>
                    <li>Inicializar con el valor de cero el acumulador de sumas cuya variable utilizada es ‘sum’.</li>
                    <li>Para el bucle externo, hacer: </li>
                    <ol type="1" start="6"><li>1.	Inicializar el valor del contador ‘i’ en cero. </li></ol>
                    <ol type="1" start="6"><li>2.	Mientras el valor de la condición (i &lt;=n-1) sea verdadera ejecutar las sentencias del bucle externo. </li></ol>
                    <ol type="1" start="6"><li>3.	Luego de cada iteración incrementar en uno el valor del contador ‘i’. </li></ol>
                    <ol type="1" start="6"><li>4.	Inicializar el acumulador de productos ‘prod’ con el valor de uno.</li></ol>
                    <ol type="1" start="6"><li>5.	Para el bucle interno, hacer: </li>
                      <ol type="1" start="6"><li>5.1.	Inicializar el valor del contador ‘j’ en uno.</li></ol>
                      <ol type="1" start="6"><li>5.2.	Mientras el valor de la condición (j&lt;=i*i+1) sea verdadera ejecutar las sentencias del bucle interno.</li></ol>
                      <ol type="1" start="6"><li>5.3.	Luego de cada iteración incrementar en uno el valor del contador ‘j’.</li></ol>
                      <ol type="1" start="6"><li>5.4.	Asignar al acumulador ‘prod’ lo que tiene multiplicado por el valor del contador ‘j’.</li></ol>
                    </ol>
                    <ol type="1" start="6"><li>6.	Asignar al acumulador ‘sum’ lo que tiene sumado el valor del término e-nésimo de la serie.</li></ol>

                    <li>Asignar a la variable serie el valor del acumulador ‘sum’.</li>
                    <li>Imprimir el valor de la serie aproximada.</li>
                  </ol>                    


                    <h2><b>D) Implementación</b></h2>
                    <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.27.1 se muestra el código del programa en C/C++.</p>
                    <h5><b>Tabla 2.27.1. </b>Programa que calcula la serie de la función seno.</h5>
                    <pre><code [highlight]="prefTab2[0].tabla2_27_1"  [lineNumbers]="true"></code></pre> <br>
                    <h2>E) Pruebas</h2>
                    <p>En la Tabla 2.27.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                    <p>En la salida de la Tabla 2.27.2 se puede ver que, al ingresar el número de términos igual a 10 y el valor del ángulo en grados igual a 30, se obtiene el valor de la serie aproximada igual a 0.5.</p>
                    <h5><b>Tabla 2.27.2.</b> Salida del programa</h5>
                    <img src="./assets/images/Capitulos/II/media/Tabla 2.27.2.png" style="display:block; margin:auto; "><br>
                    <p>En la Tabla 2.27.3, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada iteración del bucle externo for() se inicializa el acumulador del producto en 1 y luego se calcula el factorial de (2i+1) utilizando un bucle interno for(). Luego de ejecutarse el bucle interno for() se utiliza un acumulador de sumas donde se acumulan los valores parciales de la serie de la función y la ejecución del bucle externo termina cuando la condición de esta sentencia se hace falsa.</p>
                   <h5><b>Tabla 2.27.3. </b>Prueba de escritorio del programa.</h5>
                   <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                    <tr style="color:red"><td>n</td><td>x</td><td>Sum</td><td>i</td><td>i &lt;= n - 1</td><td>prod</td><td>j</td><td>j &lt;= 2*i+1</td></tr>
                      <tr><td>3</td><td>π/6</td><td>0</td><td>0</td><td>0 &lt;= 3 (V)</td><td>1</td><td>1</td><td>1 &lt;= 1 (V)</td></tr>
                      <tr><td></td><td></td><td>0 + π/6 = π/6 = 0.523599</td><td></td><td></td><td>1*1=1</td><td style="color:rgb(33, 15, 201)">2</td><td style="color:rgb(33, 15, 201)">2 &lt;= 1 (F)</td></tr>
                      <tr><td></td><td></td><td></td><td>1</td><td>1 &lt;= 3 (V)</td><td>1</td><td>1</td><td>1 &lt;= 3 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>1*1=1</td><td>2</td><td>2 &lt;= 3 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>1*2=2</td><td>3</td><td>3 &lt;= 3 (V)</td></tr>
                      <tr><td></td><td></td><td>0.523599 - (π/6)<sup>3</sup>/6=0.49967</td><td></td><td></td><td>2*3=6</td><td style="color:rgb(33, 15, 201)">4</td><td style="color:rgb(33, 15, 201)">4 &lt;= 3 (F)</td></tr>
                      <tr><td></td><td></td><td></td><td>2</td><td>2 &lt;= 3 (V)</td><td>1</td><td>1</td><td>1 &lt;= 5 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>1*1=1</td><td>2</td><td>2 &lt;= 5 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>1*2=2</td><td>3</td><td>3 &lt;= 5 (V)</td></tr>                      
                      <tr><td></td><td></td><td></td><td></td><td></td><td>2*3=6</td><td>4</td><td>4 &lt;= 5 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>6*4=24</td><td>5</td><td>5 &lt;= 5 (V)</td></tr>
                      <tr><td></td><td></td><td>0.499674 + (π/6)<sup>5</sup>/120 = 0.5000002</td><td></td><td></td><td>24*5=120</td><td style="color:rgb(33, 15, 201)">6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td></tr>
                   
                      <tr><td></td><td></td><td></td><td>3</td><td>3 &lt;= 3 (V)</td><td>1</td><td>1</td><td>1 &lt;= 7 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>1*1=1</td><td>2</td><td>2 &lt;= 7 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>1*2=2</td><td>3</td><td>3 &lt;= 7 (V)</td></tr>                      
                      <tr><td></td><td></td><td></td><td></td><td></td><td>2*3=6</td><td>4</td><td>4 &lt;= 7 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>6*4=24</td><td>5</td><td>5 &lt;= 7 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>24*5=120</td><td>6</td><td>6 &lt;= 7 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>120*6=720</td><td>7</td><td>7 &lt;= 7 (V)</td></tr>
                      <tr><td></td><td></td><td>0.5000002 - (π/6)<sup>7</sup>/5040 = 0.5</td><td></td><td></td><td>720*7=5040</td><td style="color:rgb(33, 15, 201)">8</td><td style="color:rgb(33, 15, 201)">8 &lt;= 7 (F)</td></tr>
                                      
                      <tr><td></td><td></td><td style="color:rgb(33, 15, 201)">4</td><td style="color:rgb(33, 15, 201)">4&lt;= 3 (F)</td><td></td><td></td><td></td><td></td></tr>
                    </table> <br> 


              </ng-template>
            </mat-tab>
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Resumen">
        <ng-template matTabContent>
          <br><h1>Resumen</h1>
          <ol type="1">
            <li>Un algoritmo es un método para resolver un problema. La solución de un problema de programación implica la aplicación de cuatro fases: a) Análisis del problema; b) Diseño del algoritmo; c) Desarrollo y codificación; Implementación y pruebas.</li>
            <li>Un programa es un conjunto de instrucciones que producirán la ejecución de una determinada tarea para conseguir un fin.</li>
            <li>El pseudocódigo es un lenguaje que se utiliza para describir algoritmos y ayuda a la codificación de un programa.</li>
            <li>La programación estructurada enseña la descomposición de un programa en módulos más simples de programar que permitirá la escritura de programas fáciles de leer y modificar. En un programa estructurado el flujo lógico se gobierna por las estructuras de control básicas: a) estructuras secuenciales; b) estructuras de decisión; c) estructuras repetitivas. El estudio de las estructuras de control se realiza en base al diseño de algoritmos y a la creación de programas en lenguaje C/C++.</li>
            <li>La estructura de control secuencial es aquella en la que una instrucción se ejecuta a continuación de otra de modo de secuencia.</li>
            <li>La estructura de control de selección es aquella en la que las instrucciones se ejecutan entre acciones alternativas. Las principales sentencias de decisión son: a) La sentencia if; b) La sentencia if-else; c) Sentencias if-else anidadas; d) Secuencia de Sentencias if; e) Secuencia de Sentencias if-else; f) Sentencia de control switch.</li>
            <li>La estructura de control conocida como bucle es aquella que realiza la repetición o iteración de acciones o grupos de sentencias. Las principales sentencias de repetición son: a) La sentencia while; b) La sentencia do-while; c) La sentencia for; d) Bucles anidados.</li>
            <li>En el lenguaje C/C++ es posible anidar bucles, donde estos bucles anidados constan de un bucle externo con uno o más bucles internos. Cada vez que se repite el bucle externo, los bucles internos se repiten y se ejecutan las sentencias de estos bucles</li>
          </ol>
        </ng-template>
      </mat-tab>

      <mat-tab label="Test de Conocimientos">
        <ng-template matTabContent>

        </ng-template>
      </mat-tab>

      <mat-tab label="Ejercicios Propuestos">
        <ng-template matTabContent>

        </ng-template>
      </mat-tab>

      <mat-tab label="Bibliografía">
        <ng-template matTabContent>

        </ng-template>
      </mat-tab>

    </mat-tab-group>
  <button mat-button (click)="selectTabNext()" *ngIf="positionCurrentNext">{{titleNext}} <mat-icon>navigate_next</mat-icon></button>
    <button mat-button (click)="selectTabBefore()" *ngIf="positionCurrentBefore"><mat-icon>navigate_before</mat-icon> Atras  &nbsp; &nbsp; &nbsp;&nbsp;</button>

</div>
<!-- EXAMPLES
<mat-tab label="Pracniques">
  <ng-template matTabContent>
    <mat-tab-group>
      &lt;!&ndash; <mat-tab *ngFor="let tab of asyncTabs | async"> &ndash;&gt;
      <mat-tab *ngFor="let tab of praqnique" label="{{tab.label}}">
        <br>
        <table>
          <tr>
            <td>
              <h2 style="color:green;"><strong>{{tab.tituloN}}</strong></h2>
            </td>
            <td>
              <h2>{{tab.titulo}}</h2>
            </td>
          </tr>
        </table>
        <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
          <TR>
            <TABLE>
              <TR><strong>SINOPSIS</strong></TR>
              <TR>{{tab.sinopsisDescrip}}</TR>
            </TABLE>
          </TR>
          <TR>
            <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
              <TR *ngFor="let item of tab.sinopsis">
                <TD><strong>{{item.titulo}}</strong>{{item.descrip}}</TD>
              </TR>
            </TABLE>
          </TR>
        </TABLE><br>
        <a href="{{tab.link}}" download="ProgramaPracnique">
          <mat-icon>save_alt</mat-icon><strong>Descargar {{tab.tituloN}} PracniqueCompGraf.zip</strong>
        </a>
        <br><br>
        <h3><strong>{{tab.A.subtitulo}}</strong></h3>
        <p>{{tab.A.problema}}</p>
        <img src="{{tab.A.fotoPath}}" style="display:block; margin:auto;"><br>
        <h5><strong>{{tab.A.fotoN}}</strong>{{tab.A.fotoDescrip}}</h5><br>
        <p>{{tab.A.problema1}}</p>
        <ul *ngFor="let x of tab.A.problemalist">
          <div>{{x}}</div>
        </ul>
        <h3><strong>{{tab.B.subtitulo}}</strong></h3>
        <div *ngFor="let itemPasos of tab.B.pasosB">
          <h3><strong>{{itemPasos.subtitulo2}}</strong></h3>
          <p><strong>{{itemPasos.tituloproblema}}</strong></p>
          <p>{{itemPasos.parrafo}}</p>
          <img src="{{itemPasos.fotoPath}}" style="display:block; margin:auto; ">
          <p>{{itemPasos.parrafo2}}</p>
          <p>{{itemPasos.parrafo3}}</p>
          <p><strong>{{itemPasos.titulosolucion}}</strong></p>
          <div *ngFor="let item of itemPasos.solucion">
            <mathjax [content]=item.parrafo class='box'></mathjax>
            <img src="{{item.fotoPath}}" style="display:block; margin:auto; ">
          </div>
        </div>
        <h3><strong>{{tab.C.subtitulo}}</strong></h3>
        <dl *ngFor="let itemAlgoritmos of tab.C.algoritmosC">
          <dt>{{itemAlgoritmos.titulo}}</dt>
          <dd>
            <ul *ngFor="let p of itemAlgoritmos.pasos; index as i">
              <div value="{{i+1}}">{{p}}</div>
            </ul>
            <ul *ngFor="let p of itemAlgoritmos.pasosFormulas; index as i">
              <div value="{{i+1}}">{{p}}</div>
            </ul>
          </dd>
        </dl>
        <h3><strong>{{tab.D.subtitulo}}</strong></h3>
        <div *ngFor="let itemCodigos of tab.D.listaCodigo">
          <p>{{itemCodigos.problema}}</p>
          <h5><strong>{{itemCodigos.tablaN}}</strong>{{itemCodigos.tablaDescrip}}</h5><br>
          <pre><code [highlight]="itemCodigos.tablaDatos" (highlighted)="onHighlight($event)" [lineNumbers]="true"></code></pre><br>
        </div>
        <h3><strong>{{tab.E.subtitulo}}</strong></h3>
        <div *ngFor="let item of tab.E.listaPrueba">
          <p>{{item.problema}}</p>
          <img src="{{item.fotoPath}}" style="display:block; margin:auto; width: 75%;"><br>
          <h5><strong>{{item.fotoN}}</strong>{{item.fotoDescrip}}</h5><br>
        </div>
      </mat-tab>
    </mat-tab-group>
  </ng-template>
</mat-tab>
<mat-tab label="Pracniques Propuestos">
  <ng-template matTabContent>
    <mat-tab-group>
      &lt;!&ndash; <mat-tab *ngFor="let tab of asyncTabs | async"> &ndash;&gt;
      <mat-tab *ngFor="let tab of praqniquePropuesto" label="{{tab.label}}">
        <br>
        <table>
          <tr>
            <td>
              <h2 style="color:green;"><strong>{{tab.tituloN}}</strong></h2>
            </td>
            <td>
              <h2>{{tab.titulo}}</h2>
            </td>
          </tr>
        </table>
        <h3><strong>{{tab.subtitulo}}</strong></h3>
        <div *ngFor="let item of tab.listaGeneral">
          <div *ngFor="let i of item.listaParrafoFotos">
            <mathjax [content]=i.problema class='box'></mathjax><br>
            <img src="{{i.fotoPath}}" style="display:block; margin:auto; width: 50%;"><br>
            <h5><strong>{{i.fotoN}}</strong>{{i.fotoDescrip}}</h5><br>
          </div>
          <div *ngFor="let i of item.listaParrafos">
            <mathjax [content]=i.problema class='box'></mathjax><br>
          </div>
          <div *ngFor="let i of item.listaFotos">
            <img src="{{i.fotoPath}}" style="display:block; margin:auto; width: 50%;"><br>
            <h5><strong>{{i.fotoN}}</strong>{{i.fotoDescrip}}</h5><br>
          </div>
        </div>
        <a href="{{tab.linkAnexo}}" download="Anexo">
          <mat-icon>{{tab.iconodescarga}}</mat-icon><strong>{{tab.tituloAnexo}}</strong>
        </a>
      </mat-tab>
    </mat-tab-group>
  </ng-template>
</mat-tab>
<mat-tab label="Evaluación">
  <ng-template matTabContent>
    <div class="Evaluacion">
      <app-quiz [propagarNumCapitulo]="num_capitulo"></app-quiz>
    </div>
  </ng-template>
</mat-tab>
<mat-tab label="Juegos">
  <ng-template matTabContent>
    <div class="Snake">
      <app-snake></app-snake>
    </div>
  </ng-template>

</mat-tab>
<mat-tab label="Resumen">
  <ng-template matTabContent>
    <br>
    <h1>Resumen</h1>
    <ul>
      <li>La forma más conveniente de especificar un segmento de línea en la pantalla de una computadora es proporcionan.</li>
      <li>El componente o subsistema GDI (Graphics Device Interface) trabaja junto con el núcleo y la API de Windows do las coordenadas de sus dos puntos finales.</li>
      <li>Un punto es el objeto geométrico más simple y elemental, que permite representar líneas, planos, vectores y todo tipo de figuras geométricas complejas en 2D y 3D como curvas, superficies y sólidos.</li>
      <li>La estructura Point (Point Struct), representa un par ordenado de coordenadas x e y enteras que define un punto en un plano bidimensional.</li>
      <li>La estructura PointF (PointF Struct), representa un par ordenado de coordenadas x e y de punto flotante que define un punto en un plano bidimensional.</li>
      <li>Cuando se necesita trabajar con varios puntos para graficar una Figura Geométrica como un polígono o una curva se puede utilizar un arreglo de puntos.</li>
      <li>Un punto se puede mover desde una localidad a otra de dos maneras: a) Primero, se puede trasladar un punto desde su posición actual a una nueva; b) Segundo, se puede rotar ese punto con respecto a otro en el plano o en los ejes dentro de un espacio a una nueva posición.</li>
      <li>El rectángulo (Rectangle) es una estructura (struct) que almacena un conjunto de cuatro enteros que representan la localización y el tamaño de un rectángulo en un lienzo o canvas.</li>
      <li>Un vector es un ente matemático que tiene módulo (magnitud), dirección y sentido.</li>
      <li>Se pueden graficar las líneas y puntos notables de un triángulo utilizando Geometría Aplicada y utilizando las ecuaciones de traslación de un punto a otro en el mundo de la Computación Gráfica.</li>
      <li>Un vector 2D tiene dos componentes en el plano (x,y) que se lo puede representar gráficamente utilizando líneas con puntos y con flechas, aplicando Geometría Aplicada y utilizando las ecuaciones de traslación de un punto a otro en el mundo de la Computación Gráfica.</li>
      <li>Un vector 3D tiene tres componentes en el plano (x,y,z) que se lo puede representar gráficamente utilizando líneas con puntos y con flechas, aplicando Geometría Aplicada y utilizando las ecuaciones de traslación de un punto a otro en el mundo de la Computación Gráfica.</li>
    </ul>
  </ng-template>
</mat-tab>
<mat-tab label="Bibliografía">
  <ng-template matTabContent>
    <br>
    <h1>Bibliografía</h1>
    <ul>
      <li>Ammeraal, L., Zhang, K., 2017. Computer Graphics for Java Programmers. Springer. Third Edition.</li>
      <li>Lengyel, E., 2011. Mathematics for 3D Game Programming and Computer Graphics. Charles River Media. Third Edition.</li>
      <li>Steeb, W.H., Hardy, A., 2008. Mathematical Tools in Computer Graphics with C# Implementations. World Scientific Pub. Co. Inc. First Edition.</li>
      <li>Spiegel, M., Lipschutz, S., Spellman, D., 2011. Análisis Vectorial. 2° edición. SCHAUM, McGraw-Hill, Interamericana Editores, S.A., México. ISBN: 978-607-15-0550-7.</li>
      <li>Kimberling, C., 1994. Encyclopedia of Triangle Centers. Evansville University. Disponible en: https://faculty.evansville.edu/ck6/encyclopedia/ETC.html</li>
      <li>Beer, F., Jhonston, E.R., Mazurek, D., Eisenberg, E., 2010. Mecánica Vectorial para Ingenieros. Estática. Novena Edición. McGraw-Hill/Interamericana Editores, S.A., México. ISBN: 978-607-15-0277-3.</li>
    </ul>
  </ng-template>
</mat-tab>-->
