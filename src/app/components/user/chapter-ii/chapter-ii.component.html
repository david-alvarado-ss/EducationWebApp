<div style="margin: 50px;">
    <ng-container *ngIf="(asyncTabs | async) === null">
        Loading tabs...
    </ng-container>
    <table>
        <tr>
            <td>
                <h1><b> CAPÍTULO 2 ALGORITMOS Y ESTRUCTURAS DE CONTROL EN LENGUAJE C/C++
                </b></h1>
            </td>
            <td></td>
            <td>
                <a href="https://drive.google.com/uc?id=1yQtGhmytRdEwydcquFPeafxYunAMHTux&export=download" download="Capitulo12021">
                    <mat-icon>cloud_download</mat-icon>Descargar Archivo Capítulo II
                </a>
            </td>
        </tr>
    </table>

    <mat-tab-group [selectedIndex]="selectedIndex.value" (selectedIndexChange)="selectedIndex.setValue($event)">
        <mat-tab label="Introducción">
            <ng-template matTabContent>
              <br>
              <h1>Introducción</h1>
              <p>En este capítulo se aprenderán a diseñar algoritmos y a utilizar la computadora como una herramienta para resolver problemas creando programas con estructuras de control en el lenguaje C/C++. Para la solución de problemas de programación se aplican aspectos de Ingeniería de Software y el método científico que permiten identificar a la programación con un enfoque sistemático. 
              </p>
              <p>
                En un programa estructurado el flujo lógico se gobierna por tres estructuras de control básicas: a) estructuras secuenciales; b) estructuras de decisión; c) estructuras repetitivas. El estudio de las estructuras de control se realiza en base al diseño de algoritmos y a la creación de programas en un lenguaje de programación estructurado como es el Lenguaje C/C++.
              </p>
            </ng-template>
        </mat-tab>
        <mat-tab label="Objetivos">
            <ng-template matTabContent>
              <br>
                <h1>Objetivos</h1>
                <ul>
                    <li>Revisar los principales conceptos en torno a algoritmos y a estructuras de control.</li>
                    <li>Entender cómo trabajan los algoritmos y las estructuras de control y cómo se aplican con el lenguaje C/C++ en la construcción de programas.</li>
                    <li>Aprender a crear algoritmos en Pseudocódigo y en Lenguaje C/C++.</li>
                    <li>Diseñar y crear programas en lenguaje C/C++ utilizando algoritmos y estructuras de control.</li>
                    <li>Resolver casos de estudio con algoritmos y estructuras de control aplicadas al área matemática.</li>
                </ul>
                  </ng-template>
        </mat-tab>
      <mat-tab label="Algoritmo">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="2.1.1. Definición de Algoritmo">
              <ng-template matTabContent>
                <br>
              <h1>Definición de Algoritmo</h1>
              <p>Un algoritmo es un conjunto de pasos o instrucciones ordenadas y finitas que permiten resolver un problema (Joyanes,L., 2008). Etimológicamente hablando la palabra algoritmo proviene del latín, dixit algorithmus y este del griego arithmos, que significa número y también con la influencia del matemático persa Muhammad Al-Juarismi que vivió durante el siglo IX y alcanzó gran reputación por el enunciado de las reglas paso a paso para sumar, restar, multiplicar y dividir números decimales. Euclides, el gran matemático griego que vivió en el siglo IV antes de Cristo, inventó un método para encontrar el Máximo Común Divisor (MCD) de dos números en base a divisiones sucesivas. A Euclides y a Al-Juarismi se les consideran los padres de la algoritmia que es una ciencia que se dedica al estudio de los algoritmos.
              </p>
              </ng-template>
            </mat-tab>
            <mat-tab  label="2.1.2. Características de los Algoritmos">
              <ng-template matTabContent>
                <br>
                <h1>Características de los Algoritmos </h1>
                <p>
                  Un algoritmo tiene las siguientes tres características (Joyanes, L., 2008):
                </p>
                <br>
                <li><strong>Preciso: </strong>Un algoritmo debe definirse de manera rigurosa sin ambigüedades.
                </li>
                <li><strong>Definido: </strong>Si se sigue un algoritmo dos veces, se debe obtener el mismo resultado.</li>
                <li><strong>Finito: </strong>Un algoritmo debe terminar en algún momento.</li>
                <br>
                <p>
                  Considerando estas características un algoritmo puede tener elementos de entrada y debe producir un resultado claro y conciso, que puede ser escrito en un lenguaje de programación como C/C++.   
                </p>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.3. Etapas para la Solución de un Problema">
              <ng-template matTabContent>
                <br>
                <h1>Etapas para la Solución de un Problema</h1>
            
                <p>
                  Los Ingenieros en Sistemas en la industria de la computación han encontrado que la ingeniería y el método científico para la solución de problemas pueden ser adaptados para el desarrollo confiable de sistemas de software (Hanly, J., Koffman, E., Horvath, J., 1995). Desde hace varias décadas la Ingeniería de Software ha sido utilizada para identificar la programación con un enfoque sistemático (Pressman, R., 2010). En este capítulo se van a aplicar cuatro fases en la resolución de problemas de programación, considerando los aspectos de la ingeniería y el método científico dentro de cada fase.
                </p>
                <br>
                <ol type="1" style="font-weight: normal;" >
                  <li><strong>Análisis del Problema: </strong>En esta fase, se estudia la especificación del problema, se identifican las entradas y salidas requeridas. Se revisan los principios teóricos y científicos que se aplican en la solución de un problema y se listan las fórmulas o relaciones relevantes.</li>
                  <li><strong>Diseño del Algoritmo: </strong>En esta fase, se escribe el algoritmo y se lista los sub-problemas a detalle. Se puede aplicar el proceso llamado “divide y vencerás” (divide and conquer), donde el problema se divide en sub-problemas.</li>
                  <li><strong>Desarrollo y Codificación: </strong>En esta fase, se presenta la codificación del programa en Lenguaje C/C++, debidamente comentado y explicado conforme a los algoritmos diseñados, considerando la especificación de requerimientos, datos, constantes y fórmulas requeridas para resolver el problema.</li>
                  <li><strong>Implementación y Pruebas: </strong>En esta fase, se verifica que la solución del problema es correcta y el programa trabaja adecuadamente, para lo cual se corre el programa varias veces y se prueba con diferentes valores. Además, se pueden contemplar pruebas de escritorio del programa mostrando el funcionamiento de algunas partes del mismo o en su totalidad considerando los datos y los cálculos que se necesitan procesar.</li>
                </ol>

              </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.4. Programas y Algoritmos">
              <ng-template matTabContent>
                <br>
                <h1>Programas y Algoritmos</h1>
               
                <p>Un algoritmo como se mencionó en la sección 2.1.1, es un conjunto de pasos o instrucciones que se siguen para resolver un problema. Un programa implementa uno o más algoritmos y lo traduce a lenguaje máquina. Según Joyanes Aguilar, et al. (2005), un algoritmo se puede expresar de tres maneras: a) forma gráfica, utilizando un diagrama de flujo; b) pseudocódigo que es un lenguaje de descripción algorítmica; c) lenguaje de programación que es una manera explícita de representar un algoritmo. En este capítulo se van a diseñar algoritmos mediante pseudocódigo y se los van a implementar utilizando el Lenguaje de Programación C/C++.</p>
              <p>Los programas se pueden dividir en sub-programas utilizando funciones, de modo que la complejidad algorítmica se reduce a tener un solo programa completo, lo cual ayuda a mejorar el rendimiento del mismo. Esta práctica es muy utilizada y se conoce como refinamiento progresivo. De acuerdo con Wirth Niklaus (1971), un programa está formado por algoritmos y estructuras de datos.</p>
              <p>La programación como tal puede tener muchos enfoques o paradigmas de programación lo cual permite formular la resolución de un problema de diferentes formas. Los dos paradigmas de programación más utilizados son: a) Paradigma de Programación Estructurada, que permite mejorar la calidad, claridad y tiempo de desarrollo de un programa recurriendo al uso de subrutinas y estructuras de control; b) Paradigma de Programación Orientada a Objetos, que permite innovar la programación utilizando objetos que manipulan datos y diferentes mecanismos de abstracción como herencia y polimorfismo (Granizo E., 2016).</p>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.5. Pseudocódigo como Técnica de Representación de un Algoritmo">
              <ng-template matTabContent>
                <br>
                <h1>Pseudocódigo como Técnica de Representación de un Algoritmo</h1>
         
              <p>Pseudocódigo es un lenguaje de especificación o descripción de algoritmos. El uso de este lenguaje ayuda a la codificación de un programa de una manera relativamente fácil (Joyanes Aguilar, L., 2008). Este lenguaje nació en inglés y era un medio de representación básico de las estructuras de control de la programación estructurada. Actualmente, se lo puede utilizar también en español sustituyendo las palabras originales del idioma inglés. En esta obra de programación se utilizará la técnica del pseudocódigo para diseñar los algoritmos de los programas y el Lenguaje C/C++ para implementar los mismos.</p>
              <p>Por ejemplo, algunas de las palabras reservadas y operadores que maneja el Pseudocódigo son:</p>
            <ol>
                <li value="1">Leer (Read)</li>
                <li>Imprimir (Print/Write)</li>
                <li>Calcular (Calculate)</li>
                <li>Repetir (Repeat)</li>
                <li>Asignar a 'x', el valor de 'y':
                  <ul>
                    <li>	x &larr; y; (Opción 1)</li>
                  <li>	x := y; (Opción 2)</li>
                  <li>	x = y; (Opción 3)</li>
                  </ul>
                </li>
            </ol>  
                <p>En la sección 2.2 se presentará el algoritmo en Pseudocódigo y la implementación de programas en Lenguaje C/C++, utilizando estructuras de control secuenciales, selectivas y repetitivas. Además, se presentan varios Casos de Estudio donde se cumplen con las etapas para la solución de un problema, aplicando el método científico.</p>

            </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.6. Diseño Conceptual de Procesos Aplicado a Programas">
              <ng-template matTabContent>
                <br>
                <h1>Diseño Conceptual de Procesos Aplicado a Programas</h1>
               
                <p>Un proceso es un sistema formado por unidades, componentes o equipos interconectados en forma organizada para procesar, modificar o transformar las propiedades de elementos o corrientes de proceso en productos de interés (Mallar, M.A., 2010). Un proceso se puede representar por: a) Diagrama de Entrada-Salida (input-output); b) Diagrama de Bloques (operaciones principales); c) Diagrama de Flujos (Flowsheet); d) Diagrama de tuberías e instrumentación (PID).</p>
                <p>El Diagrama de Entrada-Salida (input-output) se utiliza para representar flujos de materiales considerando las entradas y salidas de los procesos de fabricación de un producto. En la Figura 2.1 se muestra un ejemplo de un Proceso Químico donde las entradas son: a) Recursos económicos; b) Materias primas; c) Energía; las salidas son: a) Recursos económicos; b) Productos; c) Energía; d) Residuos.</p>
                <br>
                <img src="./assets/images/Capitulos/II/media/Figura 2.1..png" style="display:block; margin:auto; "><br>
                
                <h5 style="text-align:center"><b>Figura 2.1. </b>Diagrama de Entrada-Salida de un Proceso Químico (Adaptado de: Arce, E., 2011).</h5>
                <br>
                <p>Este tipo de diagramas también se pueden utilizar para representar un programa como un proceso. Conceptualmente un programa puede ser considerado como una caja negra (Joyanes Aguilar, L., 2008), donde la caja negra es el proceso o algoritmo de resolución, las entradas y las auxiliares son un grupo de datos que van a ser procesados para obtener las salidas o resultados, como se puede ver en la Figura 2.2. En el resto de capítulos y lecciones se utilizará el Diagrama de Entrada-Salida para entender el funcionamiento de un algoritmo como un proceso.</p>
                <br>
                <img src="./assets/images/Capitulos/II/media/Figura 2.2..png" style="display:block; margin:auto; "><br>
                
                <h5 style="text-align:center"><b>Figura 2.2. </b>Diagrama de Entrada-Salida de un Programa (Adaptado de: Joyanes Aguilar, L., 2008).</h5>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.7. Aplicaciones de Algoritmos en la Vida Cotidiana">
              <ng-template matTabContent>
                <br>
                <h1>Aplicaciones de Algoritmos en la Vida Cotidiana</h1>
              
                <p>Un …………………..xyz</p>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.8. Estructuras de Control en Lenguaje C/C++">
              <ng-template matTabContent>
                <br>
                <h1>Estructura de Control en Lenguaje C/C++</h1>
               
                <p>Las estructuras de control permiten manejar y modificar el flujo de ejecución de las instrucciones de un programa (Granizo E., 2016). Entre las principales estructuras de control están:</p>
                <ol type="a">
                  <li>Estructuras de control secuenciales.</li>
                  <li>Estructuras de control selectivas.</li>
                  <li>Estructuras de control repetitivas.</li>
                </ol>
              </ng-template>
            </mat-tab>
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Estructuras de Control Secuenciales">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="Introducción">
              <ng-template matTabContent>
                <br>
               <h1>Estructuras de Control Secuenciales</h1>
              
               <p>La estructura de control secuencial es aquella en la que una instrucción se ejecuta a continuación de otra a modo de secuencia, es decir, una instrucción no se ejecuta hasta que finaliza la anterior (Joyanes Aguilar, L., 2008). Las operaciones se suceden de tal modo que la salida de una es la entrada de la siguiente y así sucesivamente hasta el fin del proceso. Los principales componentes de las estructuras de control secuenciales son:</p>
               <ol type="a">
                 <li>Escritura</li>
                 <li>Lectura</li>
                 <li>Asignación
                   <ul>
                     <li>Asignación Simple</li>
                     <li>Asignación Contador</li>
                     <li>Asignación Acumulador</li>
                     <li>Asignación de Trabajo</li>
                   </ul>
                 </li>
               </ol>
               </ng-template>
            </mat-tab>
            <mat-tab  label="2.2.1. Escritura">
              <ng-template matTabContent>
                <br>
                <h1>Escritura</h1>

                <p>La escritura consiste en enviar por un dispositivo de salida un resultado o mensaje. En la sección 1.4.1 se explica a detalle la función de escritura en el Lenguaje C/C++. Esta operación se puede representar mediante pseudocódigo y Lenguaje C/C++ como se indica a continuación: </p>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="200"> <b> Pseudocódigo </b> </th>
                    <th width="200"> <b> Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR>
                    <td><p>entero : a</p>
                    <p>a &#8592; 7</p>
                    <p>Imprimir 'a'</p></td>
                    <td> <p>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> a;</font></p>
                    <p>a=7;</p>
                    <p>cout 
                      <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font>
                       a;</p></td>
                  </TR>
                </TABLE>

              </ng-template>
            </mat-tab>
            <mat-tab  label="2.2.2. Lectura">
              <ng-template matTabContent>
                <br>
                <h1>Lectura</h1>
              
                <p>La lectura consiste en recibir desde un dispositivo de entrada un valor. En la sección 1.4.2 se explica a detalle la función de lectura en el Lenguaje C/C++. Esta operación se puede representar mediante pseudocódigo y Lenguaje C/C++ como se indica a continuación:</p>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="200"> <b> Pseudocódigo </b> </th>
                    <th width="200"> <b> Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR>
                    <td><p>entero : a</p>
                    <p>Leer 'a'</p></td>
                    <td> <p>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> a;</font></p>
                    <p>cin 
                      <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                       a;</p></td>
                  </TR>
                </TABLE><br>
                <p><b>Ejercicio 2.1: </b>Escribir un programa que permita sumar dos números enteros, para lo cual se puede utilizar la siguiente expresión matemática: num3 = num1 + num2, considerando que se deben utilizar tres variables.</p>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> 
                    <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                    <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR>
                    <td>1</td>  <td>entero : num1</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> num1;</font>
                    </td>
                  </TR>
                  <TR>
                    <td>2</td>
                    <td>entero : num2</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> num2;</font>
                    </td>
                  </TR>
                  <TR>
                    <td>3</td> <td>entero : num3</td> <td> 
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> num3;</font>
                    </td>
                  </TR>
                  <TR><td>4</td><td>Leer num1</td><td>cin <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font> num1;</td></TR>
                  <TR><td>5</td><td>Leer num1</td><td>cin <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font> num2;</td></TR>
                  <TR><td>6</td><td>num3 &#8592; num1 + num2</td><td>num3 = num1 + num2;</td></TR>
                  <TR><td>7</td><td>Imprimir mensaje: "Resultado de la suma: "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                    <font color="red">"Resultado de la suma: "</font>;</td></TR>
                  <TR><td>8</td><td>Imprimir num3</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> num3</td></TR>
                </TABLE>
                <br><h5><b>Programa 2.1.</b> Código del programa.</h5>
                <pre><code [highlight]="prefTab2[0].programa2_1"  [lineNumbers]="true"></code></pre><br>
                <p>La Ejecución 2.1, correspondiente a la salida del programa, muestra que al ingresar el primer número que es el 8 y el segundo número que es el 2, se obtiene la suma entre los dos números que es el 9.</p>
                <h5><b>Ejecución 2.2.</b>Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Ejecución 2.1.png" style="display:block; margin:auto; "><br>
                
              </ng-template>
            </mat-tab>
            <mat-tab  label="2.2.3. Asignación">
              <ng-template matTabContent>
                <br><h1>Asignación</h1>
                <p>La asignación consiste en el paso de valores a una zona de la memoria RAM, tal y como se describió en la sección 1.5.4 sobre el funcionamiento del operador de asignación igual. En la memoria RAM se almacenan temporalmente las variables que reciben valores de procesos lectura y de cálculos. La asignación se puede clasificar en cuatro tipos: a) Asignación simple; b) Asignación contador; c) Asignación acumulador; d) Asignación de trabajo.</p>
                <ol type="a">
                  <li><b>Asignación simple: </b>Esta asignación consiste en pasar un valor a una variable. Esta operación se puede representar mediante pseudocódigo y Lenguaje C/C++ como se indica a continuación:</li>
                </ol>
                <h4><b>Ejercicio 2.2: </b>Escribir un programa que permita probar la asignación simple, donde se asigna un valor a una variable, luego ese mismo valor se asigna a otra utilizando la misma variable y finalmente se imprime los valores de las dos variables. </h4>
                
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> 
                    <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                    <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR> <td>1</td>  <td>entero : a</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      a;</td>
                  </TR>
                  <TR>
                    <td>2</td>
                    <td>entero : b</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> b;</font>
                    </td>
                  </TR>
                  <TR><td>3</td> <td>a &#8592; 7 </td> <td>a=7;</td> </TR>
                  <TR><td>4</td><td>b &#8592; a</td><td>b=a;</td></TR>
                  <TR><td>5</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>6</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  <TR><td>7</td><td>Imprimir mensaje: "Valor de 'b': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                    <font color="red">"Valor de 'b': "</font>;</td></TR>
                  <TR><td>8</td><td>Imprimir b</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> b</td></TR>
                </TABLE> <br>
                <h5><b>Programa 2.2. </b> Código del programa</h5>
                <pre><code [highlight]="prefTab2[0].programa2_2"  [lineNumbers]="true"></code></pre><br>
               <p>La Ejecución 2.2, correspondiente a la salida del programa, muestra que al ingresar el valor igual a 7 en la variable ‘a’, se asigna este mismo valor a la variable ‘b’ y se imprimen sus valores.</p>
               <h4><b>Ejecución 2.2. </b>Salida del programa</h4>
               <img src="./assets/images/Capitulos/II/media/Ejecución 2.2.png" style="display:block; margin:auto; "><br>
                
               <ol type="a" start="2">
                  <li><b>Asignación Contador: </b>Esta asignación consiste en usarla como un verificador del número de veces que se realiza un proceso. Esta operación se puede representar mediante pseudocódigo y Lenguaje C/C++ como se indica a continuación:</li>
                </ol>
                <h4><b>Ejercicio 2.3: </b>Escribir un programa que permita contar desde el uno hasta el cinco, utilizando un contador, donde inicialmente se le asigna el valor de cero a la variable que opera como contador, luego se utiliza este contador para contar hasta cinco y también se imprimen los valores del mismo.</h4>
                
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th><th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR> <td>1</td>  <td>entero : a</td><td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font> a;</td>
                  </TR>
                  <TR>
                    <td>2</td><td>a &#8592; 0</td><td>a=0;</td>
                  </TR>
                  <TR><td>3</td> <td>a &#8592; a+1 </td> <td>a=a+1;</td> </TR>
                  <TR><td>4</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>5</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  <TR><td>6</td> <td>a &#8592; a+1 </td> <td>a = a+1;</td> </TR>
                  <TR><td>7</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>8</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  <TR><td>9</td> <td>a &#8592; a+1 </td> <td>a = a+1;</td> </TR>
                  <TR><td>10</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>11</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  <TR><td>12</td> <td>a &#8592; a+1 </td> <td>a = a+1;</td> </TR>
                  <TR><td>13</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>14</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  <TR><td>15</td> <td>a &#8592; a+1 </td> <td>a = a+1;</td> </TR>
                  <TR><td>16</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>17</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  
                </TABLE> <br>
                <h5><b>Programa 2.3. </b> Código del programa</h5>
                <pre><code [highlight]="prefTab2[0].programa2_3"  [lineNumbers]="true"></code></pre><br>
                <p>La Ejecución 2.3, correspondiente a la salida del programa, muestra que el valor del contador ‘a’ varía entre uno y cinco.</p>
                <h4><b>Ejecución 2.3. </b>Salida del programa</h4>
                <img src="./assets/images/Capitulos/II/media/Ejecución 2.3.png" style="display:block; margin:auto; "><br>

                <ol type="a" start="3">
                  <li><b>Asignación Acumulador: </b>Esta asignación consiste en usarla como un sumador o un producto en un proceso. </li>
                  <ul>
                    <li>Un sumador generalmente se inicializa con el neutro aditivo que es el valor de cero y se aplica la siguiente fórmula: sum = sum + valor; donde el valor depende de lo que se quiere acumular.</li>
                    <li>Un producto generalmente se inicializa con el neutro multiplicativo que es el valor de uno y se aplica la siguiente fórmula: prod = prod * valor; donde el valor depende de lo que se quiere acumular.</li>
                  </ul>
                  Estas operaciones se pueden representar mediante pseudocódigo y Lenguaje C/C++ como se indican a continuación en los siguientes ejercicios:
                </ol>
                <h4><b>Ejercicio 2.4: </b>Escribir un programa que permita realizar la sumatoria de los cinco primeros dígitos, es decir, 1+2+3+4+5, utilizando cinco variables y un acumulador de sumas. A cada variable se le asigna uno de los dígitos y luego se le asigna al acumulador cada variable, para finalmente imprimir el valor del acumulador.</h4>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> 
                    <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                    <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR> <td>1</td>  <td>entero : n1</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n1;</td>
                  </TR>
                  <TR> <td>2</td>  <td>entero : n2</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n2;</td>
                  </TR>
                  <TR> <td>3</td>  <td>entero : n3</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n3;</td>
                  </TR>
                  <TR> <td>4</td>  <td>entero : n4</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n4;</td>
                  </TR>
                  <TR> <td>5</td>  <td>entero : n5</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n5;</td>
                  </TR>
                  <TR> <td>6</td>  <td>entero : sum</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      sum;</td>
                  </TR>
                  <TR><td>7</td> <td>n1 &#8592; 1 </td> <td>n1 = 1;</td> </TR>
                  <TR><td>8</td> <td>n2 &#8592; 2 </td> <td>n2 = 2;</td> </TR>
                  <TR><td>9</td> <td>n3 &#8592; 3 </td> <td>n3 = 3;</td> </TR>
                  <TR><td>10</td> <td>n4 &#8592; 4 </td> <td>n4 = 4;</td> </TR>
                  <TR><td>11</td> <td>n5 &#8592; 5 </td> <td>n5 = 5;</td> </TR>
                  <TR><td>12</td><td>sum &#8592; 0</td><td>sum = 0;</td></TR>
                  <TR><td>13</td><td>sum &#8592; sum + n1</td><td>sum = sum + n1;</td></TR>
                  <TR><td>14</td><td>sum &#8592; sum + n2</td><td>sum = sum + n2;</td></TR>
                  <TR><td>15</td><td>sum &#8592; sum + n3</td><td>sum = sum + n3;</td></TR>
                  <TR><td>16</td><td>sum &#8592; sum + n4</td><td>sum = sum + n4;</td></TR>
                  <TR><td>17</td><td>sum &#8592; sum + n5</td><td>sum = sum + n5;</td></TR>
                  <TR><td>18</td><td>Imprimir mensaje: "Valor del acumulador 'sum': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor del acumulador 'sum': "</font>; </td></TR>
                  <TR><td>19</td><td>Imprimir 'sum'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> sum;</td></TR>
                </TABLE> <br>

                <h5><b>Programa 2.4. </b> Código del programa</h5>
                <pre><code [highlight]="prefTab2[0].programa2_4"  [lineNumbers]="true"></code></pre><br>
                <p>La Ejecución 2.4, correspondiente a la salida del programa, muestra que la variable ‘sum’ tiene acumulado el valor de 15 que representa la sumatoria de los cinco primeros dígitos.</p>
                <h4><b>Ejecución 2.4. </b>Salida del programa</h4>
                <img src="./assets/images/Capitulos/II/media/Ejecución 2.4.png" style="display:block; margin:auto; "><br>

                <h4><b>Ejercicio 2.5: </b>Escribir un programa que permita realizar el producto de los cinco primeros dígitos, es decir, 1*2*3*4*5, utilizando cinco variables y un acumulador de productos. A cada variable se le asigna uno de los dígitos y luego se le asigna al acumulador cada variable, para finalmente imprimir el valor del acumulador.</h4>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> 
                    <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                    <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR> <td>1</td>  <td>entero : n1</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n1;</td>
                  </TR>
                  <TR> <td>2</td>  <td>entero : n2</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n2;</td>
                  </TR>
                  <TR> <td>3</td>  <td>entero : n3</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n3;</td>
                  </TR>
                  <TR> <td>4</td>  <td>entero : n4</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n4;</td>
                  </TR>
                  <TR> <td>5</td>  <td>entero : n5</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n5;</td>
                  </TR>
                  <TR> <td>6</td>  <td>entero : prod</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      prod;</td>
                  </TR>
                  <TR><td>7</td> <td>n1 &#8592; 1 </td> <td>n1 = 1;</td> </TR>
                  <TR><td>8</td> <td>n2 &#8592; 2 </td> <td>n2 = 2;</td> </TR>
                  <TR><td>9</td> <td>n3 &#8592; 3 </td> <td>n3 = 3;</td> </TR>
                  <TR><td>10</td> <td>n4 &#8592; 4 </td> <td>n4 = 4;</td> </TR>
                  <TR><td>11</td> <td>n5 &#8592; 5 </td> <td>n5 = 5;</td> </TR>
                  <TR><td>12</td><td>prod &#8592; 0</td><td>prod = 0;</td></TR>
                  <TR><td>13</td><td>prod &#8592; prod * n1</td><td>prod = prod * n1;</td></TR>
                  <TR><td>14</td><td>prod &#8592; prod * n2</td><td>prod = prod * n2;</td></TR>
                  <TR><td>15</td><td>prod &#8592; prod * n3</td><td>prod = prod * n3;</td></TR>
                  <TR><td>16</td><td>prod &#8592; prod * n4</td><td>prod = prod * n4;</td></TR>
                  <TR><td>17</td><td>prod &#8592; prod * n5</td><td>prod = prod * n5;</td></TR>
                  <TR><td>18</td><td>Imprimir mensaje: "Valor del acumulador 'prod': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor del acumulador 'prod': "</font>; </td></TR>
                  <TR><td>19</td><td>Imprimir 'prod'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> prod;</td></TR>
                </TABLE> <br>
                <h5><b>Programa 2.5. </b> Código del programa</h5>
                <pre><code [highlight]="prefTab2[0].programa2_5"  [lineNumbers]="true"></code></pre><br>
                <p>La Ejecución 2.5, correspondiente a la salida del programa, muestra que la variable ‘prod’ tiene acumulado el valor de 120 que representa el producto de los cinco primeros dígitos.</p>
                <h4><b>Ejecución 2.5. </b>Salida del programa</h4>
                <img src="./assets/images/Capitulos/II/media/Ejecución 2.5.png" style="display:block; margin:auto; "><br>

                <ol type="a" start="4">
                  <li><b>Asignación de Trabajo: </b>Esta asignación consiste en recibir el resultado de una operación o fórmula matemática que involucre muchas variables. Esta operación se puede representar mediante pseudocódigo y Lenguaje C/C++ como se indica a continuación:</li>
                </ol>
                <h4><b>Ejercicio 2.6: </b>Escribir un programa que permita probar la siguiente expresión matemática: d = (a * c) + (c / 2), para lo cual se deben utilizar cuatro variables, donde las variables ‘a’, ‘b’ y ‘c’ tienen los valores de 5, 2 y 7 respectivamente.</h4>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> 
                    <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                    <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR> <td>1</td>  <td>entero : a</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      a;</td>
                  </TR>
                  <TR> <td>2</td>  <td>entero : b</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      b;</td>
                  </TR>
                  <TR> <td>3</td>  <td>entero : c</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      c;</td>
                  </TR>
                  <TR> <td>4</td>  <td>entero : d</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      d;</td>
                  </TR>
                  <TR><td>5</td> <td>a &#8592; 5 </td> <td>a = 5;</td> </TR>
                  <TR><td>6</td> <td>b &#8592; 2 </td> <td>b = 2;</td> </TR>
                  <TR><td>7</td> <td>c &#8592; 7 </td> <td>c = 7;</td> </TR>
                  <TR><td>8</td> <td>d &#8592; (a*c) + (c/2) </td> <td>d = (a*c) + (c/2) ;</td> </TR>
                  <TR><td>9</td><td>Imprimir mensaje: "Valor de la expresión 'd': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de la expresión 'd': "</font>; </td></TR>
                  <TR><td>10</td><td>Imprimir 'd'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> d;</td></TR>
                </TABLE> <br>
                <h5><b>Programa 2.6. </b> Código del programa</h5>
                <pre><code [highlight]="prefTab2[0].programa2_6"  [lineNumbers]="true"></code></pre><br>
                <p>La Ejecución 2.6, correspondiente a la salida del programa, muestra que el valor de la expresión matemática evaluada es igual a 38.</p>
                <h4><b>Ejecución 2.6. </b>Salida del programa</h4>
                <img src="./assets/images/Capitulos/II/media/Ejecución 2.6.png" style="display:block; margin:auto; "><br>

              </ng-template>
            </mat-tab>
            <mat-tab  label="2.2.4. Casos de Estudio">
              <ng-template matTabContent>
                <br>
                <h1><b>Caso de Estudio 2.1: Encontrar el Perímetro y el Área de un Círculo.</b></h1>
                <h2><b>A) Problema</b></h2>
                <p>Escribir un programa para calcular e imprimir el perímetro y el área de un círculo. (Ver Figura 2.1.1)</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.1.1.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.1.1. </b>El círculo y sus fórmulas</h5>
                
                <h2><b>B) Análisis</b></h2>
                <p>Claramente, se puede ver que la entrada del problema es el radio del círculo. Hay dos salidas requeridas: el perímetro y el área del círculo. Partiendo de un conocimiento básico de geometría, se sabe que hay una relación entre el radio del círculo con el perímetro y con el área de la figura geométrica. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
                <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Constante del Problema</b></p>
                <p>PI=3.141596</p>
                <p><b>Entradas del Problema</b></p>
                <table>
                  <tr><td width="200">radio</td><td width="200">/* radio del círculo */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200">perímetro</td><td width="200">/* perímetro del círculo */</td></tr>
                  <tr><td>área</td><td>/* área del círculo */</td></tr>
                </table><br>
                <p><b>Fórmulas Relevantes</b></p>
                <table>
                  <tr><td width="60"><em>P= 2 &pi; r</em></td><td width="30"> (1) </td><td width="270">/* Fórmula del perímetro de un círculo */</td></tr>
                  <tr><td ><em>A=&pi; r <sup>2</sup></em></td><td> (2) </td><td>/* Fórmula del área de un círculo */</td></tr>
                  
                </table> <br>
                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.1.2 se muestra el Diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘radio’; b) Salidas: las variables ‘perimetro’ y ‘area’; c) Auxiliares: la constante PI.</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.1.2.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.1.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <br>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                <p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el radio del círculo.</li>
                  <li>Calcular el perímetro.</li>
                    <ol type="1" start="2">
                      <li>1. Asignar el producto de dos veces PI por el radio a la variable ‘perimetro’.</li>
                    </ol>
                  <li>Calcular el área.</li>
                  <ol type="1" start="3">
                    <li>1.	Asignar el producto de PI por el cuadrado del radio a la variable ‘area’.</li>
                  </ol>
                  <li>Imprimir el valor de la variable 'perímetro' y de la variable 'área'</li>
                </ol>
                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.1.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.1.1. </b>Programa que calcula el perímetro y el área del círculo.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_1_1"  [lineNumbers]="true"></code></pre>
                <br>
                <h2>E) Pruebas</h2>
                <p>La Tabla 2.1.2 muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora, donde como se puede ver en la siguiente salida del programa, se le pide al usuario que ingrese un valor para el radio que puede ser ‘5’ y el programa calcula los valores del perímetro y del área como son ‘31.41’ y ‘78.53’ respectivamente.</p>
                <h5><b>Tabla 2.1.2.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.1.2.png" style="display:block; margin:auto; "><br>
                
                <h1><b>Caso de Estudio 2.2: Encontrar el Perímetro y el Área de un Rectángulo.</b></h1>
                <h2><b>A) Problema</b></h2>
                <p>Escribir un programa para calcular e imprimir el perímetro y el área de un rectángulo. (Ver Figura 2.2.1)</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.2.1.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.2.1. </b>El rectángulo y sus fórmulas</h5>
                <h2><b>B) Análisis</b></h2>
                <p>Claramente, se puede ver que las entradas del problema son el ancho y el largo del rectángulo. Hay dos salidas requeridas: el perímetro y el área del rectángulo. Partiendo de un conocimiento básico de geometría, se sabe que hay una relación entre el ancho y el largo del rectángulo con el perímetro y con el área de la figura geométrica. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
                <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Entradas del Problema</b></p>
                <table>
                  <tr><td width="200">ancho</td><td width="200">/* ancho del rectángulo */</td></tr>
                  <tr><td width="200">largo</td><td width="200">/* largo del rectángulo */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200">perímetro</td><td width="200">/* perímetro del rectángulo  */</td></tr>
                  <tr><td width="200">área</td><td width="200">/* área del rectángulo */</td></tr>
                </table><br>
                <p><b>Fórmulas Relevantes</b></p>
                <table>
                  <tr><td width="70"><em>P= 2a + 2b</em></td><td width="30"> (1) </td><td width="280">/* Fórmula del perímetro de un rectángulo */</td></tr>
                  <tr><td ><em>A= ab <sup>2</sup></em></td><td> (2) </td><td>/* Fórmula del área de un rectángulo */</td></tr>
                </table> <br>
                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.2.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas y salidas del problema como son: a) Entradas: las variables ‘ancho’ y ‘largo’; b) Salidas: las variables ‘perimetro’ y ‘area’.</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.2.2.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.2.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                <p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el ancho del rectángulo.</li>
                  <li>Leer el largo del rectángulo.</li>
                  <li>Calcular el perímetro.</li>
                  <ol type="1"  start="3">
                    <li>1. Asignar el producto de dos veces el ancho por dos veces el largo a la variable ‘perimetro’.</li>
                  </ol>
                  <li>Calcular el área.</li>
                  <ol type="1" start="4">
                    <li>1. Asignar el producto del ancho por el largo a la variable ‘area’.</li>
                    
                  </ol>
                  <li>Imprimir el valor de la variable ‘perimetro’ y de la variable ‘area’.</li>
                </ol>

                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.2.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.2.1. </b>Programa que calcula el perímetro y el área del rectángulo.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_2_1"  [lineNumbers]="true"></code></pre>
                <br>
                <h2>E) Pruebas</h2>
                <p>La Tabla 2.2.2 muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <h5><b>Tabla 2.2.2. </b>Salida del programa.</h5>

                <img src="./assets/images/Capitulos/II/media/Tabla 2.2.2.png" style="display:block; margin:auto; "><br>
                
                <h1><b>Caso de Estudio 2.3: Encontrar la Generatriz, el Área y el Volumen de un Cono.</b> </h1>
                
                <h2><b>A) Problema</b></h2>
                <p>Escribir un programa para calcular e imprimir la generatriz, el área y el volumen de un cono. (Ver Figura 2.2.1)</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.3.1.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.2.1. </b>El Cono y sus fórmulas.</h5>
                <h5></h5>
                <h2><b>B) Análisis</b></h2>
                <p>Claramente, se puede ver que las entradas del problema son el radio y la altura del cono. Hay tres salidas requeridas: la generatriz, el área y el volumen del cilindro. Partiendo de un conocimiento básico de geometría, se sabe que hay una relación entre el radio y la altura del rectángulo con la generatriz, con el área y con el volumen de la figura geométrica. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
                <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Constante del Problema</b></p>
                <p>PI=3.141596</p>
                <p><b>Entradas del Problema</b></p>
                <table>
                  <tr><td width="200">r</td><td width="200">/* radio del Cono */</td></tr>
                  <tr><td width="200">h</td><td width="200">/* altura del cono */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200">perímetro</td><td width="200">/* generatriz del cono  */</td></tr>
                  <tr><td width="200">área</td><td width="200">/* área del cono*/</td></tr>
                  <tr><td>volumen</td><td>/* volumen del cono */</td></tr>
                </table><br>

                <p><b>Fórmulas Relevantes</b></p>
                <table>
                  <tr><td width="120"><em>g= &#8730;(r<sup>2</sup> + h<sup>2</sup> ) </em></td><td width="30"> (1) </td><td width="280">/* Fórmula de la generatriz de un cono */</td></tr>
                  <tr><td ><em>A= &pi;∙r∙g + &pi;∙r<sup>2</sup></em></td><td> (2) </td><td>/* Fórmula del área de un cono */</td></tr>
                  <tr><td><em>V= <sup>1</sup>/<sub>3</sub> &pi;∙r<sup>2</sup>∙h</em></td><td>(3)</td> <td>/* Fórmula del volumen de un cono */</td></tr>
                </table> <br>

                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.3.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘r’ (radio) y la variable ‘h’ (altura); b) Salidas: las variables ‘g’ (generatriz), ‘area’ y ‘volumen’; c) Auxiliares: la constante PI.</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.3.2.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.3.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h3><b>B.3) Diagrama de Proceso</b></h3>
                <p>En la Figura 2.3.2 se muestra el diagrama de procesos del problema donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘r’ (radio) y la variable ‘h’ (altura); b) Salidas: las variables ‘g’ (generatriz), ‘area’ y ‘volumen’; c) Auxiliares: la constante PI.</p>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                <p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el radio del cono, utilizando la variable ‘r’.</li>
                  <li>Leer la altura del cono, utilizando la variable ‘h’.</li>
                  <li>Calcular la generatriz del cono.</li>
                  <ol type="1" start="3">
                    <li>1. Asignar la raíz cuadrada de la suma del cuadrado del radio más el cuadrado de la altura (‘h’), a la variable ‘g’ (generatriz).</li>
                  </ol>
                  <li>Calcular el área.</li>
                  <ol type="1" start="4">
                    <li>1. Asignar la suma entre el producto de PI por el radio y por la altura más el producto de PI por el cuadrado del radio, a la variable ‘area’.</li>
                    
                  </ol>
                  <li>Calcular el volumen.</li>
                  <ol type="1" start="5">
                    <li>1. Asignar el producto de un tercio por PI por el cuadrado del radio y por la altura, a la variable ‘volumen’.</li>
                  </ol>
                  <li>Imprimir el valor de la variable ‘g’ (generatriz), de la variable ‘area’ y de la variable ‘volumen’.</li>
                </ol>


                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.3.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.3.1. </b>Programa que calcula la generatriz, el área y el volumen del cono.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_3_1"  [lineNumbers]="true"></code></pre> <br>
                <h2>E) Pruebas</h2>
                <p>La Tabla 2.3.2 muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <h5><b>Tabla 2.3.2.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.3.2.png" style="display:block; margin:auto; "><br>
                
                <h1><b>Caso de Estudio 2.4: Encontrar la distancia, tiempo de vuelo y la altura alcanzada por un proyectil.</b> </h1>
                <h2><b>A) Problema</b></h2>
                <p>Escribir un programa para calcular e imprimir la distancia ‘d’, el tiempo de vuelo ‘t’ y la altura ‘h’ alcanzada por un proyectil que es disparado con un ángulo θ (‘theta’) en grados con respecto a la horizontal y a una velocidad inicial ‘v’ en m/seg. La trayectoria parabólica del proyectil se muestra en la Figura 2.4.1 y cuyas fórmulas son las siguientes:</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.4.1.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.4.1. </b>Tiro Parabólico de un Proyectil.</h5>
                <h5></h5>
                <h2><b>B) Análisis</b></h2>
                <p>Claramente, se puede ver que las entradas del problema son la velocidad inicial de lanzamiento del proyectil y el ángulo de lanzamiento theta en grados. Hay tres salidas requeridas: el tiempo de vuelo, la distancia y la altura alcanzada por un proyectil. Partiendo de un conocimiento básico de Física, se sabe que hay una relación entre la velocidad y el ángulo de lanzamiento con la distancia, el tiempo de vuelo y la altura. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
                <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Constante del Problema</b></p>
                <p>PI= 3.141596</p>
                <p>g= 9.8</p>
                <p><b>Entradas del Problema</b></p>
                <table>
                  <tr><td width="200">v</td><td width="200">/* velocidad de lanzamiento  */</td></tr>
                  <tr><td width="200">theta</td><td width="200">/* ángulo de lanzamiento  */</td></tr>
                </table>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200">d</td><td width="200">/* distancia alcanzada por el proyectil */</td></tr>
                  <tr><td width="200">t</td><td width="200">/* tiempo de vuelo */</td></tr>
                  <tr><td>h</td> <td>/* altura alcanzada por el proyectil */</td></tr>
                </table>

                <p><b>Fórmulas Relevantes</b></p>
                <table>
                  <tr><td width="100"><em>d=(v<sup>2</sup>∙sen(2θ))/g</em></td><td width="30"> (1) </td><td width="280">/* Fórmula de la distancia alcanzada por el proyectil */</td></tr>
                  <tr><td ><em>t=(v∙sen(2θ))/g</em></td><td> (2) </td><td>/* Fórmula del tiempo de vuelo del proyectil */</td></tr>
                  <tr><td><em>h=(v<sup>2</sup>∙sen<sup>2</sup>(θ))/g</em></td><td>(3)</td><td>/* Fórmula de la altura alcanzada por el proyectil */</td></tr>
                </table><br>

                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.4.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘v’ (velocidad) y la variable ‘theta’ (ángulo); b) Salidas: las variables ‘d’ (distancia), ‘t’ (tiempo) y ‘h’ (altura); c) Auxiliares: la constante ‘PI’ y la constante ‘g’ (gravedad).</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.4.2.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.4.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conocen las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                <p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el valor de la velocidad en m/seg, utilizando la variable ‘v’.</li>
                  <li>Leer el valor del ángulo theta en grados, utilizando la variable ‘theta’.</li>
                  <li>Convertir el ángulo theta de grados a radianes.</li>
                  <ol type="1" start="3">
                    <li>1. Asignar a la variable theta el producto del ángulo theta por la constante PI y dividirlo para el valor de 180 grados.</li>
                  </ol>
                  <li>Calcular la distancia alcanzada por el proyectil.</li>
                  <ol type="1" start="4">
                    <li>1.	Asignar a la variable ‘d’ (distancia) los valores que contempla la fórmula de la distancia (1), según la Física Clásica</li>
                  </ol>
                  <li>Calcular el tiempo de vuelo del proyectil</li>
                  <ol type="1" start="5">
                    <li>1.	Asignar a la variable ‘t’ (tiempo) los valores que contempla la fórmula del tiempo de vuelo (2), según la Física Clásica.</li>
                  </ol>
                  <li>Calcular la altura alcanzada por el proyectil.</li>
                  <ol type="1" start="6">
                    <li>1.	Asignar a la variable ‘h’ (altura) los valores que contempla la fórmula de la altura (3), según la Física Clásica.</li>
                  </ol>
                  <li>Imprimir los valores de la variable ‘d’ (distancia), de la variable ‘t’ (tiempo) y de la variable ‘h’ (altura).</li>
                </ol>

                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.4.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.4.1. </b>Programa que calcula la distancia, tiempo de vuelo y la altura alcanzada por un proyectil.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_4_1"  [lineNumbers]="true"></code></pre> <br>
                <h2>E) Pruebas</h2>
                <p>En la Tabla 2.4.2 se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <h5><b>Tabla 2.4.2. </b>Salida del programa.</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.4.2.png" style="display:block; margin:auto; "><br>
                
              </ng-template>
            </mat-tab>
            
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Estructuras de Control de Selección">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="2.3.1. La sentencia if">
              <br>
              <h2>La Sentencia if</h2>
              <br>
              <p>La sentencia if permite escoger entre ejecutar una instrucción o no ejecutarla. El formato de esta sentencia tiene la siguiente sintaxis:</p>
              <h4><strong>Sintaxis 1:  </strong>  </h4>
              <pre><code [highlight]="prefTab[0].sintaxis1"  [lineNumbers]="true"></code></pre>
              <p>expresión: Expresión lógica que determina si la sentencia o acción se ha de ejecutar. </p>
              <p>sentencia:  La sentencia o acción se ejecuta si la expresión lógica es verdadera. </p>
              <p><strong>Nota: </strong> En esta sintaxis no es necesario utilizar llaves ya que se tiene una sola sentencia o instrucción. </p>
              <h4><strong>Sintaxis 2:  </strong>  </h4>
              <pre><code [highlight]="prefTab[0].sintaxis2"  [lineNumbers]="true"></code></pre>
              <p>expresión: Expresión lógica que determina si la sentencia o acción se ha de ejecutar. </p>
              <p>sentencia: Las acciones o sentencias se ejecutan si la expresión lógica es verdadera. </p>
              <p><strong>Nota: </strong> En esta sintaxis es necesario utilizar llaves ya que se tienen varias sentencias o instrucciones. </p>
              <h4><strong>Ejercicio 2.7: </strong>Escribir un programa que permita ver si un número es par, para lo cual se debe utilizar el operador de módulo, que permite obtener el resto de una división entera.</h4><br>
              <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
                <TR>
                  <TH>N°</TH>
                  <TH>Algoritmo en Pseudocódigo</TH>
                  <TH>Algoritmo en Lenguaje C/C++</TH>
                </TR>
                <tbody *ngFor="let item of prefTab[0].tablaDatos1">
                <TR style="text-align: left">
                  <TD>
                    <ul *ngFor="let i of item.Numero" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Pseudo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Codigo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                </TR>
                </tbody>
              </TABLE><br>
              <h5><strong>Programa 2.7: </strong>Código del programa .</h5><br>
              <pre><code [highlight]="prefTab[0].programa1"  [lineNumbers]="true"></code></pre><br>
              <p>La Ejecución 2.7, correspondiente a la salida del programa, muestra que el número 6 es par.</p>
              <h5><strong>Ejecución 2.7: </strong>Salida del programa .</h5>
              <img src="./assets/images/Capitulos/II/media/a1.png" style="display:block; margin:auto; "><br>
              <h4><strong>Ejercicio 2.8: </strong> Escribir un programa que permita ver si una nota entre 0 y 10 ingresada por teclado es mayor o igual que siete y se imprima un mensaje de aprobado.</h4>
              <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
                <TR>
                  <TH>N°</TH>
                  <TH>Algoritmo en Pseudocódigo</TH>
                  <TH>Algoritmo en Lenguaje C/C++</TH>
                </TR>
                <tbody *ngFor="let item of prefTab[0].tablaDatos2">
                <TR style="text-align: left">
                  <TD>
                    <ul *ngFor="let i of item.Numero" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Pseudo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Codigo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                </TR>
                </tbody>
              </TABLE><br>
              <h5><strong>Programa 2.8: </strong>Código del programa .</h5><br>
              <pre><code [highlight]="prefTab[0].programa2"  [lineNumbers]="true"></code></pre><br>
              <p>La Ejecución 2.8, correspondiente a la salida del programa, muestra que el valor de la nota igual a 8 corresponde al mensaje de Aprobado.</p>
              <h5><strong>Ejecución 2.8: </strong>Salida del programa .</h5>
              <img src="./assets/images/Capitulos/II/media/a2.png" style="display:block; margin:auto; "><br>
              <h3><strong>Caso de Estudio 2.5: Divisibilidad entre dos Números. </strong></h3>
              <h4><strong>A)   Problema </strong></h4>
              <p>Escribir un programa que permita ver si un número es divisible para otro.</p>
              <h4><strong>B)   Análisis </strong></h4>
              <p>Claramente, se puede ver que las entradas del problema son los dos números que se ingresan para analizar la divisibilidad entre ellos. Hay una variable auxiliar que se va a utilizar para calcular el módulo de la división entre los dos números ingresados, de tal manera que si el valor del módulo es cero los dos números son divisibles entre sí. La única salida requerida es un mensaje de impresión que indica si el primer número es divisible para el segundo número.</p>
              <h4><strong>B.1)   Requerimiento de los Datos </strong></h4>
              <h4><strong>Entradas del Problema </strong></h4>
              <p>num1	&nbsp; &nbsp;/* primer número */ <br> num2	&nbsp; &nbsp;/* segundo número */ </p>
              <h4><strong>Auxiliares del Problema </strong></h4>
              <p>num3	&nbsp; &nbsp;/* módulo de la división */ </p>
              <h4><strong>Salidas del Problema </strong></h4>
              <p>mensaje	&nbsp; &nbsp;/* mensaje que indica que el primer número es divisible para el segundo número */ </p>
              <h4><strong>Formulas Relevantes </strong></h4>
              <p>n3=n1 MOD n2	&nbsp; &nbsp;(1)	/* Fórmula del módulo de una división entre dos números */ </p>
              <h4><strong>B.2)   Diagrama de Entrada-Salida </strong></h4>
              <p>En la Figura 2.5.1 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘num1’ y la variable ‘num2’; b) Salidas: Un mensaje de información que indica que el primer número es divisible para el segundo número; c) Auxiliares: la variable ‘num3’;</p>
              <img src="./assets/images/Capitulos/II/media/a3.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.5.1. </strong>Diagrama de Entrada-Salida del Programa.</h5>
              <h4><strong>C)   Diseño </strong></h4>
              <p>Una vez que se conoce las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
              <h4><strong>Algoritmo </strong></h4>
              <p>1.	Leer el primer número.</p>
              <p>2.	Leer el segundo número.</p>
              <p>3.	Leer el lado 3 del triángulo.</p>
              <p>4.	Calcular el módulo de la división entre los dos números ingresados, utilizando la ecuación (1), donde se asigna en la variable ‘num3’ el módulo de la división entre ‘num1’ y ‘num2’.</p>
              <p>5.	Si el valor de la variable ‘num3’ es igual a cero.</p>
              <p> &nbsp; &nbsp; 5.1.	Imprimir el mensaje que el número 1 es divisible para el número 2.</p>
              <h4><strong>D)   Implementación </strong></h4>
              <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.5.1 se muestra el código del programa en C/C++.</p>
              <h5><strong>Tabla 2.5.1. </strong>Programa que permita ver si un número es divisible para otro.</h5>
              <pre><code [highlight]="prefTab[0].programa3"  [lineNumbers]="true"></code></pre><br>
              <h4><strong>E) Pruebas </strong></h4>
              <p>La Tabla 2.5.2 muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con un análisis manual de datos aplicando conceptos de divisibilidad.</p>
              <h5><strong>Tabla 2.5.2. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a4.png" style="display:block; margin:auto; "><br>

            </mat-tab>
            <mat-tab  label="2.3.2. La sentencia if-else">
              <h2>La sentencia if-else</h2>
              <p>La sentencia if-else permite escoger entre dos instrucciones o acciones diferentes, es decir, se elige una sentencia y la otra no se la toma en cuenta. El formato de esta sentencia tiene la siguiente sintaxis:</p>
              <h4><strong>Sintaxis 1:</strong></h4>
              <pre><code [highlight]="prefTab[0].sintaxis3"  [lineNumbers]="true"></code></pre><br>
              <p>expresión &nbsp; &nbsp; Expresión lógica que determina si la sentencia o acción se ha de ejecutar.</p>
              <p>sentencia1 &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresión lógica es verdadera.</p>
              <p>sentencia2 &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresión lógica es falsa.</p>
              <p><strong>Nota:</strong>En esta sintaxis no es necesario utilizar llaves ya que se tiene una sola sentencia o instrucción, tanto en el ‘if’ como en el ‘else’.</p>
              <h4><strong>Sintaxis 2:</strong></h4>
              <pre><code [highlight]="prefTab[0].sintaxis4"  [lineNumbers]="true"></code></pre><br>
              <p>expresión &nbsp; &nbsp; Expresión lógica que determina si la sentencia o acción se ha de ejecutar.</p>
              <p>sentencia1 &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresión lógica es verdadera.</p>
              <p>sentencia2 &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresión lógica es falsa.</p>
              <p><strong>Nota:</strong>En esta sintaxis es necesario utilizar llaves ya que se tienen varias sentencias o instrucciones, tanto en el ‘if’ como en el ‘else’.</p>
              <p>Considerando los operadores relacionales explicados en la sección 1.7, en la Tabla 2.1, se presenta el operador relacional contrario correspondiente a la sentencia if-else. Cabe indicar que el operador relacional del else se evalúa automáticamente y no es necesario colocar la expresión contraria, pero si es necesario entender cómo trabaja esta sentencia de decisión, para evitar confusiones y posibles errores de programación.</p>
              <h5><strong>Tabla 2.1. </strong>Operador relacional contrario de la sentencia if-else.</h5>
              <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
                <TR>
                  <TH>if</TH>
                  <TH>else</TH>
                </TR>
                <tbody *ngFor="let item of prefTab[0].tablaDatos3">
                <TR style="text-align: left">
                  <TD>
                    <ul *ngFor="let i of item.if" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.else" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                </TR>
                </tbody>
              </TABLE><br>
              <h4><strong>Ejercicio 2.9: </strong>Escribir un programa que permita ver si un número es par o impar, para lo cual se debe utilizar el operador de módulo, que permite obtener el resto de una división entera.</h4>
              <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
                <TR>
                  <TH>N°</TH>
                  <TH>Algoritmo en Pseudocódigo</TH>
                  <TH>Algoritmo en Lenguaje C/C++</TH>
                </TR>
                <tbody *ngFor="let item of prefTab[0].tablaDatos4">
                <TR style="text-align: left">
                  <TD>
                    <ul *ngFor="let i of item.Numero" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Pseudo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Codigo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                </TR>
                </tbody>
              </TABLE><br>
              <h5><strong>Programa 2.9:</strong> Código del programa.</h5>
              <pre><code [highlight]="prefTab[0].programa4"  [lineNumbers]="true"></code></pre><br>
              <p>La Ejecución 2.9.2, correspondiente a la salida del programa, muestra que el número 8 es par y la Ejecución 2.9.2, muestra que el número 7 es impar.</p>
              <h5><strong>Ejecución 2.9.1.:</strong> Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a5.png" style="display:block; margin:auto; "><br>
              <h5><strong>Ejecución 2.9.2.:</strong> Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a6.png" style="display:block; margin:auto; "><br>
              <h4><strong>Ejercicio 2.10:</strong> Escribir un programa que permita calcular el mayor de dos números leídos desde el teclado y visualizarlo en pantalla.</h4>
              <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
                <TR>
                  <TH>N°</TH>
                  <TH>Algoritmo en Pseudocódigo</TH>
                  <TH>Algoritmo en Lenguaje C/C++</TH>
                </TR>
                <tbody *ngFor="let item of prefTab[0].tablaDatos5">
                <TR style="text-align: left">
                  <TD>
                    <ul *ngFor="let i of item.Numero" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Pseudo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Codigo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                </TR>
                </tbody>
              </TABLE><br>
              <h5><strong>Programa 2.10:</strong> Código del programa.</h5>
              <pre><code [highlight]="prefTab[0].programa5"  [lineNumbers]="true"></code></pre><br>
              <p>En la salida de la Ejecución 2.10.1 se puede ver que al ingresar primero el número 84 y luego el número 23, el programa presenta al número 84 como el mayor entre los dos números. De manera similar, en la salida de la Ejecución 2.10.2 se puede ver que al ingresar primero el número 23 y luego el número 84, el programa presenta nuevamente al número 84 como el mayor entre los dos números, por lo que el algoritmo del programa logra su propósito que es encontrar el número mayor entre dos números.</p>
              <h5><strong>Ejecución 2.10.1.:</strong> Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a7.png" style="display:block; margin:auto; "><br>
              <h5><strong>Ejecución 2.10.2.:</strong> Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a8.png" style="display:block; margin:auto; "><br>
              <h3><strong>Caso de Estudio 2.6: Evaluar una Función Definida por Partes. </strong></h3>
              <h4><strong>A)   Problema </strong></h4>
              <p>Dada la función definida por partes y=f(x), calcular el valor de ‘y’ para un valor dado de ‘x’ y visualizarlo en pantalla.</p>
              <img src="./assets/images/Capitulos/II/media/a9.png" style="display:block; margin:auto; "><br>
              <p>Los dos intervalos de la función se muestran en la Figura 2.6.1 que son: <br>  y=-x+3;  I_1:x < 3; <br> 
                𝑦=𝑥−3;  𝐼_2:𝑥≥3</p>
              <img src="./assets/images/Capitulos/II/media/a10.png" style="display:block; margin:auto; "><br>
              
              <h4><strong>B)   Análisis </strong></h4>
              <p>Claramente, se puede ver que la entrada del problema es el valor de ‘x’. Hay una salida requerida: el valor de f(x)=y. Partiendo de un conocimiento básico de Álgebra, se sabe que hay dos intervalos y dos funciones lineales sobre las cuales se va a evaluar en un punto a la función definida por partes. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
              <h4><strong>B.1)   Requerimiento de los Datos </strong></h4>
              <h4><strong>Entradas del Problema </strong></h4>
              <p>x	&nbsp; &nbsp;/* valor de ‘x’ de la función */ </p>
              <h5><strong>Figura 2.6.1. </strong>Intervalos de la función.</h5>
              <h4><strong>Salidas del Problema </strong></h4>
              <p>y	&nbsp; &nbsp;/* valor de ‘y’ de la función */ </p>
              <h4><strong>Formulas Relevantes </strong></h4>
              <p>y=-x+3; x < 3	&nbsp; &nbsp;(1)	/* Función lineal en el intervalo 1 */ <br> y=x-3;x ≥ 3 &nbsp; &nbsp; /* Función lineal en el intervalo 2 */</p>
              <h4><strong>B.2)   Diagrama de Entrada-Salida </strong></h4>
              <p>En la Figura 2.6.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas y salidas del problema como son: a) Entradas: la variable ‘x’ (variable independiente); b) Salidas: la variable ‘y’ (variable dependiente).</p>
              <img src="./assets/images/Capitulos/II/media/a11.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.6.2. </strong>Diagrama de Entrada-Salida del Programa.</h5>
              <h4><strong>C)   Diseño </strong></h4>
              <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
              <h4><strong>Algoritmo </strong></h4>
              <p>1.	Leer el valor de ‘x’.</p>
              <p>2. Si el valor de 'x' está dentro del intervalo I1: x<3.</p>
              <p> &nbsp; &nbsp; 2.1. 	Evaluar a la función f(x)=-x+3 en un punto 'x'.</p>
              <p>3.	Caso contrario, el valor de 'x' está dentro del intervalo I2: x≥3.</p>
              <p> &nbsp; &nbsp; 3.1. 	Evaluar a la función f(x)=x-3 en un punto 'x'.</p>
              <p>4.	Imprimir el valor de la variable ‘x’ y de la variable ‘y’.</p>
              
              
              <h4><strong>D)   Implementación </strong></h4>
              <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.6.1 se muestra el código del programa en C/C++.</p>
              <h5><strong>Tabla 2.6.1. </strong>Programa que evalúa una función definida por partes.</h5>
              <pre><code [highlight]="prefTab[0].programa6"  [lineNumbers]="true"></code></pre><br>
              <h4><strong>E) Pruebas </strong></h4>
              <p>La Tabla 2.6.2 y la Tabla 2.6.3 muestran dos ejemplos de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
              <p>En la salida de la Tabla 2.5.2 se puede ver que al ingresar el valor de ‘x’ igual a 2, se evalúa la función en el primer intervalo. De manera similar, en la salida Tabla 2.5.3 se puede ver que al ingresar el valor de ‘x’ igual a 7, se evalúa la función en el segundo intervalo, por lo que el algoritmo del programa logra su propósito que es evaluar una función definida por partes o a trozos.</p>
              <h5><strong>Tabla 2.6.2. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a12.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.6.3. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a13.png" style="display:block; margin:auto; "><br>
              <h3><strong>Caso de Estudio 2.7: Encontrar el Perímetro, el Semi-perímetro y el Área de un Triángulo. </strong></h3>
              <h4><strong>A)   Problema </strong></h4>
              <p>Escribir un programa para calcular e imprimir el perímetro, el semi-perímetro y el área de un triángulo. Además, validar la existencia de un triángulo. (Ver Figura 2.7.1)</p>
              <img src="./assets/images/Capitulos/II/media/a14.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.7.1. </strong>El Triángulo y sus fórmulas.</h5>
              
              <h4><strong>B)   Análisis </strong></h4>
              <p>Claramente, se puede ver que las entradas del problema son los tres lados del triángulo. Hay tres salidas requeridas: el perímetro, el semi-perímetro y el área del triángulo. Partiendo de un conocimiento básico de geometría, se sabe que hay una relación entre los tres lados del triángulo con el perímetro, con el semi-perímetro y con el área de la figura geométrica. Las fórmulas requeridas se incluyen en el requerimiento de los datos. En esta versión del programa del triángulo se considera la validación de la existencia de un triángulo cuyo Teorema expresa que un triángulo cualquiera existe si y sólo si la suma de cualquiera de sus dos lados es mayor que el tercer lado: (a+b>c)∧(a+c>b)∧(b+c>a).</p>
              <h4><strong>B.1)   Requerimiento de los Datos </strong></h4>
              <h4><strong>Entradas del Problema </strong></h4>
              <p>a	&nbsp; &nbsp;/* lado 1 del triángulo */ </p>
              <p>b	&nbsp; &nbsp;/* lado 2 del triángulo */ </p>
              <p>c	&nbsp; &nbsp;/* lado 3 del triángulo */ </p>
              
              <h4><strong>Salidas del Problema </strong></h4>
              <p>perimetro	&nbsp; &nbsp;/* perímetro del triángulo */ </p>
              <p>s	&nbsp; &nbsp;/* semi-perímetro del triángulo */ </p>
              <p>area	&nbsp; &nbsp;/* área del triángulo */ </p>
              <h4><strong>Formulas Relevantes </strong></h4>
              <img src="./assets/images/Capitulos/II/media/a15.png" style="display:block; margin:auto; "><br>
              <h4><strong>B.2)   Diagrama de Entrada-Salida </strong></h4>
              <p>En la Figura 2.7.1 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas y salidas del problema como son: a) Entradas: la variable ‘a’ (lado 1), la variable ‘b’ (lado 2), la variable ‘c’ (lado 3); b) Salidas: la variable ‘s’ (semiperímetro), la variable ‘perimetro’, la variable ‘area’. </p>
              <img src="./assets/images/Capitulos/II/media/a16.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.7.2. </strong>Diagrama de Entrada-Salida del Programa.</h5>
              <h4><strong>C)   Diseño </strong></h4>
              <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
              <h4><strong>Algoritmo </strong></h4>
              <p>1.	Leer el lado 1 del triángulo.</p>
              <p>2.	Leer el lado 2 del triángulo.</p>
              <p>3.	Leer el lado 3 del triángulo.</p>
              <p>4. Si la suma de cualquiera de los dos lados es mayor que el tercero, es decir, si se cumple la condición del teorema: (a+b>c)∧(a+c>b)∧(b+c>a).</p>
              <p> &nbsp; &nbsp; 4.1. 	Calcular el perímetro.</p>
              <p> &nbsp; &nbsp; &nbsp; 4.1.1. 	Asignar la suma de los tres lados del triángulo a la variable ‘perimetro’.</p>
              <p> &nbsp; &nbsp; 4.2. 	Calcular el perímetro.</p>
              <p> &nbsp; &nbsp; &nbsp; 4.2.1. 	Asignar la suma de los tres lados del triángulo a la variable ‘perimetro’.</p>
              <p> &nbsp; &nbsp; 4.3. 	Calcular el semi-perímetro.</p>
              <p> &nbsp; &nbsp; &nbsp; 4.3.1. 	Asignar la suma de los tres lados del triángulo a la variable ‘semiperimetro’.</p>
              <p> &nbsp; &nbsp; 4.4. 	Calcular el area.</p>
              <p> &nbsp; &nbsp; &nbsp; 4.4.1. 	4.4.1.	Asignar el valor de la raíz cuadrada del semi-perímetro multiplicado por la diferencia entre el semi-perímetro por cada uno de los lados del triángulo, a la variable ‘area’.</p>
              <p> &nbsp; &nbsp; 4.5. 	Imprimir el valor de la variable ‘perimetro’, de la variable ‘semiperimetro’ y de la variable ‘area’.</p>
              
              <p>5.	Caso contrario, se niega la condición del teorema de existencia de un triángulo, es decir: !(a+b>c)∧(a+c>b)∧(b+c>a).</p>
              <p> &nbsp; &nbsp; 5.1. 	5.1.	Imprimir el mensaje de error que el triángulo no existe.</p>
                      
              <h4><strong>D)   Implementación </strong></h4>
              <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.7.1 se muestra el código del programa en C/C++.</p>
              <h5><strong>Tabla 2.7.1. </strong>Programa que calcula el perímetro, el semi-perímetro y el área del triángulo.</h5>
              <pre><code [highlight]="prefTab[0].programa7"  [lineNumbers]="true"></code></pre><br>
              <h4><strong>E) Pruebas </strong></h4>
              <p>La Tabla 2.7.2, la Tabla 2.7.3 y la Tabla 2.7.4 muestran tres ejemplos de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
              <p>En la salida de la Tabla 2.7.2 se puede ver que, al ingresar los valores de 3, 4 y 5 en los tres lados obtenemos un triángulo rectángulo donde se puede calcular los valores del perímetro, semi-perímetro y del área de dicho triángulo. De manera similar, en la salida de la Tabla 2.7.3 se puede ver que, al ingresar los valores de 3, 3 y 3 en los tres lados obtenemos un triángulo equilátero donde se puede calcular los valores del perímetro, semi-perímetro y del área de dicho triángulo. Finalmente, en la salida de la Tabla 2.7.4 se puede ver que, al ingresar los valores de 1, 2 y 3 en los tres lados obtenemos un triángulo que no existe donde no se puede calcular los valores del perímetro, semi-perímetro y del área de dicho triángulo.</p>
              <h5><strong>Tabla 2.7.2. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a17.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.7.3. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a18.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.7.3. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a19.png" style="display:block; margin:auto; "><br>

              <h3><strong>Caso de Estudio 2.8: Encontrar la aceleración de dos objetos conectados mediante una cuerda. </strong></h3>
              <h4><strong>A)   Problema </strong></h4>
              <p>Escribir un programa para calcular e imprimir la magnitud de la aceleración (‘a’) de dos objetos conectados mediante una cuerda, la tensión (‘T’) en la cuerda y la normal (‘n’) de la masa m_2, donde una bola de masa m_1 y un bloque de masa m_2 se unen mediante una cuerda ligera que pasa sobre una polea sin fricción de masa despreciable, como se muestra en la Figura 2.8.1. El bloque se encuentra sobre un plano inclinado sin fricción de ángulo θ (‘theta’) en grados. A continuación, se presentan las ecuaciones que calculan los elementos solicitados.</p>
              <img src="./assets/images/Capitulos/II/media/a20.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.8.1. </strong>(a) Dos objetos conectados mediante una cuerda ligera sobre una polea sin friccion. (b) Diagrama de cuerpo libre para la bola. (c) Diagrama de cuerpo libre para el bloque (Serway, R., Jewett, J., 2005).</h5>
              
              <h4><strong>B)   Análisis </strong></h4>
              <p>Claramente, se puede ver que las entradas del problema son la masa m_1, la masa m_2 y el ángulo θ (‘theta’) en grados. Hay tres salidas requeridas: la aceleración, la tensión y la normal (‘n’) de la masa m_2. Partiendo de un conocimiento básico de Física, se sabe que hay una relación entre la masa m_1, la masa m_2 y el ángulo θ (‘theta’) del plano inclinado con la acelaración, la tensión y la normal. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
              <h4><strong>B.1)   Requerimiento de los Datos </strong></h4>
              <h4><strong>Constantes del Problema </strong></h4>
              <p>PI = 3.141596</p>
              <p>g = 9.80665</p>
              <h4><strong>Entradas del Problema </strong></h4>
              <p>m1	&nbsp; &nbsp;/* primera masa */ </p>
              <p>m2	&nbsp; &nbsp;/* segunda masa */ </p>
              <p>theta	&nbsp; &nbsp;/* ángulo del plano inclinado */ </p>
              
              <h4><strong>Salidas del Problema </strong></h4>
              <p>a	&nbsp; &nbsp;/* aceleración de dos objetos conectados mediante una cuerda */ </p>
              <p>T	&nbsp; &nbsp;/* tensión en la cuerda */ </p>
              <p>n	&nbsp; &nbsp;/* normal (‘n’) de la masa m_2 */ </p>
              <h4><strong>Formulas Relevantes </strong></h4>
              <img src="./assets/images/Capitulos/II/media/a21.png" style="display:block; margin:auto; "><br>
              <h4><strong>B.2)   Diagrama de Entrada-Salida </strong></h4>
              <p>En la Figura 2.8.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘m1’ (primera masa), la variable ‘m2’ y la variable ‘theta’ (ángulo del plano inclinado); b) Salidas: las variables ‘a’ (aceleración), ‘T’ (tensión) y ‘n’ (normal); c) Auxiliares: la constante ‘PI’ y la constante ‘g’ (gravedad). </p>
              <img src="./assets/images/Capitulos/II/media/a22.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.8.2. </strong>Diagrama de Entrada-Salida del Programa.</h5>
              <h4><strong>C)   Diseño </strong></h4>
              <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
              <h4><strong>Algoritmo </strong></h4>
              <p>1.	Imprimir el mensaje de información: “Aceleración de dos objetos conectados mediante una cuerda”</p>
              <p>2.	Leer el valor de la primera masa, utilizando la variable ‘m1’.</p>
              <p>3.	Leer el valor de la segunda masa, utilizando la variable ‘m2’.</p>
              <p>4.	Leer el valor del ángulo theta del plano inclinado en grados, utilizando la variable ‘theta’</p>
              <p>5. Convertir el ángulo theta de grados a radianes.</p>
              <p> &nbsp; &nbsp; 5.1. Asignar a la variable ‘theta’ el producto del ángulo theta por la constante PI y dividirlo para el valor de 180 grados.</p>
                          
              <p>6.	Si la suma entre las masas ‘m1’ y ‘m2’ es diferente de cero.</p>
              <p> &nbsp; &nbsp; 6.1.	Calcular la aceleración de dos objetos conectados mediante una cuerda.</p>
              <p> &nbsp; &nbsp; &nbsp; 6.1.1.	Asignar a la variable ‘a’ (aceleración) los valores que contempla la fórmula de la aceleración (1), según la Física Clásica.</p>
              <p> &nbsp; &nbsp; 6.2.	Calcular la tensión en la cuerda.</p>
              <p> &nbsp; &nbsp; &nbsp; 6.2.1.	Asignar a la variable ‘T’ (tensión) los valores que contempla la fórmula de la tensión (2), según la Física Clásica.</p>
              <p> &nbsp; &nbsp; 6.3.	Calcular el valor de la normal de la masa ‘m2’.</p>
              <p> &nbsp; &nbsp; &nbsp; 6.3.1.	Asignar a la variable ‘n’ (normal) los valores que contempla la fórmula de la normal (3), según la Física Clásica.</p>
              <p> &nbsp; &nbsp; 6.4.	Imprimir el valor de la variable ‘a’ (aceleración), de la variable ‘T’ (tensión) y de la variable ‘n’ (normal).</p>
              <p>7.	Caso contrario, la suma entre las masas m1 y m2 es igual a cero.</p>
              <p> &nbsp; &nbsp; 7.1.	Imprimir el mensaje de error: “Error en el ingreso de los valores de las masas”.</p>
                      
              <h4><strong>D)   Implementación </strong></h4>
              <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.8.1 se muestra el código del programa en C/C++.</p>
              <h5><strong>Tabla 2.8.1. </strong>Programa que calcula la aceleración de dos objetos conectados mediante una cuerda, la tensión y la normal.</h5>
              <pre><code [highlight]="prefTab[0].programa8"  [lineNumbers]="true"></code></pre><br>
              <h4><strong>E) Pruebas </strong></h4>
              <p>En la Tabla 2.8.2 se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora científica.</p>
              
              <h5><strong>Tabla 2.8.2. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a23.png" style="display:block; margin:auto; "><br>
              
            </mat-tab>

            <mat-tab  label="2.3.3. Sentencias if-else Anidadas">
              <h2><strong>Sentencias if-else Anidadas</strong></h2>
              <p>La sentencia if-else anidada es la una sentencia if-else, pero se utiliza para elegir una única acción o instrucción entre más de dos posibles alternativas, por lo que esto constituye una elección múltiple con varias alternativas. El formato de esta sentencia tiene la siguiente sintaxis:</p>
              <h4><strong>Sintaxis: </strong></h4>
              <pre><code [highlight]="prefTab[0].sintaxis5"  [lineNumbers]="true"></code></pre><br>
              <p>expresión &nbsp; &nbsp; &nbsp; Expresión lógica que determina si la sentencia o acción se ha de ejecutar.</p>
              <p>sentencia1 &nbsp; &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresión1 es verdadera.</p>
              <p>sentencia2 &nbsp; &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresión2 es verdadera.</p>
              <p>sentencia3 &nbsp; &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresión3 es verdadera.</p>
              <p>sentencian &nbsp; &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresiónn es verdadera.</p>
              <p>sentencian+1 &nbsp; &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresiónn es falsa.</p>
              <p><strong>Nota: </strong>En esta sintaxis no es necesario utilizar llaves ya que se tiene una sola sentencia o instrucción, tanto en los ‘if’ como en los ‘else’.</p>
              <h4><Strong>Ejercicio 2.11: </Strong>Escribir un programa que permita analizar si un número leído desde el teclado es mayor que cero, es menor que cero, o es igual a cero.</h4>
              <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
                <TR>
                  <TH>N°</TH>
                  <TH>Algoritmo en Pseudocódigo</TH>
                  <TH>Algoritmo en Lenguaje C/C++</TH>
                </TR>
                <tbody *ngFor="let item of prefTab[0].tablaDatos6">
                <TR style="text-align: left">
                  <TD>
                    <ul *ngFor="let i of item.Numero" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Pseudo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Codigo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                </TR>
                </tbody>
              </TABLE><br>
              <h5><strong>Programa 2.11: </strong>Código del programa.</h5>
              <pre><code [highlight]="prefTab[0].programa9"  [lineNumbers]="true"></code></pre><br>
              <p>En la salida de la Ejecución 2.11.1 se puede ver que al ingresar el número 7, el programa indica que este número es mayor que cero. De manera similar, en la salida de la Ejecución 2.10.2 se puede ver que al ingresar el número -4, el programa indica que este número es menor que cero. Finalmente, en la salida de la Ejecución 2.10.3 se puede ver que al ingresar el número 0, el programa indica que este número es efectivamente el cero, por lo que el algoritmo del programa logra su propósito que es analizar si un número leído desde el teclado es mayor que cero, es menor que cero, o es igual a cero.</p>
              <h5><strong>Ejecución 2.11.1: </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a24.png" style="display:block; margin:auto; "><br>
              <h5><strong>Ejecución 2.11.2: </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a25.png" style="display:block; margin:auto; "><br>
              <h5><strong>Ejecución 2.11.3: </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a26.png" style="display:block; margin:auto; "><br>
              <h4><Strong>Ejercicio 2.12: </Strong>Escribir un programa que permita analizar si un número leído desde el teclado es mayor que cero, es menor que cero, o es igual a cero.</h4>
              <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
                <TR>
                  <TH>N°</TH>
                  <TH>Algoritmo en Pseudocódigo</TH>
                  <TH>Algoritmo en Lenguaje C/C++</TH>
                </TR>
                <tbody *ngFor="let item of prefTab[0].tablaDatos7">
                <TR style="text-align: left">
                  <TD>
                    <ul *ngFor="let i of item.Numero" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Pseudo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Codigo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                </TR>
                </tbody>
              </TABLE><br>
              <h5><strong>Programa 2.12: </strong> Código del programa.</h5>
              <pre><code [highlight]="prefTab[0].programa10"  [lineNumbers]="true"></code></pre><br>
              <p>En la salida de la Ejecución 2.12.1 se puede ver que al ingresar el número 7, el programa indica que el número siguiente es el 8. De manera similar, en la salida de la Ejecución 2.12.2 se puede ver que al ingresar el número -4, el programa indica que el número siguiente es el -5. Finalmente, en la salida de la Ejecución 2.12.3 se puede ver que al ingresar el número 0, el programa indica que el número siguiente es el 1 y el número anterior es el -1, por lo que el algoritmo del programa logra su propósito.</p>
              <h5><strong>Ejecución 2.12.1: </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a27.png" style="display:block; margin:auto; "><br>
              <h5><strong>Ejecución 2.12.2: </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a28.png" style="display:block; margin:auto; "><br>
              <h5><strong>Ejecución 2.12.3: </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a29.png" style="display:block; margin:auto; "><br>

              <h3><strong>Caso de Estudio 2.9: Evaluar una Función Definida por Partes. </strong></h3>
              <h4><strong>A)   Problema </strong></h4>
              <p>Dada la función definida por partes y=f(x), calcular el valor de ‘y’ para un valor dado de ‘x’ y visualizarlo en pantalla.</p>
              <img src="./assets/images/Capitulos/II/media/a30.png" style="display:block; margin:auto; "><br>
              <p>Los tres intervalos de la función se muestran en la Figura 2.9.1 que son:</p>
              <p>y=-x;  I_1:x≤-1</p>
              <p>y=x^2;  I_2:-1 < x < 1, es decir, (-1 < x)∧(x < 1) </p>
              <p>y=x;  I_3:x≥1</p>
              <img src="./assets/images/Capitulos/II/media/a31.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.9.1. </strong>Intervalos de la función.</h5>
              
              <h4><strong>B)   Análisis </strong></h4>
              <p>Claramente, se puede ver que la entrada del problema es el valor de ‘x’. Hay una salida requerida: el valor de f(x)=y. Partiendo de un conocimiento básico de Álgebra, se sabe que hay dos intervalos y dos funciones lineales sobre las cuales se va a evaluar en un punto a la función definida por partes. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
              <h4><strong>B.1)   Requerimiento de los Datos </strong></h4>
              
              <h4><strong>Entradas del Problema </strong></h4>
              <p>x	&nbsp; &nbsp;/* valor de ‘x’ de la función */ </p>
                           
              <h4><strong>Salidas del Problema </strong></h4>
              <p>y	&nbsp; &nbsp;/* valor de ‘y’ de la función */ </p>
              
              <h4><strong>Formulas Relevantes </strong></h4>
              <img src="./assets/images/Capitulos/II/media/a32.png" style="display:block; margin:auto; "><br>
              <h4><strong>B.2)   Diagrama de Entrada-Salida </strong></h4>
              <p>En la Figura 2.9.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas y salidas del problema como son: a) Entradas: la variable ‘x’ (variable independiente); b) Salidas: la variable ‘y’ (variable dependiente). </p>
              <img src="./assets/images/Capitulos/II/media/a33.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.9.2. </strong>Diagrama de Entrada-Salida del Programa.</h5>
              <h4><strong>C)   Diseño </strong></h4>
              <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
              <h4><strong>Algoritmo </strong></h4>
              <p>1.	Leer el valor de ‘x’.</p>
              <p>2.	Si el valor de 'x' está dentro del intervalo I1: x≤-1.</p>
              <p> &nbsp; &nbsp; 2.1. 	Evaluar a la función f(x)=-x en un punto 'x'.</p>
              <p>3.		Caso contrario, si el valor de 'x' está dentro del intervalo I2: (-1< x)∧(x < 1).</p>
              <p> &nbsp; &nbsp; 3.1.	Evaluar a la función f(x)=x^2  en un punto 'x'.</p>
              <p>4.	Caso contrario, si el valor de 'x' está dentro del intervalo I3: x≥1.</p>
              <p> &nbsp; &nbsp; 4.1.	Evaluar a la función f(x)=x en un punto 'x'.</p>
              <p>5. Imprimir el valor de la variable ‘x’ y de la variable ‘y’.</p>
                                                           
              <h4><strong>D)   Implementación </strong></h4>
              <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.9.1 se muestra el código del programa en C/C++.</p>
              <h5><strong>Tabla 2.9.1. </strong>Programa que evalúa una función definida por partes.</h5>
              <pre><code [highlight]="prefTab[0].programa11"  [lineNumbers]="true"></code></pre><br>
              <h4><strong>E) Pruebas </strong></h4>
              <p>La Tabla 2.9.2, la Tabla 2.9.3 y la Tabla 2.9.4 muestran tres ejemplos de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
              <p>En la salida de la Tabla 2.9.2 se puede ver que, al ingresar el valor de -4 se evalúa la primera función cuyo valor resultante es 4. De manera similar, en la salida Tabla 2.9.3 se puede ver que, al ingresar el valor de 0.5 se evalúa la segunda función cuyo valor resultante es 0.25. Finalmente, en la salida Tabla 2.9.4 se puede ver que, al ingresar el valor de 4 se evalúa la tercera función cuyo valor resultante es 4.</p>
              
              <h5><strong>Tabla 2.9.2. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a34.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.9.3. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a35.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.9.4. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a36.png" style="display:block; margin:auto; "><br>

              <h3><strong>Caso de Estudio 2.10: Calcular la Media de Tres Notas. </strong></h3>
              <h4><strong>A)   Problema </strong></h4>
              <p>Tres notas de tipo flotante entre 0 y 100 representan las puntuaciones de un estudiante de un curso de Programación. Escribir un programa para encontrar la media de estas notas y visualizar un cuadro de calificaciones, de acuerdo con los valores de las notas y puntuaciones presentadas de la Tabla 2.10.1:</p>
              <h5><strong>Tabla 2.10.1. </strong>Tabla de notas y puntuaciones.</h5>
              <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
                <TR>
                  <TH>Nota</TH>
                  <TH>Puntuación</TH>
                </TR>
                <tbody *ngFor="let item of prefTab[0].tablaDatos8">
                <TR style="text-align: left">
                  <TD>
                    <ul *ngFor="let i of item.nota" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.puntos" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                </TR>
                </tbody>
              </TABLE><br>
              <p>Los cinco intervalos de la nota promedio se muestran en la Figura 2.10.1 que son:</p>
              <p>I_1:0 ≤ m < 60, es decir, (0 ≤ m)∧(m < 60) </p>
              <p>I_2:60 ≤ m < 70, es decir, (60 ≤ m)∧(m < 70)</p>
              <p>I_3:70 ≤ m < 80, es decir, (70 ≤ m)∧(m < 80)</p>
              <p>I_4:80 ≤ m < 90, es decir, (80 ≤ m)∧(m < 90)</p>
              <p>I_5:90 ≤ m ≤ 100, es decir, (90 ≤ m)∧(m ≤ 100)</p>
              <img src="./assets/images/Capitulos/II/media/a37.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.10.1. </strong>Intervalos de la nota promedio.</h5>
              
              <h4><strong>B)   Análisis </strong></h4>
              <p>Claramente, se puede ver que la entrada del problema es el valor del consumo de la luz ‘c’. Hay una salida requerida que es el valor del recibo. Partiendo de un conocimiento básico de Álgebra, se sabe que hay cuatro intervalos y cuatro diferentes valores para los recibos que dependen de los valores de las tarifas. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
              <h4><strong>B.1)   Requerimiento de los Datos </strong></h4>
              
              <h4><strong>Entradas del Problema </strong></h4>
              <p>nota1	&nbsp; &nbsp;/* Valor de la primera nota*/ </p>
              <p>nota2	&nbsp; &nbsp;/* Valor de la segunda nota*/ </p>
              <p>nota3	&nbsp; &nbsp;/* Valor de la tercera nota*/ </p>
                           
              <h4><strong>Salidas del Problema </strong></h4>
              <p>suma	&nbsp; &nbsp;/* Valor de la sumatoria de las 3 notas */ </p>
              <p>m	&nbsp; &nbsp;/* Valor de la media de las 3 notas */ </p>
              <p>puntuacion	&nbsp; &nbsp;/* Valor de la puntuación de las 3 notas */ </p>
              
              <h4><strong>Formulas Relevantes </strong></h4>
              <img src="./assets/images/Capitulos/II/media/a38.png" style="display:block; margin:auto; "><br>
              <h4><strong>B.2)   Diagrama de Entrada-Salida </strong></h4>
              <p>En la Figura 2.10.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas y salidas del problema como son: a) Entradas: la variable ‘nota1’, la variable ‘nota2’, la variable ‘nota2’; b) Salidas: la variable ‘suma’, la variable ‘m’ (media), la variable ‘puntuacion’. </p>
              <img src="./assets/images/Capitulos/II/media/a39.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.10.2. </strong>Diagrama de Entrada-Salida del Programa.</h5>
              <h4><strong>C)   Diseño </strong></h4>
              <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
              <h4><strong>Algoritmo </strong></h4>
              <p>1.	Leer el valor de la primera nota ‘nota1’.</p>
              <p>2.	Leer el valor de la segunda nota ‘nota2’.</p>
              <p>3.	Leer el valor de la tercera nota ‘nota3’.</p>
              <p>4.	Calcular la sumatoria de las tres notas.</p>
              <p> &nbsp; &nbsp; 4.1.	Asignar la suma de las tres notas a la variable ‘suma’.</p>
              <p>5. Calcular la media de las tres notas.</p>
              <p> &nbsp; &nbsp; 5.1.	Asignar la división entre la sumatoria y el valor de tres a la variable ‘m’.</p>
              <p>6.	Si el valor de la media 'm' está dentro del intervalo I1: (0≤m)∧(m<60).</p>
              <p> &nbsp; &nbsp; 6.1.	Asignar a la variable ‘puntuacion’ el valor de ‘E’.</p>
              <p>7.	Caso contrario, si el valor de la media 'm' está dentro del intervalo I2: (60≤m)∧(m<70).</p>
              <p> &nbsp; &nbsp; 7.1.	Asignar a la variable ‘puntuacion’ el valor de ‘D’.</p>
              <p>8.	Caso contrario, si el valor de la media 'm' está dentro del intervalo I3: (70≤m)∧(m<80).</p>
              <p> &nbsp; &nbsp; 8.1.	Asignar a la variable ‘puntuacion’ el valor de ‘C’.</p>
              <p>9.	Caso contrario, si el valor de la media 'm' está dentro del intervalo I4: (80≤m)∧(m<90).</p>
              <p> &nbsp; &nbsp; 9.1.	Asignar a la variable ‘puntuacion’ el valor de ‘B’.</p>
              <p>10.	Caso contrario, si el valor de la media 'm' está dentro del intervalo I5: (90≤m)∧(m≤100).</p>
              <p> &nbsp; &nbsp; 10.1.	Asignar a la variable ‘puntuacion’ el valor de ‘A’.</p>
              <p>11.	Imprimir un cuadro de calificaciones resumen.</p>
              <p> &nbsp; &nbsp; 11.1.	Imprimir el valor de la primera nota.</p>
              <p> &nbsp; &nbsp; 11.2.	Imprimir el valor de la segunda nota.</p>
              <p> &nbsp; &nbsp; 11.3.	Imprimir el valor de la tercera nota.</p>
              <p> &nbsp; &nbsp; 11.4.	Imprimir el valor de la sumatoria de las tres notas.</p>
              <p> &nbsp; &nbsp; 11.5.	Imprimir el valor de la media de las tres notas.</p>
              <p> &nbsp; &nbsp; 11.6.	Imprimir el valor de la puntuación.</p>
                                                           
              <h4><strong>D)   Implementación </strong></h4>
              <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.10.2 se muestra el código del programa en C/C++.</p>
              <h5><strong>Tabla 2.10.2. </strong>Programa que calcula el consumo eléctrico.</h5>
              <pre><code [highlight]="prefTab[0].programa12"  [lineNumbers]="true"></code></pre><br>
              <h4><strong>E) Pruebas </strong></h4>
              <p>La Tabla 2.10.3 muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora. En la salida de la Tabla 2.10.3 se puede ver que, al ingresar los valores de las tres notas 77, 84, 91, se obtiene el valor de la sumatoria que es 252, el valor de la media que es 84 y la puntuación que corresponde al valor de ‘B’.</p>
                            
              <h5><strong>Tabla 2.10.3. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a40.png" style="display:block; margin:auto; "><br>
              
            </mat-tab>

            <mat-tab  label="2.3.4. Secuencia de Sentencias if">
              <h2><strong>Secuencia de Sentencias if</strong></h2>
              <p>Solo en ciertos casos se puede utilizar una secuencia de sentencias if, lo cual no es tan legible ni eficiente y se podría reemplazar por sentencias if-else anidadas que resulta mucho más eficiente ya que se ejecutan más rápidamente (ver Sección 2.2.2.3). El formato de esta sentencia tiene la siguiente sintaxis:</p>
              <h4><strong>Sintaxis: </strong></h4>
              <pre><code [highlight]="prefTab[0].sintaxis6"  [lineNumbers]="true"></code></pre><br>
              <p>expresión &nbsp; &nbsp; &nbsp; Expresión lógica que determina si la sentencia o acción se ha de ejecutar.</p>
              <p>sentencia1 &nbsp; &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresión1 es verdadera.</p>
              <p>sentencia2 &nbsp; &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresión2 es verdadera.</p>
              <p>sentencia3 &nbsp; &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresión3 es verdadera.</p>
              <p>sentencian &nbsp; &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresiónn es verdadera.</p>
              <p><strong>Nota: </strong>En esta sintaxis no es necesario utilizar llaves ya que se tiene una sola sentencia o instrucción, en todos los ‘if’.</p>
              <h4><strong>Ejercicio 2.13: </strong>Escribir un programa que permita analizar si un número leído desde el teclado es mayor que cero, es menor que cero, o es igual a cero.</h4>
              <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
                <TR>
                  <TH>N°</TH>
                  <TH>Algoritmo en Pseudocódigo</TH>
                  <TH>Algoritmo en Lenguaje C/C++</TH>
                </TR>
                <tbody *ngFor="let item of prefTab[0].tablaDatos9">
                <TR style="text-align: left">
                  <TD>
                    <ul *ngFor="let i of item.Numero" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Pseudo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Codigo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                </TR>
                </tbody>
              </TABLE><br>
              <h5><strong>Programa 2.13: </strong>Código del programa.</h5>
              <pre><code [highlight]="prefTab[0].programa13"  [lineNumbers]="true"></code></pre><br>
              <p>En la salida de la Ejecución 2.13.1 se puede ver que al ingresar el número 7, el programa indica que este número es mayor que cero. De manera similar, en la salida de la Ejecución 2.13.2 se puede ver que al ingresar el número -4, el programa indica que este número es menor que cero. Finalmente, en la salida de la Ejecución 2.13.3 se puede ver que al ingresar el número 0, el programa indica que este número es efectivamente el cero, por lo que el algoritmo del programa logra su propósito que es analizar si un número leído desde el teclado es mayor que cero, es menor que cero, o es igual a cero.</p>
              <h5><strong>Ejecución 2.13.1: </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a41.png" style="display:block; margin:auto; "><br>
              <h5><strong>Ejecución 2.13.2: </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a42.png" style="display:block; margin:auto; "><br>
              <h5><strong>Ejecución 2.13.3: </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a43.png" style="display:block; margin:auto; "><br>

              <h3><strong>Caso de Estudio 2.11: Evaluar una Función Definida por Partes. </strong></h3>
              <h4><strong>A)   Problema </strong></h4>
              <p>Dada la función definida por partes y=f(x), calcular el valor de ‘y’ para un valor dado de ‘x’ y visualizarlo en pantalla.</p>
              <img src="./assets/images/Capitulos/II/media/a44.png" style="display:block; margin:auto; "><br>
              <p>Los tres intervalos de la función se muestran en la Figura 2.9.1 que son:</p>
              <p>y=-x;  I_1:x≤-1</p>
              <p>y=x^2;  I_2:-1 < x < 1, es decir, (-1 < x)∧(x < 1) </p>
              <p>y=x;  I_3:x≥1</p>
              <img src="./assets/images/Capitulos/II/media/a45.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.11.1. </strong>Intervalos de la función.</h5>
              
              <h4><strong>B)   Análisis </strong></h4>
              <p>Claramente, se puede ver que la entrada del problema es el valor de ‘x’. Hay una salida requerida: el valor de f(x)=y. Partiendo de un conocimiento básico de Álgebra, se sabe que hay dos intervalos y dos funciones lineales sobre las cuales se va a evaluar en un punto a la función definida por partes. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
              <h4><strong>B.1)   Requerimiento de los Datos </strong></h4>
              
              <h4><strong>Entradas del Problema </strong></h4>
              <p>x	&nbsp; &nbsp;/* valor de ‘x’ de la función */ </p>
                           
              <h4><strong>Salidas del Problema </strong></h4>
              <p>y	&nbsp; &nbsp;/* valor de ‘y’ de la función */ </p>
              
              <h4><strong>Formulas Relevantes </strong></h4>
              <img src="./assets/images/Capitulos/II/media/a46.png" style="display:block; margin:auto; "><br>
              <h4><strong>B.2)   Diagrama de Entrada-Salida </strong></h4>
              <p>En la Figura 2.11.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas y salidas del problema como son: a) Entradas: la variable ‘x’ (variable independiente); b) Salidas: la variable ‘y’ (variable dependiente). </p>
              <img src="./assets/images/Capitulos/II/media/a47.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.11.2. </strong>Diagrama de Entrada-Salida del Programa.</h5>
              <h4><strong>C)   Diseño </strong></h4>
              <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
              <h4><strong>Algoritmo </strong></h4>
              <p>1.	Leer el valor de ‘x’.</p>
              <p>2.	Si el valor de 'x' está dentro del intervalo I1: x≤-1.</p>
              <p> &nbsp; &nbsp; 2.1. 	Evaluar a la función f(x)=-x en un punto 'x'.</p>
              <p>3.		Caso contrario, si el valor de 'x' está dentro del intervalo I2: (-1< x)∧(x < 1).</p>
              <p> &nbsp; &nbsp; 3.1.	Evaluar a la función f(x)=x^2  en un punto 'x'.</p>
              <p>4.	Caso contrario, si el valor de 'x' está dentro del intervalo I3: x≥1.</p>
              <p> &nbsp; &nbsp; 4.1.	Evaluar a la función f(x)=x en un punto 'x'.</p>
              <p>5. Imprimir el valor de la variable ‘x’ y de la variable ‘y’.</p>
                                                           
              <h4><strong>D)   Implementación </strong></h4>
              <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.9.1 se muestra el código del programa en C/C++.</p>
              <h5><strong>Tabla 2.11.1. </strong>Programa que evalúa una función definida por partes.</h5>
              <pre><code [highlight]="prefTab[0].programa14"  [lineNumbers]="true"></code></pre><br>
              <h4><strong>E) Pruebas </strong></h4>
              <p>La Tabla 2.11.2, la Tabla 2.11.3 y la Tabla 2.11.4 muestran tres ejemplos de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
              <p>En la salida de la Tabla 2.11.2 se puede ver que, al ingresar el valor de -4 se evalúa la primera función cuyo valor resultante es 4. De manera similar, en la salida Tabla 2.11.3 se puede ver que, al ingresar el valor de 0.5 se evalúa la segunda función cuyo valor resultante es 0.25. Finalmente, en la salida Tabla 2.11.4 se puede ver que, al ingresar el valor de 4 se evalúa la tercera función cuyo valor resultante es 4.</p>
              
              <h5><strong>Tabla 2.11.2. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a48.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.11.3. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a49.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.11.4. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a50.png" style="display:block; margin:auto; "><br>

              <h3><strong>Caso de Estudio 2.12: Calcular el Consumo Eléctrico. </strong></h3>
              <h4><strong>A)   Problema </strong></h4>
              <p>Dadas las siguientes tarifas por gasto eléctrico en función del consumo en KWH, como se puede ver en la Tabla 2.12.1:</p>
              <h5><strong>Tabla 2.12.1. </strong>Tarifas de consumo eléctrico.</h5>
              <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
                <TR>
                  <TH>Consumo (KWH)</TH>
                  <TH>Tarifa (USD por KWH)</TH>
                </TR>
                <tbody *ngFor="let item of prefTab[0].tablaDatos10">
                <TR style="text-align: left">
                  <TD>
                    <ul *ngFor="let i of item.nota" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.puntos" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                </TR>
                </tbody>
              </TABLE><br>
              <p>Escribir un programa que permita calcular el costo de la planilla de luz o el recibo de la luz. Los cuatro intervalos del consumo de la luz ‘c’ se muestran en la Figura 2.12.1 que son:</p>
              <p>TARIFA1: I_1:0≤c≤200, es decir, (0 ≤ c)∧(c ≤ 200)</p>
              <p>TARIFA2: I_2:200 < c ≤ 500, es decir, (200 < c)∧(c ≤ 500) </p>
              <p>TARIFA3: I_3:500 < c ≤ 700, es decir, (500 < c)∧(c ≤ 700) </p>
              <p>TARIFA4: I_4:c > 700</p>
              
              <img src="./assets/images/Capitulos/II/media/a51.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.12.1. </strong>Intervalos de la nota promedio.</h5>
              
              <h4><strong>B)   Análisis </strong></h4>
              <p>Claramente, se puede ver que la entrada del problema es el valor del consumo de la luz ‘c’. Hay una salida requerida que es el valor del recibo. Partiendo de un conocimiento básico de Álgebra, se sabe que hay cuatro intervalos y cuatro diferentes valores para los recibos que dependen de los valores de las tarifas. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
              <h4><strong>B.1)   Requerimiento de los Datos </strong></h4>
              
              <h4><strong>Constante del Problema </strong></h4>
              <p>TARIFA1 = 0.35 </p>
              <p>TARIFA2 = 0.55 </p>
              <p>TARIFA3 = 0.75 </p>
              <p>TARIFA4 = 1.05 </p>
              <h4><strong>Entradas del Problema </strong></h4>
              <p>c	&nbsp; &nbsp;/* valor del consumo de la luz */ </p>
                                         
              <h4><strong>Salidas del Problema </strong></h4>
              <p>recibo	&nbsp; &nbsp;/* valor del recibo */ </p>
                            
              <h4><strong>Formulas Relevantes </strong></h4>
              <img src="./assets/images/Capitulos/II/media/a52.png" style="display:block; margin:auto; "><br>
              <h4><strong>B.2)   Diagrama de Entrada-Salida </strong></h4>
              <p>En la Figura 2.12.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘c’ (consumo); b) Salidas: la variable ‘recibo’; c) Auxiliares: la constante ‘TARIFA1’, la constante ‘TARIFA2’, la constante ‘TARIFA3’ y la constante ‘TARIFA4’.</p>
              <img src="./assets/images/Capitulos/II/media/a53.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.12.2. </strong>Diagrama de Entrada-Salida del Programa.</h5>
              <h4><strong>C)   Diseño </strong></h4>
              <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
              <h4><strong>Algoritmo </strong></h4>
              <p>1.	Leer el valor del consumo ‘c’.</p>
              <p>2.	Si el valor del consuno 'c' está dentro del intervalo I1: (0 ≤ c)∧(c ≤ 200).</p>
              <p> &nbsp; &nbsp; 2.1.	Calcular el valor del recibo con la TARIFA1.</p>
              <p>3.	Si el valor del consuno 'c' está dentro del intervalo I2: (200 < c)∧(c ≤ 500).</p>
              <p> &nbsp; &nbsp; 3.1.	Calcular el valor del recibo con la TARIFA2.</p>
              <p>4.	Si el valor del consuno 'c' está dentro del intervalo I3: (500 < c)∧(c ≤ 700)</p>
              <p> &nbsp; &nbsp; 4.1.	Calcular el valor del recibo con la TARIFA3.</p>
              <p>5. Si el valor del consuno 'c' está dentro del intervalo I4: c > 700.</p>
              <p> &nbsp; &nbsp; 5.1.	Calcular el valor del recibo con la TARIFA4.</p>
              <p>6.	Imprimir el valor de la variable ‘recibo’.</p>
                                                                  
              <h4><strong>D)   Implementación </strong></h4>
              <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.12.1 se muestra el código del programa en C/C++.</p>
              <h5><strong>Tabla 2.12.1. </strong>Programa que calcula el consumo eléctrico.</h5>
              <pre><code [highlight]="prefTab[0].programa15"  [lineNumbers]="true"></code></pre><br>
              <h4><strong>E) Pruebas </strong></h4>
              <p>La Tabla 2.12.2, la Tabla 2.12.3, la Tabla 2.12.4 y la Tabla 2.12.5 muestran cuatro ejemplos de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
              <p>En la salida de la Tabla 2.12.2 se puede ver que, al ingresar el valor del consumo igual a 100 se obtiene una cuenta total de $35 USD. De manera similar, en la salida Tabla 2.12.3 se puede ver que, al ingresar el valor del consumo igual a 400 se obtiene una cuenta total de $220 USD. De manera similar, en la salida Tabla 2.12.4 se puede ver que, al ingresar el valor del consumo igual a 600 se obtiene una cuenta total de $450 USD. Finalmente, en la salida Tabla 2.12.5 se puede ver que, al ingresar el valor del consumo igual a 800 se obtiene una cuenta total de $840 USD.</p>
                            
              <h5><strong>Tabla 2.12.2. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a54.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.12.3. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a55.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.12.4. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a56.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.12.5. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a57.png" style="display:block; margin:auto; "><br>
            </mat-tab>

            <mat-tab  label="2.3.5. Secuencia de Sentencias if-else">
              <h2>Secuencia de Sentencias if-else</h2>
              <p>Solo en ciertos casos se puede utilizar una secuencia de sentencias if-else, lo cual no es tan legible ni eficiente y se podría reemplazar por sentencias if-else anidadas que resulta mucho más eficiente ya que se ejecutan más rápidamente. El formato de esta sentencia tiene la siguiente sintaxis:</p>
              <h4>Sintaxis: </h4>
              <pre><code [highlight]="prefTab[0].sintaxis7"  [lineNumbers]="true"></code></pre><br>
              <p>expresión1 &nbsp; &nbsp; Expresión lógica que determina si la sentencia o acción se ha de ejecutar.</p>
              <p>expresión2 &nbsp; &nbsp; Expresión lógica que determina si la sentencia o acción se ha de ejecutar.</p>
              <p>sentencia2.1 &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresión lógica es verdadera.</p>
              <p>sentencia2.2 &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresión lógica es verdadera.</p>
              <p>expresión3 &nbsp; &nbsp; Expresión lógica que determina si la sentencia o acción se ha de ejecutar.</p>
              <p>expresión4 &nbsp; &nbsp; Expresión lógica que determina si la sentencia o acción se ha de ejecutar.</p>
              <p>sentencia4.1 &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresión lógica es verdadera.</p>
              <p>sentencia4.2 &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresión lógica es verdadera.</p>
              <p>expresiónm &nbsp; &nbsp; Expresión lógica que determina si la sentencia o acción se ha de ejecutar.</p>
              <p>expresiónn &nbsp; &nbsp; Expresión lógica que determina si la sentencia o acción se ha de ejecutar.</p>
              <p>sentencian.1 &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresión lógica es verdadera.</p>
              <p>sentencian.2 &nbsp; &nbsp; La sentencia o acción se ejecuta si la expresión lógica es verdadera.</p>
              <p><strong>Nota: </strong>En esta sintaxis no es necesario utilizar llaves ya que se tiene una sola sentencia o instrucción, en todos los ‘if-else’.</p>

              <h4><strong>Ejercicio 2.14: </strong> Escribir un programa que permita calcular el mayor de tres números leídos desde el teclado y visualizarlo en pantalla.</h4>
              <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
                <TR>
                  <TH>N°</TH>
                  <TH>Algoritmo en Pseudocódigo</TH>
                  <TH>Algoritmo en Lenguaje C/C++</TH>
                </TR>
                <tbody *ngFor="let item of prefTab[0].tablaDatos11">
                <TR style="text-align: left">
                  <TD>
                    <ul *ngFor="let i of item.Numero" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Pseudo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Codigo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                </TR>
                </tbody>
              </TABLE><br>
              <h5><strong>Programa 2.14:  </strong>Código del programa.</h5>
              <pre><code [highlight]="prefTab[0].programa16"  [lineNumbers]="true"></code></pre><br>
              <p>En la salida de la Ejecución 2.14 se puede ver que al ingresar el valor del primer número que es 72, el valor del segundo número que es 84 y el valor del tercer número que es 51, el programa indica que el mayor de los tres números es 84.</p>
              <h5><strong>Ejecución 2.14: </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a58.png" style="display:block; margin:auto; "><br>

              <h3><strong>Caso de Estudio 2.13: Colores Secundarios a partir de Mezclas. </strong></h3>
              <h4><strong>A)   Problema </strong></h4>
              <p>Escribir un programa que permita obtener los colores secundarios a partir de la mezcla de dos colores primarios, es decir, amarillo, azul y rojo. El programa debe permitir visualizar un mensaje de la mezcla de los dos colores en pantalla.</p>
                            
              <h4><strong>B)   Análisis </strong></h4>
              <p>Claramente, se puede ver que las entradas del problema son los valores de las variables ‘primero’ y ‘segundo’ que representan a los dos colores que se van a mezclar. Hay una sola salida requerida que es un mensaje de información que contiene la mezcla de los dos colores y su resultado que es un color secundario. Partiendo de un conocimiento básico de arte, se sabe que hay tres colores secundarios obtenidos a partir de la mezcla de dos colores primarios:</p>
              <ol type=”A”>
                <li>Amarillo + Rojo = Naranja</li>
                <li>Azul + Rojo = Violeta</li>
                <li>Amarillo + Azul = Verde</li>
              </ol>
              <p>En la Figura 2.13.1 se muestran los tres colores primarios y los tres colores secundarios obtenidos de mezclas:</p>
              <img src="./assets/images/Capitulos/II/media/a59.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.13.1.</strong>Tres colores secundarios obtenidos de mezclas.</h5>
              <h4><strong>B.1)   Requerimiento de los Datos </strong></h4>
              
              <h4><strong>Entradas del Problema </strong></h4>
              <p>primero	&nbsp; &nbsp;/* valor del primer color */ </p>
              <p>segundo	&nbsp; &nbsp;/* valor del segundo color */ </p>
                                         
              <h4><strong>Salidas del Problema </strong></h4>
              <p>Amarillo + Azul = Verde	&nbsp; &nbsp;/* Mensaje de información de la primera mezcla */ </p>
              <p>Amarillo + Rojo = Naranja	&nbsp; &nbsp;/* Mensaje de información de la segunda mezcla */ </p>
              <p>Azul + Rojo = Violeta	&nbsp; &nbsp;/* Mensaje de información de la tercera mezcla */ </p>
              <p>Azul + Amarillo = Verde	&nbsp; &nbsp;/* Mensaje de información de la cuarta mezcla */ </p>
                            
              <h4><strong>B.2)   Diagrama de Entrada-Salida </strong></h4>
              <p>En la Figura 2.13.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas y salidas del problema como son: a) Entradas: la variable ‘primero’, la variable ‘segunco’; b) Salidas: Mensaje 1: “Verde”; Mensaje 2: “Naranja”; Mensaje 3: “Violeta”; Mensaje 4: “Verde”.</p>
              <img src="./assets/images/Capitulos/II/media/a60.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.13.2. </strong>Diagrama de Entrada-Salida del Programa.</h5>
              <h4><strong>C)   Diseño </strong></h4>
              <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
              <h4><strong>Algoritmo </strong></h4>
              <p>1.	Imprimir el mensaje de información: “Mezcla de dos colores primarios”.</p>
              <p>2.	Imprimir el mensaje: a. Amarillo; b. Azul.</p>
              
              <p>3.	Imprimir el mensaje: Seleccione un color (a o b):</p>
              <p>4.	Leer el primer color utilizando la variable ‘primero’.</p>
              <p>5.	Si el primer color es igual a la opción 'a' (Amarillo).</p>
              <p> &nbsp; &nbsp; 5.1.	Imprimir el mensaje: b. Azul; c. Rojo.</p>
              <p> &nbsp; &nbsp; 5.2.	Imprimir el mensaje: Seleccione otro color (b o c):</p>
              <p> &nbsp; &nbsp; 5.3.	Leer el segundo color utilizando la variable ‘segundo’.</p>
              <p> &nbsp; &nbsp; 5.4.	Si el segundo color es igual a la opción 'b' (Azul).</p>
              <p> &nbsp; &nbsp; &nbsp; 5.4.1.	Imprimir el mensaje: Amarillo + Azul = Verde</p>
              <p> &nbsp; &nbsp; 5.5.	Caso contrario, se seleccionó la opción 'c' (Rojo).</p>
              <p> &nbsp; &nbsp; &nbsp; 5.5.1.	Imprimir el mensaje: Amarillo + Rojo = Naranja</p>
              <p>6.	Caso contrario, se seleccionó la opción 'b' (Azul)..</p>
              <p> &nbsp; &nbsp; 6.1.	Imprimir el mensaje: c. Rojo; a. Amarillo.</p>
              <p> &nbsp; &nbsp; 6.2.	Imprimir el mensaje: Seleccione otro color (c o a):</p>
              <p> &nbsp; &nbsp; 6.3.	Leer el segundo color.</p>
              <p> &nbsp; &nbsp; 6.4.	Si el segundo color es igual a la opción 'c' (Rojo).</p>
              <p> &nbsp; &nbsp; 6.4.1.	Imprimir el mensaje: Azul + Rojo = Violeta</p>
              <p> &nbsp; &nbsp; 6.5.	Caso contrario, se seleccionó la opción 'a' (Amarillo).</p>
              <p> &nbsp; &nbsp; 6.5.1.	Imprimir el mensaje: Azul + Amarillo = Verde</p>
                                                                  
              <h4><strong>D)   Implementación </strong></h4>
              <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.13.1 se muestra el código del programa en C/C++.</p>
              <h5><strong>Tabla 2.13.1. </strong>Programa que evalúa una función definida por partes.</h5>
              <pre><code [highlight]="prefTab[0].programa17"  [lineNumbers]="true"></code></pre><br>
              <h4><strong>E) Pruebas </strong></h4>
              <p>La Tabla 2.13.2, la Tabla 2.13.3, la Tabla 2.13.4 y la Tabla 2.13.5 muestran cuatro ejemplos de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos obtenidos por las mezclas de dos colores primarios para obtener un color secundario de acuerdo a la Figura 2.13.1.</p>
              <p>En la salida de la Tabla 2.13.2 se puede ver que, al seleccionar la opción ‘a’ (Amarillo) y la opción ‘b’ (Azul), se obtiene el color Verde. De manera similar, en la salida de la Tabla 2.13.3 se puede ver que, al seleccionar la opción ‘a’ (Amarillo) y la opción ‘c’ (Rojo), se obtiene el color Naranja. De manera similar, en la salida de la Tabla 2.13.4 se puede ver que, al seleccionar la opción ‘b’ (Azul) y la opción ‘c’ (Rojo), se obtiene el color Violeta. Finalmente, en la salida de la Tabla 2.13.5 se puede ver que, al seleccionar la opción ‘b’ (Azul) y la opción ‘a’ (Amarillo), se obtiene el color Verde.</p>
                            
              <h5><strong>Tabla 2.13.2. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a61.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.13.3. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a62.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.13.4. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a63.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.13.5. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a64.png" style="display:block; margin:auto; "><br>

              <h3><strong>Caso de Estudio 2.14: Calcular las Raíces de la Función Cuadrática. </strong></h3>
              <h4><strong>A)   Problema </strong></h4>
              <p>Escribir un programa para calcular las raíces de la función cuadrática:</p>
              <p>f(x)=ax^2+bx+c</p>
              <p>Las raíces son los valores de x para los cuales:</p>
              <p>f(x)=0</p>
              <p>Para calcular las raíces de la función se utiliza la fórmula:</p>
              <img src="./assets/images/Capitulos/II/media/a65.png" style="display:block; margin:auto; "><br>
              <p>El discriminante de la función cuadrática es:</p>
              <p>∆=b^2-4ac</p>
              <p>Los tipos de raíces se obtienen de acuerdo a las siguientes condiciones del discriminante:</p>
              <p>si ∆ > 0, las raíces son reales.</p>
              <p>si ∆ = 0, existe una sola raíz real.</p>
              <p>si ∆ < 0, las raíces son imaginarias.</p>
              <p>En la Figura 2.14.1 se muestran tres gráficos que corresponden a las condiciones del discriminante y sus raíces.</p>
              <h5><strong>Figura 2.14.1. </strong>Raíces de la función cuadrática.</h5>
              <img src="./assets/images/Capitulos/II/media/a66.png" style="display:block; margin:auto; "><br>
                            
              <h4><strong>B)   Análisis </strong></h4>
              <p>Claramente, se puede ver que las tres entradas del problema son los coeficientes ‘a’, ‘b’ y ‘c’ de la función. Dependiendo del valor del discriminante; si el descriminante es mayor que cero, entonces hay dos salidas diferentes que son ‘x1’ y ‘x2’; si el discriminante es igual a cero, entonces hay dos salidas iguales entre sí que son ‘x1’ y ‘x2’; si el discriminante es menor que cero, entonces hay dos salidas complejas conjugadas que son formadas por las variables ‘real’ e ‘imag’. Además, hay una salida para la ecuación lineal que es ‘x’ si el valor del coeficiente ‘a’ es igual a cero. Finalmente, hay otra salida que es la misma variable del coeficiente ‘c’ cuando el valor del coeficiente ‘a’ es igual a cero y también el valor del coeficiente ‘b’ es igual a cero. Partiendo de un conocimiento básico de Algebra, se sabe que hay una relación entre el discriminante de la ecuación cuadrática y sus coeficientes. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
              
              <h4><strong>B.1)   Requerimiento de los Datos </strong></h4>
              
              <h4><strong>Entradas del Problema </strong></h4>
              <p>a	&nbsp; &nbsp;/* coeficiente 1 de la ecuación cuadrática */ </p>
              <p>b	&nbsp; &nbsp;/* coeficiente 2 de la ecuación cuadrática */ </p>
              <p>c	&nbsp; &nbsp;/* coeficiente 3 de la ecuación cuadrática */ </p>
                                         
              <h4><strong>Salidas del Problema </strong></h4>
              <p>x	&nbsp; &nbsp;/* raíz de la ecuación lineal */ </p>
              <p>c	&nbsp; &nbsp;/* coeficiente 3 de la ecuación cuadrática */ </p>
              <p>x1	&nbsp; &nbsp;/* raíz real de la ecuación cuadrática */ </p>
              <p>x2	&nbsp; &nbsp;/* raíz real de la ecuación cuadrática */ </p>
              <p>real	&nbsp; &nbsp;/* parte real del número complejo de la raíz imaginaria */ </p>
              <p>imag	&nbsp; &nbsp;/* parte imaginaria del número complejo de la raíz imaginaria */ </p>
              
              <h4><strong>Auxiliares del Problema </strong></h4>
              <p>D	&nbsp; &nbsp;/* Discriminante de la ecuación cuadrática */ </p>
              <h4><strong>Fórmulas Relevantes </strong></h4>
              <p>Para encontrar las raíces de la ecuación cuadrática, se deben considerar los siguientes casos:</p>
              <p>si a = 0 y si b ≠ 0, entonces: x=-c÷b (1)</p>
              <p>si a = 0 y b = 0, entonces la función es una constante, cuya ecuación es: y = c (2) </p>
              <p>si a ≠ 0, donde el discriminante es: ∆=b^2-4ac (3)</p>
              <p>si ∆>0, entonces las raíces son reales:</p>
              <img src="./assets/images/Capitulos/II/media/a67.png" style="display:block; margin:auto; "><br>
              <p>si ∆ = 0, entonces existe una sola raíz real:</p>
              <img src="./assets/images/Capitulos/II/media/a68.png" style="display:block; margin:auto; "><br>
              <p>si ∆ < 0, entonces las raíces son imaginarias:</p>
              <img src="./assets/images/Capitulos/II/media/a69.png" style="display:block; margin:auto; "><br>

              <h4><strong>B.2)   Diagrama de Entrada-Salida </strong></h4>
              <p>En la Figura 2.14.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘a’ (coeficiente 1); la variable ‘b’ (coeficiente 2); la variable ‘c’ (coeficiente 3); b) Salidas: la variable ‘x’; la variable ‘c’ (coeficiente 3); la variable ‘x1’; la variable ‘x2’; la variable ‘real’; la variable ‘imag’; c) Auxiliares: la variable ‘D’ (Discriminante).</p>
              <img src="./assets/images/Capitulos/II/media/a70.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.14.2. </strong>Diagrama de Entrada-Salida del Programa.</h5>
              <h4><strong>C)   Diseño </strong></h4>
              <p>Una vez que se conocen las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
              <h4><strong>Algoritmo </strong></h4>
              <p>1.	Imprimir el mensaje de información: “Raíces de la ecuación cuadrática.”.</p>
              <p>2.	Leer el valor del coeficiente ‘a’ de la ecuación cuadrática.</p>
              
              <p>3.	Leer el valor del coeficiente ‘b’ de la ecuación cuadrática.</p>
              <p>4.	Leer el valor del coeficiente ‘c’ de la ecuación cuadrática.</p>
              <p>5.	Si el valor del coeficiente ‘a’ es igual a cero.</p>
              <p> &nbsp; &nbsp; 5.1.	Si el valor del coeficiente ‘b’ es diferente de cero.</p>
              <p> &nbsp; &nbsp; &nbsp; 5.1.1.	Calcular el valor de la raíz de la ecuación lineal ‘x’ que es igual al resultado de la división entre –c para b.</p>
              <p> &nbsp; &nbsp; &nbsp; 5.1.2.	Imprimir el valor de la raíz de la ecuación lineal 'x'.</p>
              <p> &nbsp; &nbsp; 5.2.	Caso contrario, cuando el valor del coeficiente 'b' es igual a cero.</p>
              <p> &nbsp; &nbsp; &nbsp; 5.2.1.	Imprimir el valor de la función constante que es igual al valor de 'c'.</p>
              
              <p>6.	Caso contrario, cuando el valor del coeficiente 'a' es diferente de cero (a != 0).</p>
              <p> &nbsp; &nbsp; 6.1.	Calcular el valor del discriminante, utilizando la variable 'D'.</p>
              <p> &nbsp; &nbsp; &nbsp; 6.1.1.	Asignar a la variable ‘D’ el cuadrado de ‘b’ menos cuatro veces ‘a’ por ‘c’ de acuerdo a la ecuación (3).</p>
              <p> &nbsp; &nbsp; 6.2.	Si el valor del discriminante es mayor que cero</p>
              <p> &nbsp; &nbsp; &nbsp; 6.2.1.	Imprimir el mensaje: “Las raíces son reales”.</p>
              <p> &nbsp; &nbsp; &nbsp; 6.2.2.	Calcular el valor de la primera raíz que es ‘x1’.</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; 6.2.2.1.	Asignar a la variable ‘x1’ el valor de la expresión que consta en la ecuación (4).</p>
              <p> &nbsp; &nbsp; &nbsp; 6.2.3.	Calcular el valor de la segunda raíz que es ‘x2’.</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; 6.2.3.1.	Asignar a la variable ‘x2’ el valor de la expresión que consta en la ecuación (5).</p>

              <p> &nbsp; &nbsp; 6.3.	Caso contrario, si el valor del discrimiante es igual a cero.</p>
              <p> &nbsp; &nbsp; &nbsp; 6.3.1.	Imprimir el mensaje: “Existe una sola raíz real.”.</p>
              <p> &nbsp; &nbsp; &nbsp; 6.3.2.	Calcular el valor de la única raíz real que es ‘x1’.</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; 6.3.2.1.	Asignar a la variable ‘x1’ el valor de la expresión que consta en la ecuación (6).</p>
              <p> &nbsp; &nbsp; &nbsp; 6.3.3.	Asignar a la variable ‘x2’ el valor de la raíz de la variable ‘x1’.</p>
              <p> &nbsp; &nbsp; &nbsp; 6.3.4.	Imprimir el valor de única raíz real, donde ‘x1’ es igual a ‘x2’.</p>
              <p> &nbsp; &nbsp; 6.4.	Caso contrario, si el valor del discrimiante es menor que cero.</p>
              <p> &nbsp; &nbsp; &nbsp; 6.4.1.	Imprimir el mensaje: “Las raíces son imaginarias.”.</p>
              <p> &nbsp; &nbsp; &nbsp; 6.4.2.	Calcular el valor de la parte real del número complejo.</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; 6.4.2.1.	Asignar a la variable ‘x1’ el valor de la expresión que consta en la ecuación (8).</p>
              <p> &nbsp; &nbsp; &nbsp; 6.4.3.	Calcular el valor de la parte imaginaria del número complejo.</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; 6.4.3.1.	Asignar a la variable ‘x2’ el valor de la expresión que consta en la ecuación (9).</p>
              <p> &nbsp; &nbsp; &nbsp; 6.4.4.	Imprimir el primer número complejo ‘Z1’ obtenido con los valores de la parte real y la parte imaginaria.</p>
              <p> &nbsp; &nbsp; &nbsp; 6.4.5.	Imprimir el segundo número complejo 'Z2' que resulta ser el conjudado del primer número complejo ‘Z1’.</p>
                                                                  
              <h4><strong>D)   Implementación </strong></h4>
              <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.14.1 se muestra el código del programa en C/C++.</p>
              <h5><strong>Tabla 2.14.1. </strong>Programa que calcula las raíces de la función cuadrática.</h5>
              <pre><code [highlight]="prefTab[0].programa17"  [lineNumbers]="true"></code></pre><br>
              <h4><strong>E) Pruebas </strong></h4>
              <p>La Tabla 2.14.2, la Tabla 2.14.3, la Tabla 2.14.4, la Tabla 2.14.5 y la Tabla 2.14.6 muestran cinco ejemplos de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora científica. </p>
              <p>En la salida de la Tabla 2.14.2 se puede ver que, al ingresar los valores de ‘a’ igual a 0, ‘b’ igual a 6 y ‘c’ igual a 3 se obtiene el valor de la raíz de la ecuación lineal ‘x’ igual a -0.5. En la Tabla 2.14.3 se puede ver que, al ingresar los valores de ‘a’ igual a 0, ‘b’ igual a 0 y ‘c’ igual a 3 se obtiene una función constante cuya ecuación es igual a 3. En la Tabla 2.14.4 se puede ver que, al ingresar los valores de ‘a’ igual a  -2, ‘b’ igual a 4 y ‘c’ igual a 6 se obtienen las raíces reales x_1=-1 y x_1=3. En la Tabla 2.14.5 se puede ver que, al ingresar los valores de ‘a’ igual a -3, ‘b’ igual a 6 y ‘c’ igual a -3 se obtiene una sola raíz real igual, donde x_1 es igual a x_2 que es igual a 1. En la Tabla 2.14.6 se puede ver que, al ingresar los valores de ‘a’ igual a 1, ‘b’ igual a 1 y ‘c’ igual a 1 se obtienen las raíces imaginarias Z_1=(-0.5,0.866025i) y Z_2=(-0.5,-0.866025i).</p>
                            
              <h5><strong>Tabla 2.14.2. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a71.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.14.3. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a72.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.14.4. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a73.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.14.5. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a74.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.14.6. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a75.png" style="display:block; margin:auto; "><br>
            </mat-tab>

            <mat-tab  label="2.3.6. Sentencia de Control switch">
              <h2>Sentencia de Control switch</h2>
              <p>La sentencia switch se la utiliza cuando se necesita elegir una o varias acciones entre algunas alternativas, por lo tanto, esta sentencia no es excluyente. La sentencia switch es especialmente útil cuando la selección se basa en el valor de una variable simple o de una expresión simple denominada expresión de control o selector. El valor de esta expresión puede ser de tipo int o char, pero no de tipo float ni double. El formato de esta sentencia tiene la siguiente sintaxis:</p>
              <pre><code [highlight]="prefTab[0].programa19"  [lineNumbers]="true"></code></pre><br>
              <p>La sentencia break y default son opcionales en la sentencia switch. La sentencia break es una sentencia de salto que hace que el control del programa se salga de la sentencia switch y se dirija a la sentencia situada inmediatamente después de la misma. La sentencia default también es una sentencia opcional donde si no existe un valor específico en la lista del switch, se transfiere el control del programa a la sentencia default.</p>
              <h4><strong>Ejercicio 2.15: </strong>Escribir un programa que permita leer un dígito (0-9) e imprima el dígito seleccionado en letras y si no es así imprima el mensaje valor fuera de rango.</h4>
              <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
                <TR>
                  <TH>N°</TH>
                  <TH>Algoritmo en Pseudocódigo</TH>
                  <TH>Algoritmo en Lenguaje C/C++</TH>
                </TR>
                <tbody *ngFor="let item of prefTab[0].tablaDatos12">
                <TR style="text-align: left">
                  <TD>
                    <ul *ngFor="let i of item.Numero" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Pseudo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Codigo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                </TR>
                </tbody>
              </TABLE><br>
              <h5><strong>Programa 2.15: </strong>Código del programa.</h5>
              <pre><code [highlight]="prefTab[0].programa20"  [lineNumbers]="true"></code></pre><br>
              <p>En la salida de la Ejecución 2.15 se puede ver que al ingresar el dígito 7, el programa indica en palabras que este dígito es efectivamente el siete.</p>
              <img src="./assets/images/Capitulos/II/media/a76.png" style="display:block; margin:auto; "><br>
              <h4><strong>Ejercicio 2.16: </strong>Escribir un programa que permita leer una letra y analizar si es una vocal o no lo es.</h4>
              <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
                <TR>
                  <TH>N°</TH>
                  <TH>Algoritmo en Pseudocódigo</TH>
                  <TH>Algoritmo en Lenguaje C/C++</TH>
                </TR>
                <tbody *ngFor="let item of prefTab[0].tablaDatos13">
                <TR style="text-align: left">
                  <TD>
                    <ul *ngFor="let i of item.Numero" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Pseudo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.Codigo" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                </TR>
                </tbody>
              </TABLE><br>
              <h5><strong>Programa 2.16: </strong>Código del programa.</h5>
              <pre><code [highlight]="prefTab[0].programa21"  [lineNumbers]="true"></code></pre><br>
              <p>En la salida de la Ejecución 2.16 se puede ver que al ingresar la letra i, el programa indica en palabras que esta letra es una vocal.</p>
              <h5><strong>Ejecución 2.16: </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a77.png" style="display:block; margin:auto; "><br>

              <h3><strong>Caso de Estudio 2.15: Menú con 5 Operaciones Matemáticas. </strong></h3>
              <h4><strong>A)   Problema </strong></h4>
              <p>Escribir un programa para crear un menú que tenga las siguientes opciones:</p>
              <ol type=”A”>
                <li>Suma de dos números enteros.</li>
                <li>Resta de dos números enteros.</li>
                <li>Multiplicación entre dos números enteros.</li>
                <li>División entre dos números enteros.</li>
                <li>Módulo entre dos números enteros.</li>
              </ol>
              <p>Para la operación de la división y el módulo se debe controlar que no exista división para cero.</p>
                                          
              <h4><strong>B)   Análisis </strong></h4>
              <p>Claramente, se puede ver que las entradas del problema son el primer número representado por la variable ‘num1’ y el segundo número representado por la variable ‘num2’ con los cuales se van a realizar diferentes operaciones aritméticas. Además, la tercera entrada es la opción del menú a seleccionar representada por la variable ‘opcion’. Hay una sola salida requerida que es el valor del resultado de una operación representada por la variable ‘num3’. Partiendo de un conocimiento básico de Aritmética y Álgebra, se sabe que hay 5 operaciones matemáticas y 5 diferentes valores para el resultado que depende del tipo de operación. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
              
              <h4><strong>B.1)   Requerimiento de los Datos </strong></h4>
              
              <h4><strong>Entradas del Problema </strong></h4>
              <p>num1	&nbsp; &nbsp;/* Valor del primer número */ </p>
              <p>num2	&nbsp; &nbsp;/* Valor del segundo número */ </p>
              <p>opcion	&nbsp; &nbsp;/* Opción a ser seleccionada del menú */ </p>
                                         
              <h4><strong>Salidas del Problema </strong></h4>
              <p>num3	&nbsp; &nbsp;/* Valor del resultado de una operación */ </p>
                            
              <h4><strong>Fórmulas Relevantes </strong></h4>
              <img src="./assets/images/Capitulos/II/media/a78.png" style="display:block; margin:auto; "><br>
              
              <h4><strong>B.2)   Diagrama de Entrada-Salida </strong></h4>
              <p>En la Figura 2.15.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas y salidas del problema como son: a) Entradas: la variable ‘num1’; la variable ‘num2’; la variable ‘opcion’; b) Salidas: la variable ‘num3’.</p>
              <img src="./assets/images/Capitulos/II/media/a79.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.15.2. </strong>Diagrama de Entrada-Salida del Programa.</h5>
              <h4><strong>C)   Diseño </strong></h4>
              <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
              <h4><strong>Algoritmo </strong></h4>
              <p>1.	Imprimir un menú con cinco opciones.</p>
              <p> &nbsp; &nbsp; 1.1.	Imprimir el mensaje: 1. Suma de dos números.</p>
              <p> &nbsp; &nbsp; 1.2.	Imprimir el mensaje: 2. Resta de dos números.</p>
              <p> &nbsp; &nbsp; 1.3.	Imprimir el mensaje: 3. Multiplicación entre dos números.</p>
              <p> &nbsp; &nbsp; 1.4.	Imprimir el mensaje: 4. División entre dos números.</p>
              <p> &nbsp; &nbsp; 1.5.	Imprimir el mensaje: 5. Módulo entre dos números.</p>
              <p> &nbsp; &nbsp; 1.6.	Imprimir el mensaje: Digite una opción.</p>
              <p>2.	Leer el valor de la opción seleccionada, utilizando la variable ‘opcion’.</p>
              
              <p>3.	Si la opción seleccionada está entre los valores de 1 y 5.</p>
              <p> &nbsp; &nbsp; 3.1.	Leer el valor del primer número ‘num1’.</p>
              <p> &nbsp; &nbsp; 3.2.	Leer el valor del segundo número ‘num2’.</p>
              <p>4.	Según sea el valor de la variable 'opcion', hacer:</p>
              <p> &nbsp; &nbsp; 4.1.	Caso 1: </p>
              <p> &nbsp; &nbsp; &nbsp; 4.1.1.	Calcular la suma entre dos números.</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; 4.1.1.1.	Asignar la suma entre dos números a la variable ‘num3’.</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; 4.1.1.2.	Imprimir el mensaje: num1 + num2 = num3.</p>
              <p> &nbsp; &nbsp; 4.2.	Caso 2:  </p>
              <p> &nbsp; &nbsp; &nbsp; 4.2.1.	Calcular la resta entre dos números.</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; 4.2.1.1.	Asignar la resta entre dos números a la variable ‘num3’.</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; 4.2.1.2.	Imprimir el mensaje: num1 - num2 = num3.</p>
              <p> &nbsp; &nbsp; 4.3.	Caso 3: </p>
              <p> &nbsp; &nbsp; &nbsp; 4.3.1.	Calcular la multiplicación entre dos números.</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; 4.3.1.1.	Asignar el producto entre dos números a la variable ‘num3’.</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; 4.3.1.2.	Imprimir el mensaje: num1 * num2 = num3.</p>
              <p> &nbsp; &nbsp; 4.4.	Caso 4:  </p>
              <p> &nbsp; &nbsp; &nbsp; 4.4.1.	Si el valor de la variable ‘num2’ es diferente de cero.</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; 4.4.1.1.	Calcular la división entre dos números.</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4.4.1.1.1.	Asignar la división entre dos números a la variable ‘num3’.</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4.4.1.1.2.	Imprimir el mensaje: num1 / num2 = num3.</p>
              <p> &nbsp; &nbsp; &nbsp; 4.4.2.	Caso contrario, se niega la condición: !(num2 != 0), es decir, (num2 == 0).</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; 4.4.2.1.	Imprimir el mensaje: Error. División para cero no existe.</p>
              <p> &nbsp; &nbsp; 4.5.	Caso 5: </p>
              <p> &nbsp; &nbsp; &nbsp; 4.5.1.	Si el valor de la variable ‘num2’ es diferente de cero.</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; 4.5.1.1.	Calcular el módulo entre dos números.</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4.5.1.1.1.	Asignar el módulo entre dos números a la variable ‘num3’, utilizando el operador ‘%’.</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4.5.1.1.2.	Imprimir el mensaje: num1 % num2 = num3.</p>
              <p> &nbsp; &nbsp; &nbsp; 4.5.2.	Caso contrario, se niega la condición: !(num2 != 0), es decir, (num2 == 0).</p>
              <p> &nbsp; &nbsp; &nbsp; &nbsp; 4.5.2.1.	Imprimir el mensaje: Error. División para cero no existe.</p>
              <p> &nbsp; &nbsp; 4.6.	Caso por defecto: </p>
              <p> &nbsp; &nbsp; &nbsp; 4.6.1.	Imprimir el mensaje: Opción incorrecta.</p>
                       
                                                                
              <h4><strong>D)   Implementación </strong></h4>
              <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.15.1 se muestra el código del programa en C/C++.</p>
              <h5><strong>Tabla 2.15.1. </strong>Programa que calcula el consumo eléctrico.</h5>
              <pre><code [highlight]="prefTab[0].programa22"  [lineNumbers]="true"></code></pre><br>
              <h4><strong>E) Pruebas </strong></h4>
              <p>Desde la Tabla 2.15.2, hasta la Tabla 2.15.7, se muestran seis ejemplos de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
              <p>En la salida de la Tabla 2.15.2 se puede ver que, al seleccionar la opción 1 se puede ingresar el primer número que es el 7 y el segundo número que es el 2, obteniéndose la suma entre estos dos números que es 9. De manera similar, en la salida de la Tabla 2.15.3 se puede ver que, al seleccionar la opción 2 se puede ingresar el primer número que es el 7 y el segundo número que es el 2, obteniéndose la resta entre estos dos números que es 5. En la salida de la Tabla 2.15.4 se puede ver que, al seleccionar la opción 3 se puede ingresar el primer número que es el 7 y el segundo número que es el 2, obteniéndose la multiplicación entre estos dos números que es 14. En la salida de la Tabla 2.15.5 se puede ver que, al seleccionar la opción 4 se puede ingresar el primer número que es el 7 y el segundo número que es el 2, obteniéndose la división entera entre estos dos números que es 3. En la salida de la Tabla 2.15.6 se puede ver que, al seleccionar la opción 5 se puede ingresar el primer número que es el 7 y el segundo número que es el 2, obteniéndose el módulo o el resto de una división entera entre estos dos números que es 1. Finalmente, en la salida de la Tabla 2.15.7 se puede ver que, al seleccionar la opción 7, el programa indica que es una opción incorrecta y no realiza ningún cálculo matemático.</p>
                            
              <h5><strong>Tabla 2.15.2. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a80.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.15.3. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a81.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.15.4. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a82.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.15.5. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a83.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.15.6. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a84.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.15.7. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a85.png" style="display:block; margin:auto; "><br>

              <h3><strong>Caso de Estudio 2.16: Menú con 8 Opciones para Consulta de Valores de Peajes. </strong></h3>
              <h4><strong>A)   Problema </strong></h4>
              <p>Dadas las siguientes tarifas de peajes para vehículos, como se puede ver en la Tabla 2.16.1:</p>
              <p><strong>Tabla 2.16.1. </strong>Tarifas de peajes.</p>
              <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
                <TR>
                  <TH>Vehículo</TH>
                  <TH>Tarifa (USD)</TH>
                </TR>
                <tbody *ngFor="let item of prefTab[0].tablaDatos14">
                <TR style="text-align: left">
                 
                  <TD>
                    <ul *ngFor="let i of item.nota" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.puntos" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                </TR>
                </tbody>
              </TABLE><br>
              <p>Escribir un programa con un menú que permita seleccionar un tipo de vehículo y calcular el costo del peaje para un determinado número de vehículos según el valor de la tarifa.</p>
                                          
              <h4><strong>B)   Análisis </strong></h4>
              <p>Claramente, se puede ver que las entradas del problema son el número de vehículos representados por la variable ‘numVehiculos’ y la opción del menú a seleccionar representada por la variable ‘opcion’. Hay una salida requerida que es el valor del costo del peaje. Partiendo de un conocimiento básico de Aritmética y Álgebra, se sabe que hay 8 diferentes valores para los costos que dependen de los valores de las tarifas y del número de vehículos. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
              
              <h4><strong>B.1)   Requerimiento de los Datos </strong></h4>
              <h4><strong>Constantes del Problema </strong></h4>
              <p>TARIFA1 = 1.00 <br>
                TARIFA2 = 2.00 <br>
                TARIFA3 = 3.00 <br>
                TARIFA4 = 4.00 <br>
                TARIFA5 = 5.00 <br>
                TARIFA6 = 6.00 <br>
                TARIFA7 = 0.20 <br>
                TARIFA8 = 1.50
                </p>
              <h4><strong>Entradas del Problema </strong></h4>
              <p>numVehiculos	&nbsp; &nbsp;/* Valor del número de vehículos */ </p>
              <p>opcion	&nbsp; &nbsp;/* Opción a ser seleccionada del menú */ </p>
                                                       
              <h4><strong>Salidas del Problema </strong></h4>
              <p>costo	&nbsp; &nbsp;/* Valor del costo del peaje */ </p>
                            
              <h4><strong>Fórmulas Relevantes </strong></h4>
              <img src="./assets/images/Capitulos/II/media/a86.png" style="display:block; margin:auto; "><br>
              
              <h4><strong>B.2)   Diagrama de Entrada-Salida </strong></h4>
              <p>En la Figura 2.16.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘numVehiculos’; la variable ‘opcion’; b) Salidas: la variable ‘costo’; c) Auxiliares: las constantes TARIFA1, TARIFA2; TARIFA3; TARIFA4; TARIFA5; TARIFA6; TARIFA7; TARIFA8.</p>
              <img src="./assets/images/Capitulos/II/media/a87.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.16.2. </strong>Diagrama de Entrada-Salida del Programa.</h5>
              <h4><strong>C)   Diseño </strong></h4>
              <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
              <h4><strong>Algoritmo </strong></h4>
              <p>1.	Imprimir un menú con cinco opciones.</p>
              <p> &nbsp; &nbsp; 1.1.	Imprimir el mensaje: 1. Automóviles, todoterrenos o camionetas.</p>
              <p> &nbsp; &nbsp; 1.2.	Imprimir el mensaje: 2. Buses y camiones de 2 ejes.</p>
              <p> &nbsp; &nbsp; 1.3.	Imprimir el mensaje: 3. Buses y camiones de 3 ejes.</p>
              <p> &nbsp; &nbsp; 1.4.	Imprimir el mensaje: 4. Camiones de 4 ejes.</p>
              <p> &nbsp; &nbsp; 1.5.	Imprimir el mensaje: 5. Camiones de 5 ejes.</p>
              <p> &nbsp; &nbsp; 1.6.	Imprimir el mensaje: 6. Camiones de 6 ejes o más.</p>
              <p> &nbsp; &nbsp; 1.7.	Imprimir el mensaje: 7. Motos.</p>
              <p> &nbsp; &nbsp; 1.8.	Imprimir el mensaje: 8. Vehículo liviano con eje remolque.</p>
              <p> &nbsp; &nbsp; 1.9.	Imprimir el mensaje: Digite una opción.</p>
              <p> &nbsp; &nbsp; 1.10.	Leer el valor de la opción seleccionada, utilizando la variable ‘opcion’.</p>
              <p>2.	Si la opción seleccionada está entre los valores de 1 y 8.</p>
              <p> &nbsp; &nbsp; 2.1.	Leer el valor del número de vehículos, utilizando la variable ‘numVehiculos’.</p>
              
              <p>3.	Según sea el valor de la variable 'opcion', hacer:</p>
              <p> &nbsp; &nbsp; 3.1.	Caso 1: </p>
              <p> &nbsp; &nbsp; &nbsp; 3.1.1.	Calcular el costo del peaje por vehículo, según la Tarifa 1.</p>
              <p> &nbsp; &nbsp; &nbsp; 3.1.2.	Imprimir el costo del peaje.</p>
              <p> &nbsp; &nbsp; 3.2.	Caso 2:  </p>
              <p> &nbsp; &nbsp; &nbsp; 3.2.1.	Calcular el costo del peaje por vehículo, según la Tarifa 2.</p>
              <p> &nbsp; &nbsp; &nbsp; 3.2.2.	Imprimir el costo del peaje.</p>
              <p> &nbsp; &nbsp; 3.3.	Caso 3:  </p>
              <p> &nbsp; &nbsp; &nbsp; 3.3.1.	Calcular el costo del peaje por vehículo, según la Tarifa 3.</p>
              <p> &nbsp; &nbsp; &nbsp; 3.3.2.	Imprimir el costo del peaje.</p>
              <p> &nbsp; &nbsp; 3.4.	Caso 4:  </p>
              <p> &nbsp; &nbsp; &nbsp; 3.4.1.	Calcular el costo del peaje por vehículo, según la Tarifa 4.</p>
              <p> &nbsp; &nbsp; &nbsp; 3.4.2.	Imprimir el costo del peaje.</p>
              <p> &nbsp; &nbsp; 3.5.	Caso 5:  </p>
              <p> &nbsp; &nbsp; &nbsp; 3.5.1.	Calcular el costo del peaje por vehículo, según la Tarifa 5.</p>
              <p> &nbsp; &nbsp; &nbsp; 3.5.2.	Imprimir el costo del peaje.</p>
              <p> &nbsp; &nbsp; 3.6.	Caso 6:  </p>
              <p> &nbsp; &nbsp; &nbsp; 3.6.1.	Calcular el costo del peaje por vehículo, según la Tarifa 6.</p>
              <p> &nbsp; &nbsp; &nbsp; 3.6.2.	Imprimir el costo del peaje.</p>
              <p> &nbsp; &nbsp; 3.7.	Caso 7:  </p>
              <p> &nbsp; &nbsp; &nbsp; 3.7.1.	Calcular el costo del peaje por vehículo, según la Tarifa 7.</p>
              <p> &nbsp; &nbsp; &nbsp; 3.7.2.	Imprimir el costo del peaje.</p>
              <p> &nbsp; &nbsp; 3.8.	Caso 8: </p>
              <p> &nbsp; &nbsp; &nbsp; 3.8.1.	Calcular el costo del peaje por vehículo, según la Tarifa 8.</p>
              <p> &nbsp; &nbsp; &nbsp; 3.8.2.	Imprimir el costo del peaje.</p>
              <p> &nbsp; &nbsp; 3.9.	Caso por defecto: </p>
              <p> &nbsp; &nbsp; &nbsp; 3.9.1.	Imprimir el mensaje: Opción incorrecta.</p>
                      
                             
                                                               
              <h4><strong>D)   Implementación </strong></h4>
              <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. La Tabla 2.16.2 se muestra el código del programa en C/C++.
              <h5><strong>Tabla 2.16.2. </strong>Programa que calcula el consumo eléctrico.</h5>
              <pre><code [highlight]="prefTab[0].programa23"  [lineNumbers]="true"></code></pre><br>
              <h4><strong>E) Pruebas </strong></h4>
              <p>Desde la Tabla 2.16.3, hasta la Tabla 2.16.6, se muestran cuatro ejemplos de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
              <p>En la salida de la Tabla 2.16.3 se puede ver que, al seleccionar la opción 1 se puede ingresar el número de vehículos a pagar el peaje que en este caso es 3, obteniéndose el valor de $3 USD. De manera similar, en la salida de la Tabla 2.16.4 se puede ver que, al seleccionar la opción 4 se puede ingresar el número de vehículos a pagar el peaje que en este caso es 4, obteniéndose el valor de $16 USD. En la salida de la Tabla 2.16.5 se puede ver que, al seleccionar la opción 8 se puede ingresar el número de vehículos a pagar el peaje que en este caso es 1, obteniéndose el valor de $1 USD. Finalmente, en la salida Tabla 2.16.6 se puede ver que, al seleccionar la opción 9, el programa indica que es una opción incorrecta y no realiza ningún cálculo matemático.</p>
                            
              <h5><strong>Tabla 2.16.3. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a88.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.16.4. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a89.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.16.5. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a90.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 2.16.6. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a91.png" style="display:block; margin:auto; "><br>
              
              
            </mat-tab>
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Estructuras de Control Repetitivas o Bucles">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
              <mat-tab  label="Introducción">
                <ng-template matTabContent>
                  <br>
                  <h1>Estructuras de Control Repetitivas o Bucles</h1>
                  <p>La estructura de control conocida como bucle es aquella que realiza la repetición o iteración de acciones. La sentencia o grupos de sentencias que se repiten en un bloque se denominan cuerpo del bucle y cada repetición del cuerpo del bucle se llama iteración del bucle. Las principales sentencias de repetición son:
                  </p>
                  <ol type="a">
                    <li>La sentencia while </li>
                    <li>	La sentencia do-while </li>
                     <li>	La sentencia for </li>
                    <li>	Bucles anidados  </li> 
                  </ol>
                </ng-template>
              </mat-tab>
              <mat-tab  label="2.4.1. La sentencia while">
                <ng-template matTabContent>
                  <br><h1>La sentencia while()</h1>
                  <p>La sentencia while() crea un bucle que se repite hasta que la expresión lógica o condición del bucle se vuelva falsa. El cuerpo del bucle while() se ejecutará cero o más veces dependiendo de la condición del bucle. El formato de esta sentencia tiene la siguiente sintaxis:</p>
                  <p><b>Sintaxis 1:</b></p>
                  <pre><code align="left">while(Condición_Bucle)
      sentencia;</code></pre>
                    <table>
                      <tr VALIGN=top><td><code>Condición_Bucle</code></td>
                        <td>Expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva.</td></tr>
                        <tr VALIGN=top><td><code>sentencia</code></td>
                        <td>La sentencia o acción se ejecuta si la expresión lógica es verdadera dentro del bucle.</td></tr>
                    </table>
                    <br>
                    <table border="1" CELLPADDING=5 CELLSPACING=0>
                      <tr VALIGN=top><td width="50"><b> Nota:</b></td><td>  En esta sintaxis no es necesario utilizar llaves ya que se tiene una sola sentencia o instrucción.</td></tr>
                    </table>
                    <br>
                    <p><b>Sintaxis 2:</b></p>
                  <pre><code align="left">while(Condición_Bucle)
  &#65371;
        sentencia<sub>1</sub>;
        sentencia<sub>2</sub>;
        ...
        sentencia<sub>n</sub>;
  &#65373; 
  </code></pre>
                    <table>
                      <tr VALIGN=top><td><code>Condición_Bucle</code></td>
                        <td>Expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva.</td></tr>
                        <tr VALIGN=top><td><code>sentencia</code></td>
                        <td>Las acciones o sentencias se ejecutan si la expresión lógica es verdadera dentro del bucle.</td></tr>
                    </table>
                    <br>
                    <h4><b>Ejercicio 2.17: </b>Escribir un programa que permita imprimir de manera ascendente los números del 1 al 10 utilizando un bucle while().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en uno</td>
                        <td>i = 1;  </td>
                      </TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &gt;=10) &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Incrementar el valor del contador en uno.</td>
<td><pre>i++;
  &#65373; 
</pre> </td></TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.17: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_17"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.17 se puede ver la impresión del 1 al 10 de manera creciente.</p>
                    <h5><b>Ejecución 2.17 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.17.png" style="display:block; margin:auto; "><br>
                    <p>En la Tabla 2.17 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se incrementa en uno, mientras la condición del bucle sea verdadera.</p>
                    <h5><b>Tabla 2.17: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>1</td><td>1 &gt;=10 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>2</td><td>2 &gt;=10 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>3</td><td>3 &gt;=10 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>4</td><td>4 &gt;=10 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>5</td><td>5 &gt;=10 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>6</td><td>6 &gt;=10 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>7</td><td>7 &gt;=10 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>8</td><td>8 &gt;=10 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>9</td><td>9 &gt;=10 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>10</td><td>10 &gt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>11</td><td style="color:rgb(33, 15, 201)">11 &gt;=10 (F)</td><td> </td></tr>
                      
                    </table>
                    <br>
                    <h4><b>Ejercicio 2.18: </b>Escribir un programa que permita imprimir de manera descendente los números del 10 al 1 utilizando un bucle while().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en diez</td>
                        <td>i = 10;  </td>
                      </TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &lt;=1) &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Decrementar el valor del contador en uno.</td>
<td><pre>i--;
  &#65373; 
</pre> </td></TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.18: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_18"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.18 se puede ver la impresión del 10 al 1 de manera decreciente.</p>
                    <h5><b>Ejecución 2.18 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.18.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.18 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en uno, mientras la condición del bucle sea verdadera.</p>
                    <h5><b>Tabla 2.18: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &lt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>10</td><td>10 &lt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>9</td><td>9 &lt;=1 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>8</td><td>8 &lt;=1 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>7</td><td>7 &lt;=1 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>6</td><td>6 &lt;=1 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>5</td><td>5 &lt;=1 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>4</td><td>4 &lt;=1 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>3</td><td>3 &lt;=1 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>2</td><td>2 &lt;=1 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>1</td><td>1 &lt;=1 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>0</td><td style="color:rgb(33, 15, 201)">0 &lt;=1 (F)</td><td> </td></tr>
                      
                    </table><br>
                    <h4><b>Ejercicio 2.19: </b>Escribir un programa que permita imprimir de manera ascendente los números pares del 2 al 10 utilizando un bucle while().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en dos</td>
                        <td>i = 2;  </td>
                      </TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &gt;=1) &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Incrementar el valor del contador en dos.</td>
<td><pre>i=i+2;
  &#65373; 
</pre> </td></TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.19: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_19"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.19 se puede ver la impresión de los números pares del 2 al 10 de manera creciente.</p>
                    <h5><b>Ejecución 2.19 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.19.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.19 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se incrementa en dos, mientras la condición del bucle sea verdadera.
</p>
                    <h5><b>Tabla 2.19: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>2</td><td>2 &gt;=10 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>4</td><td>4 &gt;=10 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>6</td><td>6 &gt;=10 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>8</td><td>8 &gt;=10 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>10</td><td>10 &gt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>12</td><td>12 &gt;=10 (F)</td><td> </td></tr>                      
                    </table> <br>
 <h4><b>Ejercicio 2.20: </b>Escribir un programa que permita imprimir de manera descendente los números impares del 9 al 1 utilizando un bucle while().
</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en nueve</td>
                        <td>i = 9;  </td>
                      </TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &lt;=1) &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Decrementar el valor del contador en dos.</td>
<td><pre>i=i-2;
  &#65373; 
</pre> </td></TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.20: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_20"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.20 se puede ver la impresión del 9 al 1 de manera decreciente.
</p>
                    <h5><b>Ejecución 2.20 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.20.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.20 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en dos, mientras la condición del bucle sea verdadera.

</p>
                    <h5><b>Tabla 2.20: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=1</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>9</td><td>9 &gt;=1 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>7</td><td>7 &gt;=1 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>5</td><td>5 &gt;=1 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>3</td><td>3 &gt;=1 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>1</td><td>1 &gt;=1 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>-1</td><td>-1 &gt;=1 (F)</td><td> </td></tr>                      
                    </table> <br>
                    <h1><b>Caso de Estudio 2.17: Sumatoria y Promedio de un Grupo de Notas.</b></h1>
                    <h2><b>A) Problema</b></h2>
                    <p>Escribir un programa que permita calcular la sumatoria y el promedio de un grupo de notas leídas desde el teclado.</p>
                    <h2><b>B) Análisis</b></h2>
                    <p>Claramente se puede ver que las entradas del problema son el número de notas representada por la variable ‘n’ y el valor de una nota representada por la variable ‘nota’. Hay dos salidas requeridas que son la sumatoria de un grupo de notas representada por la variable ‘sum’ y el promedio de un grupo de notas representada por la variable ‘prom’. Se requiere un dato auxiliar que es el contador del bucle representado por la variable ‘i’. El requerimiento de los datos y las fórmulas requeridas se muestran a continuación. </p>
                    <h3><b>Requerimiento de los Datos</b></h3>
                    <p><b>Entradas del Programa</b></p>
                    <table>
                      <tr><td width="200">n</td><td width="200">/* Número de notas */</td></tr>
                      <tr><td width="200">nota</td><td width="200">/* Valor de una nota */</td></tr>
                    </table><br>
                    <p><b>Salidas del Problema</b></p>
                    <table>
                      <tr><td width="200">sum</td><td width="200">/* Sumatoria de un grupo de notas  */</td></tr>
                      <tr><td width="200">prom</td><td width="200">/* Media o promedio de un grupo de notas */</td></tr>
                     </table><br>
                    <p><b>Auxiliares del Problema</b></p>
                    <table>
                      <tr><td width="200">i</td><td width="200">/* Contador del bucle  */</td></tr>
                   </table><br>
                   <p><b>Fórmulas Relevantes</b></p>
                      <table>
                        <tr><td width="120"><em>sum = sum + valor </em></td><td width="30"> (1) </td><td width="280">/* Fórmula que representa el acumulador de una sumatoria */</td></tr>
                        <tr><td ><em>prom = <sup>sum</sup> / <sub>n</sub></em></td><td> (2) </td><td>/* Fórmula que calcula el promedio de un grupo de elementos en función del valor de la sumatoria  */</td></tr>
                      </table> <br>
                      <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.17.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘n’; la variable ‘nota’; b) Salidas: la variable ‘sum’; la variable ‘prom’; c) Auxiliares: el contador ‘i’.
</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.17.2.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.17.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                
		<p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Impresión de un mensaje de información.</li>
                  <li>Leer el valor del número de notas que se desea ingresar.</li>
		<li>Inicializar el valor del contador en uno.</li>
		<li>Inicializar el valor de la sumatoria en cero.</li>                  
		<li>Mientras el valor del contador ‘i’ sea menor o igual que cero, hacer:</li>
                  <ol type="1" start="5">
                    <li>1. Leer el valor de una nota.</li>
                  </ol><ol type="1" start="5">
                    <li>2. Asignar al acumulador de sumas ‘sum’ el valor que tiene acumulado más el valor de una nueva nota, utilizando la ecuación (1).</li>
                  </ol><ol type="1" start="5">
                    <li>3. Incrementar el valor del contador ‘i’ en uno.</li>
                  </ol>
                  <li>Calcular el valor del promedio de un grupo de notas, utilizando la ecuación (2).</li>
                  <li>Imprimir el valor de la sumatoria de un grupo de notas.</li>
                  
                  <li>Imprimir el valor del promedio de un grupo de notas.</li>
                </ol>
                
                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.17.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.17.1. </b>Programa que convierte un número decimal en un número binario.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_17_1"  [lineNumbers]="true"></code></pre> <br>
                <h2>E) Pruebas</h2>
                <p>En la Tabla 2.17.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <p>En la salida de la Tabla 2.17.2 se puede ver que, se solicita al usuario que ingrese el número de notas que para este ejemplo es 10. Luego, el usuario ingresa cada una de las 10 notas y el programa calcula la sumatoria y el promedio.</p>
		<h5><b>Tabla 2.17.2.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.17.2.png" style="display:block; margin:auto; "><br>
		<p>En la Tabla 2.17.3, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada ciclo del bucle while() se lee el valor de una nota y se suma en un acumulador el valor que tiene con el valor de una nueva nota ingresada desde el teclado y se incrementa en uno el valor del contador. Finalmente, la ejecución de la sentencia while() termina cuando la condición del bucle se hace falsa.</p>
               <h5><b>Tabla 2.17.2. </b>Prueba de escritorio del programa.</h5>

               <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                <tr style="color:red"><td>n</td><td>i</td><td>i &gt;=n</td><td>nota</td><td>sum</td><td>prom</td></tr>
                <tr><td>10</td><td>1</td><td>1 &gt;=10 (V)</td><td>11.8</td><td>0</td><td>13.983</td></tr>
                <tr><td></td><td>2</td><td>2 &gt;=10 (V)</td><td>12.6</td><td>0+11.8=11.8</td><td></td></tr>
                <tr><td></td><td>3</td><td>3 &gt;=10 (V)</td><td>16.5</td><td>11.8+12.6=24.4</td><td></td></tr>
                <tr><td></td><td>4</td><td>4 &gt;=10 (V)</td><td>18.03</td><td>24.4+16.5=40.9</td><td></td></tr>
                <tr><td></td><td>5</td><td>5 &gt;=10 (V)</td><td>14.8</td><td>40.9+18.03=58.93</td><td></td></tr>
                <tr><td></td><td>6</td><td>6 &gt;=10 (V)</td><td>10.3</td><td>58.93+14.8=73.73</td><td></td></tr>
                <tr><td></td><td>7</td><td>7 &gt;=10 (V)</td><td>7.4</td><td>73.73+10.3=84.03</td><td></td></tr>
                <tr><td></td><td>8</td><td>8 &gt;=10 (V)</td><td>17.6</td><td>84.03+7.4=91.43</td><td></td></tr>
                <tr><td></td><td>9</td><td>9 &gt;=10 (V)</td><td>16.2</td><td>91.43+1706=109.03</td><td></td></tr>
                <tr><td></td><td>10</td><td>10 &gt;=10 (V)</td><td>14.6</td><td>109.03+16.2=125.23</td><td></td></tr>
                <tr><td></td><td>11</td><td style="color:blue">11 &gt;=10 (F)</td><td>11.8</td><td>125.23+14.6=139.83</td><td></td></tr>
                        
              </table> <br>
              <h1><b>Caso de Estudio 2.18: Máximo Común Divisor y mínimo común múltiplo entre dos números.</b></h1>
              <h2><b>A) Problema</b></h2>
              <p>Escribir un programa que permita calcular el Máximo Común Divisor (MCD) y el mínimo común múltiplo (mcm) entre dos números enteros. Así, por ejemplo, el MCD entre 1032 y 180 es 12 y el mcm es 15480.</p>
              <h2><b>B) Análisis</b></h2>
              <p>Claramente se puede ver que las entradas del problema son dos números enteros. Hay dos salidas requeridas que son el MCD y el mcm. Se requieren tres datos auxiliares que son: el dividendo de la división, el divisor de la división y el residuo de la división. El proceso manual de cálculo del MCD se basa en el Algoritmo de Euclides donde se utilizan divisiones sucesivas para calcular los restos de las divisiones, donde en cada división resultante, el divisor obtenido pasa a ser el nuevo Dividendo y el Residuo obtenido pasa a ser el nuevo divisor, como se puede ver en la Figura 2.18.1.</p>
              <img src="./assets/images/Capitulos/II/media/Figura 2.18.1.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 2.18.1. </b>Divisiones sucesivas del Algoritmo de Euclides.</h5>
              <p>En la Tabla 2.18.1 se presenta el resumen de los resultados de los cocientes, Dividendos, divisores y Residuos de las divisiones sucesivas realizadas para calcular el MCD entre los números 1032 y 180.</p>
              <h5><b>Tabla 2.18.1. </b>Resumen de resultados del Algoritmo de Euclides.</h5>
            <table border="1" cellspacing="0" cellpadding="5">
              <tr><td>Cociente</td><td width="30"></td><td width="30">5</td><td width="30">1</td><td width="30">2</td><td width="30">1</td><td width="30">3</td><td width="30"></td></tr>
              <tr><td>Dividendos/Divisores</td><td>1032</td><td>180</td><td>132</td><td>48</td><td>36</td><td>12</td><td>0</td></tr>
              <tr><td>Restos</td><td>132</td><td>48</td><td>36</td><td>12</td><td>0</td><td></td><td></td></tr>
            </table>  <br>
            <p>En la solución computacional del MCD se cumple con el Algoritmo de Euclides donde se utiliza un bucle que controla las divisiones sucesivas, donde en cada división resultante, el divisor obtenido pasa a ser el nuevo Dividendo y el Residuo obtenido pasa a ser el nuevo divisor. El requerimiento de los datos y las fórmulas requeridas se muestran a continuación. </p>
            <h3><b>Requerimiento de los Datos</b></h3>
              <p><b>Entradas del Programa</b></p>
              		
		<table>
                  <tr><td width="200"> a </td><td width="200">/* primer número entero  */</td></tr>
                  <tr><td width="200"> b </td><td width="200">/* segundo número entero */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200"> MCD </td><td width="200">/* Máximo Común Divisor  */</td></tr>
                  <tr><td> mcm </td><td>/* mínimo común múltiplo */</td></tr>
                </table><br>
		<p><b>Auxiliares del Problema</b></p>
              <table>
                <tr><td width="200">D</td><td width="200">/* Dividendo de la división */</td></tr>
		<tr><td width="200">d</td><td width="200">/* divisor de la división */</td></tr>
		<tr><td width="200">R</td><td width="200">/* Residuo de la división */</td></tr>
             </table><br>
                <p><b>Fórmulas Relevantes</b></p>
                <table>
                  <tr><td width="120"><em>R=D MOD2 </em></td><td width="30"> (1) </td><td width="280">/* Fórmula que calcula el residuo de una división */</td></tr>
                  <tr><td ><em>mcm = <sup>a∙b</sup> / <sub>MCD</sub></em></td><td> (2) </td><td>/* Fórmula que calcula el mcm entre dos números ‘a’ y ‘b’ utilizando el MCD */</td></tr>
                </table> <br>

                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.18.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘a’; la variable ‘b’; b) Salidas: la variable ‘MCD’; la variable ‘mcm’; c) Auxiliares: la variable ‘D’; la variable ‘d’; la variable ‘R’.
</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.18.2.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.18.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                
			<p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el valor del primer número entero.</li>
                  <li>Leer el valor del segundo número entero.</li>
		<li>Asignar a la variable Dividendo el valor del primer número.</li>
		<li>Asignar a la variable divisor el valor del segundo número.</li>                  
		<li>Mientras el divisor sea diferente de cero, hacer:</li>
                  <ol type="1" start="5">
                    <li>1. Calcular el valor del Residuo entre el Dividendo y el divisor.</li>
                  </ol><ol type="1" start="5">
                    <li>2. Asignar a la variable Dividendo el valor del divisor.</li>
                  </ol><ol type="1" start="5">
                    <li>3. Asignar a la variable divisor el valor del Residuo.</li>
                  </ol>
                  <li>Asignar a la variable MCD el valor final del Dividendo.</li>
                  <li>Calcular el valor del mínimo común múltiplo.</li>
                   <li>Imprimir el valor del Máximo Común Divisor (MCD).</li>
                  <li>Imprimir el valor del mínimo común múltiplo (mcm).</li>
                </ol>


                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.18.2 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.18.2. </b>Programa que calcula el MCD y el mcm entre dos números.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_18_2"  [lineNumbers]="true"></code></pre> <br>
                <h2>E) Pruebas</h2>
                <p>En la Tabla 2.18.3, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <p>En la salida de la Tabla 2.18.3 se puede ver que, al ingresar el primer número que es 1032 y al ingresar el segundo número que es 180, se obtiene el valor del MCD que es 12 y el valor del mcm que es 15480.</p>
	            	<h5><b>Tabla 2.18.3.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.18.3.png" style="display:block; margin:auto; "><br>
            		<p>En la Tabla 2.18.4, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada división sucesiva el divisor de una división pasa a ser el nuevo Dividendo de la siguiente división y el Residuo de la división pasa a ser el nuevo divisor de la siguiente división. También, se puede comprobar que el MCD resultante es el valor final del Dividendo calculado y la ejecución de la sentencia while() termina cuando la condición del bucle se hace falsa.</p>
               <h5><b>Tabla 2.18.4. </b>Prueba de escritorio del programa.</h5>
            		<table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                <tr style="color:red"><td>a</td><td>b</td><td>D</td><td>D</td><td>d &lt; 0</td><td>R = D % d</td></tr>
                <tr><td>1032</td><td>180</td><td>1032</td><td>180</td><td>180 &lt; 0 (V)</td><td>132</td></tr>
	            	<tr><td></td><td></td><td>180</td><td>132</td><td>132 &lt; 0 (V)</td><td>48</td></tr>
            		<tr><td></td><td></td><td>132</td><td>48</td><td>48 &lt; 0 (V)</td><td>36</td></tr>
            		<tr><td></td><td></td><td>48</td><td>36</td><td>36 &lt; 0 (V)</td><td>12</td></tr>
                <tr><td></td><td></td><td>36</td><td>12</td><td>12 &lt; 0 (V)</td><td>0</td></tr>
                <tr><td></td><td></td><td>12</td><td>0</td><td style="color:blue">0 &lt;=0 (F)</td><td></td></tr>
                        
               </table> <br>
            </ng-template>
            </mat-tab>
            <mat-tab  label="2.4.2. La sentencia do-while">
              <ng-template matTabContent>
                <br>
                <h1>La sentencia do-while()</h1>
                <p>La sentencia do-while() crea un bucle que se repite hasta que la expresión lógica o condición del bucle se vuelva falsa. El cuerpo del bucle do-while() se ejecutará una o varias veces, pero al menos una vez, dependiendo de la condición del bucle. El formato de esta sentencia tiene la siguiente sintaxis:</p>
                <p><b>Sintaxis 1:</b></p>
                <pre><code align="left">
do
    sentencia;
while(Condición_Bucle);
</code></pre>
                  <table>
                    <tr VALIGN=top><td><code>Condición_Bucle</code></td>
                      <td>Expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva.</td></tr>
                      <tr VALIGN=top><td><code>sentencia</code></td>
                      <td>La sentencia o acción se ejecuta si la expresión lógica es verdadera dentro del bucle.</td></tr>
                  </table>
                  <br>
                  <table border="1" CELLPADDING=5 CELLSPACING=0>
                    <tr VALIGN=top><td width="50"><b> Nota:</b></td><td>  En esta sintaxis no es necesario utilizar llaves ya que se tiene una sola sentencia o instrucción.</td></tr>
                  </table>
                  <br>
                  <p><b>Sintaxis 2:</b></p>
                <pre><code align="left">
do
&#65371;
      sentencia<sub>1</sub>;
      sentencia<sub>2</sub>;
      ...
      sentencia<sub>n</sub>;
&#65373; while(Condición_Bucle);
</code></pre>
                  <table>
                    <tr VALIGN=top><td><code>Condición_Bucle</code></td>
                      <td>Expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva.</td></tr>
                      <tr VALIGN=top><td><code>sentencia</code></td>
                      <td>Las acciones o sentencias se ejecutan si la expresión lógica es verdadera dentro del bucle.</td></tr>
                  </table>
                  <br>
         
                  <h4><b>Ejercicio 2.21: </b>Escribir un programa que permita imprimir de manera ascendente los números del 1 al 10 utilizando un bucle do-while().</h4>
                  <br>
                  <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                    <TR>
                      <th width="10"> <b> N° </b> </th> 
                      <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                      <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                    </TR>
                    <TR> <td>1</td>  <td>entero : i</td>
                      <td>
                        <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                        i;</td>
                    </TR>
                    <TR>
                      <td>2</td>
                      <td>Inicializar el valor del contador en uno</td>
                      <td>i = 1;  </td>
                    </TR>
                    <TR><td>3</td> <td>Hacer:</td> 
                      <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">do </font>
                       &#65371;</td> </TR>
                    <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                      <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                        i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                     <TR><td>5</td><td>Incrementar el valor del contador en uno.</td> <td>i++; </td></TR>
    <TR><td>6</td><td>Mientras la condicion sea verdadera.</td><td>&#65373; 
    <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>(i &gt; 10);</td></TR>
                  </TABLE> <br>
                  <h5><b>Programa 2.21: </b>Código del programa</h5>
                  <pre><code [highlight]="prefTab2[0].programa2_21"  [lineNumbers]="true"></code></pre>
                  <p>En la salida de la Ejecución 2.21 se puede ver la impresión del 1 al 10 de manera creciente.</p>
                  <h5><b>Ejecución 2.21 </b>Salida del programa.</h5>
                  <img src="./assets/images/Capitulos/II/media/Ejecución 2.21.png" style="display:block; margin:auto; "><br>
                  <p>En la Tabla 2.21 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se incrementa en uno, mientras la condición del bucle sea verdadera.</p>
                  <h5><b>Tabla 2.21: </b>Prueba de escritorio del programa.</h5>
                  <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                    <tr style="color:red"><td>i</td><td>i &gt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                    <tr><td>1</td><td>1 &gt;=10 (V)</td><td>1 INTRO</td></tr>
                    <tr><td>2</td><td>2 &gt;=10 (V)</td><td>2 INTRO</td></tr>
                    <tr><td>3</td><td>3 &gt;=10 (V)</td><td>3 INTRO</td></tr>
                    <tr><td>4</td><td>4 &gt;=10 (V)</td><td>4 INTRO</td></tr>
                    <tr><td>5</td><td>5 &gt;=10 (V)</td><td>5 INTRO</td></tr>
                    <tr><td>6</td><td>6 &gt;=10 (V)</td><td>6 INTRO</td></tr>
                    <tr><td>7</td><td>7 &gt;=10 (V)</td><td>7 INTRO</td></tr>
                    <tr><td>8</td><td>8 &gt;=10 (V)</td><td>8 INTRO</td></tr>
                    <tr><td>9</td><td>9 &gt;=10 (V)</td><td>9 INTRO</td></tr>
                    <tr><td>10</td><td>10 &gt;=10 (V)</td><td>10 INTRO</td></tr>
                    <tr><td>11</td><td style="color:rgb(33, 15, 201)">11 &gt;=10 (F)</td><td> </td></tr>
                    
                  </table>
                  <br>
                  <h4><b>Ejercicio 2.22: </b>Escribir un programa que permita imprimir de manera descendente los números del 10 al 1 utilizando un bucle do-while().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en diez</td>
                        <td>i = 10;  </td>
                      </TR>
                      <TR><td>3</td> <td>Hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">do </font>&#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Decrementar el valor del contador en uno.</td><td>i--;</td></TR>
			<TR><td>6</td> <td>Mientras la condición sea verdadera</td> 
			<td>&#65373;<font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &lt;=1); </td> </TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.22: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_22"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.22 se puede ver la impresión del 10 al 1 de manera decreciente.</p>
                    <h5><b>Ejecución 2.22 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.22.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.22 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en uno, mientras la condición del bucle sea verdadera.</p>
                    <h5><b>Tabla 2.22: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &lt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>10</td><td>10 &lt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>9</td><td>9 &lt;=1 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>8</td><td>8 &lt;=1 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>7</td><td>7 &lt;=1 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>6</td><td>6 &lt;=1 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>5</td><td>5 &lt;=1 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>4</td><td>4 &lt;=1 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>3</td><td>3 &lt;=1 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>2</td><td>2 &lt;=1 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>1</td><td>1 &lt;=1 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>0</td><td style="color:rgb(33, 15, 201)">0 &lt;=1 (F)</td><td> </td></tr>
                      
                    </table><br>
                    <h4><b>Ejercicio 2.23: </b>Escribir un programa que permita imprimir de manera ascendente los números pares del 2 al 10 utilizando un bucle do-while().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en dos</td>
                        <td>i = 2;  </td>
                      </TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">do </font>
                          &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Incrementar el valor del contador en dos.</td>
			<td>i=i+2; </td></TR>
			<TR><td>6</td> <td>Mientras la condición sea verdadera</td> 
                        <td>&#65373; <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &gt;=10);</td> </TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.23: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_23"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.23 se puede ver la impresión de los números pares del 2 al 10 de manera creciente.</p>
                    <h5><b>Ejecución 2.23 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.23.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.23 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se incrementa en dos, mientras la condición del bucle sea verdadera.
</p>
                    <h5><b>Tabla 2.23: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>2</td><td>2 &gt;=10 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>4</td><td>4 &gt;=10 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>6</td><td>6 &gt;=10 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>8</td><td>8 &gt;=10 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>10</td><td>10 &gt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>12</td><td>12 &gt;=10 (F)</td><td> </td></tr>                      
                    </table> <br>   
                  <h4><b>Ejercicio 2.24: </b>Escribir un programa que permita imprimir de manera descendente los números impares del 9 al 1 utilizando un bucle do-while().
</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR><td>2</td><td>Inicializar el valor del contador en nueve</td><td>i = 9;  </td></TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">do </font>
                        &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Decrementar el valor del contador en dos.</td><td>i=i-2;</td></TR>
			<TR><td>6</td> <td>Mientras la condición sea verdadera.</td> 
                        <td>&#65373; <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &lt;=1);</td> </TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.24: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_24"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.24 se puede ver la impresión del 9 al 1 de manera decreciente.
</p>
                    <h5><b>Ejecución 2.24 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.24.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.24 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en dos, mientras la condición del bucle sea verdadera.

</p>
                    <h5><b>Tabla 2.24: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &lt;=1</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>9</td><td>9 &gt;=1 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>7</td><td>7 &gt;=1 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>5</td><td>5 &gt;=1 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>3</td><td>3 &gt;=1 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>1</td><td>1 &gt;=1 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>-1</td><td>-1 &gt;=1 (F)</td><td> </td></tr>                      
                    </table> <br>
                    <h4><b>Ejercicio 2.24: </b>Escribir un programa que permita imprimir de manera descendente los números impares del 9 al 1 utilizando un bucle do-while().
                    </h4>
                    <br>
                                        <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                                          <TR>
                                            <th width="10"> <b> N° </b> </th> 
                                            <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                                            <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                                          </TR>
                                          <TR> <td>1</td>  <td>entero : i</td>
                                            <td>
                                              <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                                              i;</td>
                                          </TR>
                                          <TR><td>2</td><td>Inicializar el valor del contador en nueve</td><td>i = 9;  </td></TR>
                                          <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                                            <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">do </font>
                                            &#65371;</td> </TR>
                                          <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                                            <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                                              i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                                           <TR><td>5</td><td>Decrementar el valor del contador en dos.</td><td>i=i-2;</td></TR>
                          <TR><td>6</td> <td>Mientras la condición sea verdadera.</td> 
                                            <td>&#65373; <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                                              (i &lt;=1);</td> </TR>
                                        </TABLE> <br>
                                        <h5><b>Programa 2.24: </b>Código del programa</h5>
                                        <pre><code [highlight]="prefTab2[0].programa2_24"  [lineNumbers]="true"></code></pre>
                                        <p>En la salida de la Ejecución 2.24 se puede ver la impresión del 9 al 1 de manera decreciente.
                    </p>
                                        <h5><b>Ejecución 2.24 </b>Salida del programa.</h5>
                                        <img src="./assets/images/Capitulos/II/media/Ejecución 2.24.png" style="display:block; margin:auto; "><br>
                     <p>En la Tabla 2.24 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en dos, mientras la condición del bucle sea verdadera.
                    
                    </p>
                                        <h5><b>Tabla 2.24: </b>Prueba de escritorio del programa.</h5>
                                        <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                                          <tr style="color:red"><td>i</td><td>i &gt;=1</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                                          <tr><td>9</td><td>9 &gt;=1 (V)</td><td>9 INTRO</td></tr>
                                          <tr><td>7</td><td>7 &gt;=1 (V)</td><td>7 INTRO</td></tr>
                                          <tr><td>5</td><td>5 &gt;=1 (V)</td><td>5 INTRO</td></tr>
                                          <tr><td>3</td><td>3 &gt;=1 (V)</td><td>3 INTRO</td></tr>
                                          <tr><td>1</td><td>1 &gt;=1 (V)</td><td>1 INTRO</td></tr>
                                          <tr><td>-1</td><td>-1 &gt;=1 (F)</td><td> </td></tr>                      
                                        </table> <br>
                     <h1><b>Caso de Estudio 2.19: Conversión de Decimal a Binario.</b></h1>
              <h2><b>A) Problema</b></h2>
              <p>Escribir un programa que permita convertir un número en sistema decimal o base 10 a sistema binario o base 2, utilizando divisiones sucesivas. Así, por ejemplo, el número 233 en binario es 11101001.</p>
              <h2><b>B) Análisis</b></h2>
              <p>Claramente se puede ver que la entrada del problema es el número decimal. Hay una sola salida requerida que es el número binario o en base dos. Se requieren cinco datos auxiliares que son: el dividendo de la división, el cociente de la división, el residuo de la división, una sumatoria para acumular valores y un contador para las potencias de 10. El proceso manual de cálculo de conversión de un número decimal a binario se basa en divisiones sucesivas y los restos obtenidos de abajo hacia arriba generan el número binario como se puede ver en la Figura 2.19.1.
</p>
              <img src="./assets/images/Capitulos/II/media/Figura 2.19.1.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 2.19.1. </b>Proceso manual de cálculo de un número binario.</h5>
             
 <p>En la solución computacional del número binario hay un bucle que controla las divisiones sucesivas, que permiten obtener los restos de las divisiones que se acumulan en una sumatoria que acumula los resultados parciales del producto del residuo por 10 elevado a una potencia de ‘n’ y un contador que controla los valores de la potencia de ‘n’. De manera sucesiva el resultado del cociente de una división pasa a ser el dividendo de la siguiente división, asignando a la variable dividendo el valor del cociente en cada iteración del bucle. Finalmente, el valor de la sumatoria obtenida viene a ser el valor del número binario calculado, como se puede ver en la Figura 2.19.2. El requerimiento de los datos y las fórmulas requeridas se muestran a continuación. 
</p>              <img src="./assets/images/Capitulos/II/media/Figura 2.19.2.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 2.19.2. </b>Solución computacional del número binario.</h5>
    
	<h3><b>B.1) Requerimiento de los Datos</b></h3>
              <p><b>Entradas del Programa</b></p>
              		
		<table>
                  <tr><td width="200"> num </td><td width="200">/* número en sistema decimal o base 10  */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200"> bin </td><td width="200">/* número en binario o base 2 */</td></tr>
                </table><br>
		<p><b>Auxiliares del Problema</b></p>
              <table>
                <tr><td width="200">D</td><td width="200">/* Dividendo de la división */</td></tr>
		<tr><td width="200">c</td><td width="200">/* cociente de la división */</td></tr>
		<tr><td width="200">R</td><td width="200">/* Residuo de la división */</td></tr>
<tr><td width="200">sum</td><td width="200">/* sumatoria */</td></tr>
<tr><td width="200">i</td><td width="200">/* contador */</td></tr>
             </table><br>
                <p><b>Fórmulas Relevantes</b></p>
                <table>
		<tr><td ><em>c = <sup>D</sup> / <sub>2</sub></em></td><td> (2) </td><td>/* Fórmula que calcula el cociente de una división */</td></tr>
                <tr><td width="120"><em>R=D MOD2 </em></td><td width="30"> (1) </td><td width="280">/* Fórmula que calcula el residuo de una división */</td></tr>
                  <tr><td ><em>sum = sum + R∙10<sup>n</sup> </em></td><td> (2) </td><td>/* Fórmula que acumula el valor de una sumatoria más el producto entre el residuo por 10 elevado a la potencia de n */</td></tr>
                </table> <br>

                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>
En la Figura 2.19.3 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘num’; b) Salidas: la variable ‘bin’; c) Auxiliares: la variable ‘D’; la variable ‘c’; la variable ‘R’; la variable ‘sum’; la variable ‘i’.

</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.19.3.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.19.3. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                
			<p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el valor del número decimal.</li>
                  <li>Asignar a la variable Dividendo el valor del número decimal.</li>
		<li>Inicializar la variable sumatoria con el valor de cero.</li>
		<li>Inicializar el contador ‘i’ con el valor de cero.</li>                  
		<li>Hacer:</li>
                  <ol type="1" start="5">
                    <li>1. Calcular el valor del cociente entre el Dividendo y el valor de 2.</li>
                  </ol><ol type="1" start="5">
                    <li>2. Calcular el valor del Residuo entre el Dividendo y el valor de 2.</li>
                  </ol><ol type="1" start="5">
                    <li>3. Asignar a la sumatoria el valor que tiene acumulado más el producto entre el Residuo con el valor de 10 elevado a la potencia de ‘i’.</li>
                  </ol><ol type="1" start="5">
                    <li>4. Asignar a la variable Dividendo el valor del cociente.</li>
                  </ol><ol type="1" start="5">
                    <li>5. Incrementar el valor del contador ‘i’ en uno.</li>
			Mientras el cociente de la división sea diferente de cero.
                  </ol>
                  <li>Asignar a la variable ‘bin’ el valor de la sumatoria que corresponde al número binario calculado.</li>
                  <li>Imprimir el valor del número binario.</li>
                </ol>

                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.19.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.19.1. </b>Programa que convierte un número decimal en un número binario.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_19_1"  [lineNumbers]="true"></code></pre> <br>
                <h2>E) Pruebas</h2>
                <p>En la Tabla 2.19.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <p>En la salida de la Tabla 2.19.2 se puede ver que, al ingresar el número 233 en sistema de numeración decimal, se obtiene el número 11101001 en sistema de numeración binario.</p>
	            	<h5><b>Tabla 2.19.2.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.19.2.png" style="display:block; margin:auto; "><br>
            		<p>En la Tabla 2.19.3, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada división sucesiva el cociente de una división pasa a ser el dividendo de la siguiente división. También, se puede comprobar que el resultado de la sumatoria es el número binario calculado y la ejecución de la sentencia do-while() termina cuando la condición del bucle se hace falsa.
</p>
               <h5><b>Tabla 2.19.3. </b>Prueba de escritorio del programa.</h5>
               <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                <tr style="color:red"><td>num</td><td>D</td><td>Sum</td><td>i</td><td>c</td><td>R</td><td>c! = 0</td></tr>
                <tr><td>233</td><td>233</td><td>0</td><td>0</td><td></td><td></td><td></td></tr>
	            	<tr><td></td><td>116</td><td>0+1&#88;10<sup>0</sup>=1</td><td>1</td><td>116</td><td>1</td><td>116 != 0 (V)</td></tr>
            		<tr><td></td><td>58</td><td>1+0&#88;10<sup>1</sup>=1</td><td>2</td><td>58</td><td>0</td><td>58 != 0 (V)</td></tr>
            		<tr><td></td><td>29</td><td>1+0&#88;10<sup>2</sup>=1</td><td>3</td><td>29</td><td>0</td><td>29 != 0 (V)</td></tr>
                <tr><td></td><td>14</td><td>1+1&#88;10<sup>3</sup>=1001</td><td>4</td><td>14</td><td>1</td><td>14 != 0 (V)</td></tr>
                <tr><td></td><td>7</td><td>1001+0&#88;10<sup>4</sup>=1001</td><td>5</td><td>7</td><td>0</td><td>7 != 0 (V)</td></tr>
                <tr><td></td><td>3</td><td>1001+1&#88;10<sup>5</sup>=101001</td><td>6</td><td>3</td><td>1</td><td>3 != 0 (V)</td></tr>
                <tr><td></td><td>1</td><td>101001+1&#88;10<sup>6</sup>=1101001</td><td>7</td><td>1</td><td>1</td><td>1 != 0 (V)</td></tr>
                <tr><td></td><td>0</td><td>1101001+1&#88;10<sup>7</sup>=11101001</td><td>8</td><td>0</td><td>1</td><td style="color:blue">0! = 0 (F)</td></tr>    
               </table> <br>

               <h1><b>Caso de Estudio 2.20: Análisis de Números Palíndromos.</b></h1>
               <h2><b>A) Problema</b></h2>
               <p>Escribir un programa que permita analizar si un número es palíndromo o no lo es. Un número palíndromo es aquel número que invertido o dado la vuelta resulta ser el mismo número. Así, por ejemplo, los números 1234321, 55555, 333, son números palíndromos. Analizar además el número de cifras que tiene el número, visualizar el número original al revés y desplegar un mensaje donde se mencione si el número ingresado por teclado es o no palíndromo.
 
 </p>
               <h2><b>B) Análisis</b></h2>
               <p>Claramente se puede ver que la entrada del problema es un número entero. Hay dos salidas requeridas que son el número de cifras del número y el número original invertido. Se requieren seis datos auxiliares que son: un contador de cifras para el número, el dividendo de la división, el cociente de la división, el residuo de la división, una sumatoria para acumular valores y un contador para las potencias de 10. 
 </p>
     <p>En la solución computacional de análisis de un número palíndromo se plantea primeramente un bucle que cuenta el número de cifras del número entero leído desde el teclado, como se puede ver en la Figura 2.20.1.
 </p>
               <img src="./assets/images/Capitulos/II/media/Figura 2.20.1.png" style="display:block; margin:auto; "><br>
               <h5 style="text-align:center"><b>Figura 2.20.1. </b>Proceso para contar el número de cifras de un número entero.</h5>
              
  <p>Luego, hay un bucle que controla las divisiones sucesivas, que permiten obtener los restos de las divisiones que se acumulan en una sumatoria que acumula los resultados parciales del producto del residuo por 10 elevado a una potencia de ‘n’ y un contador que controla los valores de la potencia de ‘n’. Antes de ingresar a este bucle, el contador se inicializa con el valor del número de cifras menos el valor de uno. De manera sucesiva, el resultado del cociente de una división pasa a ser el dividendo de la siguiente división, asignando a la variable dividendo el valor del cociente en cada iteración del bucle. Finalmente, el valor de la sumatoria obtenida viene a ser el valor del número invertido calculado, como se puede ver en la Figura 2.20.2. El requerimiento de los datos y las fórmulas requeridas se muestran a continuación.
 </p>              <img src="./assets/images/Capitulos/II/media/Figura 2.20.2.png" style="display:block; margin:auto; "><br>
               <h5 style="text-align:center"><b>Figura 2.20.2. </b>Proceso para invertir un número entero.</h5>
     
   <h3><b>B.1) Requerimiento de los Datos</b></h3>
               <p><b>Entradas del Programa</b></p>
                   
     <table>
                   <tr><td width="200"> num </td><td width="200">/* número entero original  */</td></tr>
                 </table><br>
                 <p><b>Salidas del Problema</b></p>
                 <table>
                   <tr><td width="200"> numeroCifras </td><td width="200">/* número de cifras decimales del entero  */</td></tr>
                   <tr><td width="200"> numInvertido </td><td width="200">/* número entero invertido */</td></tr>
                   <tr><td width="200"> Mensaje </td><td width="200">/* que indica que el número ingresado es palíndromo o no es palíndromo */</td></tr>
                 </table><br>
     <p><b>Auxiliares del Problema</b></p>
               <table>
                 <tr><td width="200">cont</td><td width="200">/* contador de cifras decimales de un entero */</td></tr>
     <tr><td width="200">D</td><td width="200">/* Dividendo de la división */</td></tr>
     <tr><td width="200">c</td><td width="200">/* cociente de la división */</td></tr>
     <tr><td width="200">R</td><td width="200">/* Residuo de la división */</td></tr>
     <tr><td width="200">sum</td><td width="200">/* sumatoria */</td></tr>
     <tr><td width="200">i</td><td width="200">/* contador */</td></tr>
              </table><br>
                 <p><b>Fórmulas Relevantes</b></p>
                 <table>
     <tr><td ><em>c = <sup>D</sup> / <sub>10</sub></em></td><td> (2) </td><td>/* Fórmula que calcula el cociente de una división */</td></tr>
                 <tr><td width="120"><em>R=D MOD2 </em></td><td width="30"> (1) </td><td width="280">/* Fórmula que calcula el residuo de una división */</td></tr>
                   <tr><td ><em>sum = sum + R∙10<sup>n</sup> </em></td><td> (2) </td><td>/* Fórmula que acumula el valor de una sumatoria más el producto entre el residuo por 10 elevado a la potencia de n */</td></tr>
                 </table> <br>
 
                 <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                 <p>En la Figura 2.20.3 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘num’; b) Salidas: la variable ‘numeroCifras’; la variable ‘numInvertido’; un mensaje de información que indica que el número ingresado es palíndromo o no es palíndromo; c) Auxiliares: la variable ‘cont’; la variable ‘D’; la variable ‘c’; la variable ‘R’; la variable ‘sum’; la variable ‘i’.
 </p>
                 <img src="./assets/images/Capitulos/II/media/Figura 2.20.3.png" style="display:block; margin:auto; "><br>
                 <h5 style="text-align:center"><b>Figura 2.20.3. </b>Diagrama de Entrada-Salida del Programa.</h5>
                 <h2><b>C) Diseño</b></h2>
                 <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                 
       <p><b>Algoritmo</b></p>
                 <ol type="1">
                   <li>Imprimir el mensaje de información: Analizar si un número es palíndromo.</li>
                   <li>Leer el valor de un número entero.</li>
     <li>Asignar a la variable Dividendo el valor del número entero.</li>
     <li>Inicializar el contador ‘cont’ con el valor de cero.</li>                  
     <li>Hacer:</li>
                   <ol type="1" start="5">
                     <li>1. Calcular el valor del cociente entre el Dividendo y el valor de 10.</li>
                   </ol><ol type="1" start="5">
                     <li>2. Calcular el valor del Residuo entre el Dividendo y el valor de 10.</li>
                   </ol><ol type="1" start="5">
                     <li>3. Asignar a la variable Dividendo el valor del cociente.</li>
                   </ol><ol type="1" start="5">
                     <li>4. Incrementar el valor del contador ‘i’ en uno.</li>
     Mientras el cociente de la división sea diferente de cero.
                   </ol>
                   <li>Asignar a la variable 'numeroCifras' el valor del contador 'cont' que corresponde al valor del número de cifras del número entero ingresado.</li>
     <li>Imprimir el número de cifras del número entero ingresado por teclado.</li>
     <li>Asignar a la variable Dividendo el valor del número entero.</li>
     <li>Inicializar la variable sumatoria con el valor de cero.</li>
     <li>Inicializar el contador 'i' con el valor del número de cifras menos uno.</li>
     <li>Hacer:</li>
                   <ol type="1" start="11">
                     <li>1. Calcular el valor del cociente entre el Dividendo y el valor de 10.</li>
                   </ol><ol type="1" start="11">
                     <li>2. Calcular el valor del Residuo entre el Dividendo y el valor de 10.</li>
                   </ol><ol type="1" start="11">
                     <li>3. 11.3.	Asignar a la sumatoria el valor que tiene acumulado ás el producto entre el Residuo con el valor de 10 elevado a la potencia de ‘i’.</li>
                   </ol><ol type="1" start="11">
                     <li>4. Asignar a la variable Dividendo el valor del cociente.</li>
                   </ol><ol type="1" start="11">
                     <li>5. Decrementar el valor del contador ‘i’ en uno.</li>
      Mientras el cociente de la división sea diferente de cero.
                   </ol>
     <li>Asignar a la variable 'numInvertido' el valor de la sumatoria 'sum' que corresponde al valor del número entero invertido.</li>                  
     <li>Imprimir el número entero invertido.</li>
     <li>Si el valor de la variable 'num' que tiene el valor del número entero original es igual al valor de la variable 'numInvertido' que tiene el valor del número entero invertido.</li>
     <ol type="1" start="14">
                     <li>1. Imprimir el mensaje: El número ingresado es palíndromo.</li>
                   </ol>
     <li>Caso contrario, el valor de la variable 'num' es diferente del valor de la variable 'numInvertido'.</li>
     <ol type="1" start="15">
                     <li>1. Imprimir el mensaje: El número ingresado no es palíndromo.</li>
                   </ol>
                 </ol>
 
                 <h2><b>D) Implementación</b></h2>
                 <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.20.1 se muestra el código del programa en C/C++.</p>
                 <h5><b>Tabla 2.19.1. </b>Programa que analiza si un número leído es palíndromo.</h5>
                 <pre><code [highlight]="prefTab2[0].tabla2_20_1"  [lineNumbers]="true"></code></pre> <br>
                 <h2>E) Pruebas</h2>
                 <p>En la Tabla 2.20.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                 <p>En la salida de la Tabla 2.20.2 se puede ver que, al ingresar el número 55555, el programa indica que este número tiene 5 cifras decimales. Luego, se obtiene el número invertido que en este caso resulta ser el mismo número, y por lo tanto el número ingresado es palíndromo.
 </p>
                 <h5><b>Tabla 2.20.2.</b> Salida del programa</h5>
                 <img src="./assets/images/Capitulos/II/media/Tabla 2.20.2.png" style="display:block; margin:auto; "><br>
                 <p>En la Tabla 2.20.3, se muestra la prueba de escritorio del primer bucle do-while() del programa que cuenta el número de cifras que tiene el número ingresado por el teclado que en este caso es el número 55555 cuyo número de cifras es 5.  
 </p>
                <h5><b>Tabla 2.20.3. </b>Prueba de escritorio del programa del primer bucle do-while() del programa.</h5>
                 <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                 <tr style="color:red"><td>num</td><td>D</td><td>cont</td><td>C</td><td>c!=0</td></tr>
                 <tr><td>55555</td><td>55555</td><td>0</td><td></td><td></td></tr>
                 <tr><td></td><td>5555</td><td>1</td><td>5555</td><td>5555 != 0 (V)</td></tr>
                  <tr><td></td><td>555</td><td>2</td><td>555</td><td>555 != 0 (V)</td></tr>
                  <tr><td></td><td>55</td><td>3</td><td>55</td><td>55 != 0 (V)</td></tr>
                  <tr><td></td><td>5</td><td>4</td><td>5</td><td>5 != 0 (V)</td></tr>
                  <tr><td></td><td>0</td><td>5</td><td>0</td><td style="color:rgb(33, 15, 201)">0!= 0 (F)</td></tr>
                </table> <br>
                <p>En la Tabla 2.20.4, se muestra la prueba de escritorio del segundo bucle do-while() del programa que invierte el número original que es el 55555 y se obtiene nuevamente el mismo número 55555. En cada división sucesiva el cociente de una división pasa a ser el dividendo de la siguiente división. También, se puede comprobar que el resultado de la sumatoria es el número invertido calculado mediante la suma de cada residuo multiplicado por una potencia de diez comenzando con la potencia igual al número de cifras menos uno hasta llegar al valor de cero. Finalmente, la ejecución de la sentencia do-while() termina cuando la condición del bucle se hace falsa. En este caso el número 55555 resulta ser palíndromo.</p>
                <h5><b>Tabla 2.20.4. </b>Prueba de escritorio del programa del segundo bucle do-while() del programa.</h5>
                <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                <tr style="color:red"><td>num</td><td>D</td><td>Sum</td><td>i</td><td>C</td><td>R</td><td>c!=0</td></tr>
                <tr><td>55555</td><td>55555</td><td>0</td><td>4</td><td></td><td></td><td></td></tr>
                <tr><td></td><td>5555</td><td>0+50&#88;10<sup>4</sup>=50000</td><td>3</td><td>5555</td><td>5</td><td>5555 != 0 (V)</td></tr>
                 <tr><td></td><td>555</td><td>50000+5&#88;10<sup>3</sup>=55000</td><td>2</td><td>555</td><td>5</td><td>555 != 0 (V)</td></tr>
                 <tr><td></td><td>55</td><td>55000+5&#88;10<sup>2</sup>=55500</td><td>1</td><td>55</td><td>5</td><td>55 != 0 (V)</td></tr>
                 <tr><td></td><td>5</td><td>55500+5&#88;10<sup>1</sup>=55550</td><td>0</td><td>5</td><td>5</td><td>5 != 0 (V)</td></tr>
                 <tr><td></td><td>0</td><td>55550+5&#88;10<sup>0</sup>=55555</td><td>-1</td><td>0</td><td></td><td style="color:rgb(33, 15, 201)">0!= 0 (F)</td></tr>
               </table> <br>
               <p>En la Tabla 2.20.5, se muestra otro ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
              <p>En la salida de la Tabla 2.20.5 se puede ver que, al ingresar el número 1234, el programa indica que este número tiene 4 cifras decimales. Luego, se obtiene el número invertido que en este caso no resulta ser el mismo número, y por lo tanto el número ingresado no es palíndromo.</p>
            
            


              
              <h5><b>Tabla 2.20.5.</b> Salida del programa</h5>
              <img src="./assets/images/Capitulos/II/media/Tabla 2.20.5.png" style="display:block; margin:auto; "><br>
             <p>En la Tabla 2.20.6, se muestra la prueba de escritorio del primer bucle do-while() del programa que cuenta el número de cifras que tiene el número ingresado por el teclado que en este caso es el número 1234 cuyo número de cifras es 4.  </p>
             <h5><b>Tabla 2.20.6. </b>Prueba de escritorio del programa del primer bucle do-while() del programa.</h5>
              <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
              <tr style="color:red"><td>num</td><td>D</td><td>cont</td><td>C</td><td>c!=0</td></tr>
              <tr><td>1234</td><td>1234</td><td>0</td><td></td><td></td></tr>
              <tr><td></td><td>123</td><td>1</td><td>123</td><td>123 != 0 (V)</td></tr>
               <tr><td></td><td>12</td><td>2</td><td>12</td><td>12 != 0 (V)</td></tr>
               <tr><td></td><td>1</td><td>3</td><td>1</td><td>1 != 0 (V)</td></tr>
               <tr><td></td><td>0</td><td>4</td><td>0</td><td style="color:rgb(33, 15, 201)">0!= 0 (F)</td></tr>
             </table> <br>
             <p>En la Tabla 2.20.7, se muestra la prueba de escritorio del segundo bucle do-while() del programa que invierte el número original que es el número 1234 y se obtiene el número invertido 4321. En cada división sucesiva el cociente de una división pasa a ser el dividendo de la siguiente división. También, se puede comprobar que el resultado de la sumatoria es el número invertido calculado mediante la suma de cada residuo multiplicado por una potencia de diez comenzando con la potencia igual al número de cifras menos uno hasta llegar al valor de cero. Finalmente, la ejecución de la sentencia do-while() termina cuando la condición del bucle se hace falsa. En este caso el número 1234 resulta no ser palíndromo.</p>
             <h5><b>Tabla 2.20.7. </b>Prueba de escritorio del programa del segundo bucle do-while() del programa.</h5>
             <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
             <tr style="color:red"><td>num</td><td>D</td><td>Sum</td><td>i</td><td>C</td><td>R</td><td>c!=0</td></tr>
             <tr><td>1234</td><td>1234</td><td>0</td><td>3</td><td></td><td></td><td></td></tr>
             <tr><td></td><td>123</td><td>0+4&#88;10<sup>3</sup>=4000</td><td>2</td><td>123</td><td>4</td><td>5555 != 0 (V)</td></tr>
              <tr><td></td><td>12</td><td>4000+3&#88;10<sup>2</sup>=4300</td><td>1</td><td>12</td><td>3</td><td>555 != 0 (V)</td></tr>
              <tr><td></td><td>1</td><td>4300+2&#88;10<sup>1</sup>=4320</td><td>0</td><td>1</td><td>2</td><td>55 != 0 (V)</td></tr>
              <tr><td></td><td>0</td><td>4320+1&#88;10<sup>0</sup>=4321</td><td>-1</td><td>0</td><td>1</td><td style="color:rgb(33, 15, 201)">0!= 0 (F)</td></tr>
            </table> <br>
            
            </ng-template>
            </mat-tab>

            <mat-tab  label="2.4.3. La sentencia for">
              <ng-template matTabContent>
                <br><h1>La sentencia for()</h1>
                <p>El bucle for() es el bucle más potente que tiene el lenguaje C/C++, ya que agrupa en un solo lugar tres acciones: a) inicializar uno o varios contadores; b) manejar una expresión lógica y c) incrementar o decrementar el contador o contadores. Este bucle es ideal para implementar bucles controlados por contador que son bucles en los que un conjunto de sentencias se ejecuta una vez por cada valor de un rango especificado, de acuerdo al algoritmo que resuelve un problema. El formato de esta sentencia tiene la siguiente sintaxis:</p>

                <p><b>Sintaxis 1:</b></p>
<pre><code align="left">for(Inicialización; Condición_Bucle; Incremento/Decremento) 
      sentencia;</code></pre>
                    <table>
                      <tr VALIGN=top><td><code>Inicialización</code></td>
                        <td>Sección donde se inicializan las variables de control del bucle.</td></tr>
                        
                      <tr VALIGN=top><td><code>Condición_Bucle</code></td>
                        <td>Sección que contiene una expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva, mientras sea verdadera.</td></tr>
                        <tr VALIGN=top><td><code>Incremento/Decremento</code></td>
                          <td>Sección donde se incrementan o se decrementan las variables de control del bucle.</td></tr>
                      <tr VALIGN=top><td><code>sentencia</code></td>
                        <td>La sentencia o acción se ejecuta si la expresión lógica es verdadera dentro del bucle.</td></tr>
                    </table>
                    <br>
                    <table border="1" CELLPADDING=5 CELLSPACING=0>
                      <tr VALIGN=top><td width="50"><b> Nota:</b></td><td>  En esta sintaxis no es necesario utilizar llaves ya que se tiene una sola sentencia o instrucción.</td></tr>
                    </table>
                    <br>
                    <p><b>Sintaxis 2:</b></p>
                  <pre><code align="left">for(Inicialización; Condición_Bucle; Incremento/Decremento)
&#65371;
        sentencia<sub>1</sub>;
        sentencia<sub>2</sub>;
        ...
        sentencia<sub>n</sub>;
&#65373; 
  </code></pre>
  <table>
    <tr VALIGN=top><td><code>Inicialización</code></td>
      <td>Sección donde se inicializan las variables de control del bucle.</td></tr>
      
    <tr VALIGN=top><td><code>Condición_Bucle</code></td>
      <td>Sección que contiene una expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva, mientras sea verdadera.</td></tr>
      <tr VALIGN=top><td><code>Incremento/Decremento</code></td>
        <td>Sección donde se incrementan o se decrementan las variables de control del bucle.</td></tr>
    <tr VALIGN=top><td><code>sentencias</code></td>
      <td>Las sentencias o acciones se ejecutan si la expresión lógica es verdadera dentro del bucle.</td></tr>
  </table>
  <br>
  <h4><b>Ejercicio 2.25: </b>Escribir un programa que permita imprimir de manera ascendente los números del 1 al 10 utilizando un bucle for().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR><td>2</td> <td><p>Para:</p><p>1. Inicializar el valor del contador 'i' en uno.</p>
			<p>2. Mientras la condición sea verdadera, ejecutar las sentencias del bucle.</p>
			<p>3. Luego de cada ciclo incrementar el valor del contador en uno</p> </td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font>
                          (i = 1; i &gt;= 10; i++) &#65371;</td> </TR>
                      <TR><td>3</td><td>Imprimir el valor del contador. "</td>
                        <td><p>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</p><p>&#65373; </p></td></TR>
    
                    </TABLE> <br>
                    <h5><b>Programa 2.25: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_25"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.25 se puede ver la impresión del 1 al 10 de manera creciente.</p>
                    <h5><b>Ejecución 2.25 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.25.png" style="display:block; margin:auto; "><br>
                    <p>En la Tabla 2.25 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se incrementa en uno, mientras la condición del bucle sea verdadera.</p>
                    <h5><b>Tabla 2.25: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>1</td><td>1 &gt;=10 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>2</td><td>2 &gt;=10 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>3</td><td>3 &gt;=10 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>4</td><td>4 &gt;=10 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>5</td><td>5 &gt;=10 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>6</td><td>6 &gt;=10 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>7</td><td>7 &gt;=10 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>8</td><td>8 &gt;=10 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>9</td><td>9 &gt;=10 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>10</td><td>10 &gt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>11</td><td style="color:rgb(33, 15, 201)">11 &gt;=10 (F)</td><td> </td></tr>
                      
                    </table>
                    <br>
                    <h4><b>Ejercicio 2.26: </b>Escribir un programa que permita imprimir de manera descendente los números del 10 al 1 utilizando un bucle for().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR><td>2</td><td><p>Para:</p><p>1. Inicializar el valor del contador 'i' en diez.</p><p>2. Mientras la condición sea verdadera, ejecutar las sentencias del bucle.</p><p>3. Luego de cada ciclo decrementar el valor del contador en uno.</p></td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for</font>
                          (i = 10; i &lt;= 1; i--) &#65371;</td> </TR>
                      <TR><td>3</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;<p> &#65373;</p></td></TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.26: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_26"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.26 se puede ver la impresión del 10 al 1 de manera decreciente.</p>
                    <h5><b>Ejecución 2.26 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.26.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.26 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en uno, mientras la condición del bucle sea verdadera.</p>
                    <h5><b>Tabla 2.26: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &lt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>10</td><td>10 &lt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>9</td><td>9 &lt;=1 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>8</td><td>8 &lt;=1 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>7</td><td>7 &lt;=1 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>6</td><td>6 &lt;=1 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>5</td><td>5 &lt;=1 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>4</td><td>4 &lt;=1 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>3</td><td>3 &lt;=1 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>2</td><td>2 &lt;=1 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>1</td><td>1 &lt;=1 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>0</td><td style="color:rgb(33, 15, 201)">0 &lt;=1 (F)</td><td> </td></tr>
                      
                    </table><br>
                    <h4><b>Ejercicio 2.27: </b>Escribir un programa que permita imprimir de manera ascendente los números pares del 2 al 10 utilizando un bucle for().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      
                      <TR><td>2</td> <td><p>Para:</p><p>1. Inicializar el valor del contador 'i' en dos.</p><p>2. Mientras la condición sea verdadera, ejecutar las sentencias del bucle.</p><p>3. Luego de cada ciclo incrementar el valor del contador en dos.</p></td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font>
                          (i = 2; i &gt;=10; i=i+2) &#65371;</td> </TR>
                      <TR><td>3</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;<p>&#65373; </p></td></TR>
                    
                    </TABLE> <br>
                    <h5><b>Programa 2.27: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_27"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.27 se puede ver la impresión de los números pares del 2 al 10 de manera creciente.</p>
                    <h5><b>Ejecución 2.27 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.27.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.27 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se incrementa en dos, mientras la condición del bucle sea verdadera.
</p>
                    <h5><b>Tabla 2.27: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>2</td><td>2 &gt;=10 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>4</td><td>4 &gt;=10 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>6</td><td>6 &gt;=10 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>8</td><td>8 &gt;=10 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>10</td><td>10 &gt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>12</td><td>12 &gt;=10 (F)</td><td> </td></tr>                      
                    </table> <br>
 <h4><b>Ejercicio 2.28: </b>Escribir un programa que permita imprimir de manera descendente los números impares del 9 al 1 utilizando un bucle for().
</h4>
                    <br>
                     <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      
                      <TR><td>2</td> <td><p>Para:</p><p>1. Inicializar el valor del contador 'i' en nueve.</p><p>2. Mientras la condición sea verdadera, ejecutar las sentencias del bucle.</p><p>3. Luego de cada ciclo decrementar el valor del contador en dos.</p></td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font>
                          (i = 9; i &lt;=10; i=i-2) &#65371;</td> </TR>
                      <TR><td>3</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;<p>&#65373; </p></td></TR>
                    
                    </TABLE> <br>
                    <h5><b>Programa 2.28: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_28"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.28 se puede ver la impresión del 9 al 1 de manera decreciente.
</p>
                    <h5><b>Ejecución 2.28 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.28.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.28 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en dos, mientras la condición del bucle sea verdadera.

</p>
                    <h5><b>Tabla 2.28: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=1</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>9</td><td>9 &gt;=1 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>7</td><td>7 &gt;=1 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>5</td><td>5 &gt;=1 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>3</td><td>3 &gt;=1 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>1</td><td>1 &gt;=1 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>-1</td><td>-1 &gt;=1 (F)</td><td> </td></tr>                      
                    </table> <br>
            
                    <h1><b>Caso de Estudio 2.21: Sumatoria de una sucesión.</b></h1>
                    <h2><b>A) Problema</b></h2>
                    <p>Dada la sucesión:</p>
                     <table align="right">
                      <td width="350"><em>S <sub>n</sub> = (1,2,3,4,5,6, ...,n) </em></td>
                    <td align="right">(1)</td>
                    </table>
                    <br><br>

                    <p>Donde la fórmula de la sumatoria de los n-términos es:</p>
                    
                    <table align="right">
                      <td width="350"><em> S<sub>n</sub> = &Sigma; <sup><font size="2">&#x221e;</font></sup><sub><font size="2">n=1</font></sub>
                         n</em></td>
                    <td align="right">(2)</td>
                    </table><br>
                    <h2><b>B) Análisis</b></h2>
                    <p>Claramente se puede ver que la única entrada del problema es el número de términos de la sucesión. Se requiere una sola salida que es el valor de la sumatoria de la sucesión. El proceso de cálculo requiere que la sucesión numérica infinita de la ecuación (2), se convierta a una sucesión numérica finita, donde el valor de ‘n’ se convierte en el valor de ‘i’ y el valor de infinito pasa a ser el valor de ‘n’, ya que si se quiere calcular la sumatoria de los cinco primeros términos de la sucesión, la sumatoria iría desde el valor de i = 1 hasta el valor de i = 5, como se puede ver en la ecuación (3):</p>
          
          <table align="right">
            <td width="350"><em> S<sub>n</sub> = &Sigma; <sup><font size="2">&#x221e;</font></sup><sub><font size="2">i=1</font></sub>
               i</em></td>
          <td align="right">(3)</td>
          </table><br>
          <p>Como se puede ver en la ecuación (3) se requiere utilizar un solo bucle para calcular la sumatoria de la sucesión.</p> 
        <h3><b>B.1) Requerimiento de los Datos</b></h3>
                    <p><b>Entradas del Programa</b></p>
                        
          <table>
                        <tr><td width="200"> n </td><td width="200">/* número de términos de la sucesión */</td></tr>
                      </table><br>
                      <p><b>Salidas del Problema</b></p>
                      <table>
                        <tr><td width="200"> sum </td><td width="200">/* Acumulador de sumas  */</td></tr>
                      </table><br>
          <p><b>Auxiliares del Problema</b></p>
                    <table>
          <tr><td width="200">i</td><td width="200">/* Contador para controlar la sumatoria */</td></tr>
                   </table><br>
                      <p><b>Fórmulas Relevantes</b></p>
                      <table>
                    <tr><td width="120"><em>sum = sum + valor</em></td><td width="30"> (1) </td><td width="280">/* Fórmula que representa el acumulador de una sumatoria */</td></tr>
                      <tr><td width="120"><em> S<sub>n</sub> = &Sigma; <sup><font size="2">&#x221e;</font></sup><sub><font size="2">i=1</font></sub>
                        i</em></td><td width="30"> (2) </td><td width="280">/* Fórmula que representa la sumatoria de la sucesión finita  */</td></tr>
                      </table> <br>
      
                      <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                      <p>En la Figura 2.21.1 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘n’; b) Salidas: la variable ‘sum’; c) Auxiliares: el contador ‘i’.</p>
                      <img src="./assets/images/Capitulos/II/media/Figura 2.21.1.png" style="display:block; margin:auto; "><br>
                      <h5 style="text-align:center"><b>Figura 2.20.3. </b>Diagrama de Entrada-Salida del Programa.</h5>
                      <h2><b>C) Diseño</b></h2>
                      <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                      
            <p><b>Algoritmo</b></p>
                      <ol type="1">
                        <li>1.	Imprimir el mensaje de información: Sn = (1, 2, 3, 4, 5, 6, 7, ..., n).</li>
                        <li>2.	Leer el número de términos de la serie, utilizando la variable ‘n’.</li>
                       <li>3.	Inicializar con el valor de cero el acumulador de sumas cuya variable utilizada es ‘sum’.</li>                  
          <li>Para el bucle, hacer:</li>
                        <ol type="1" start="4">
                          <li>1. Inicializar el valor del contador ‘i’ en uno. </li>
                        </ol><ol type="1" start="4">
                          <li>2. Mientras el valor de la condición (i &gt;= n), sea verdadera, ejecutar las sentencias del bucle.</li>
                        </ol><ol type="1" start="4">
                          <li>3. Luego de cada iteración incrementar en uno el valor del contador ‘i’. </li>
                        </ol><ol type="1" start="5">
                          <li>4. Asignar al acumulador 'sum' lo que tiene sumado más el valor del contador 'i'.</li>
                        </ol>
                        <li>Imprimir el valor de la sumatoria utilizando la variable ‘sum’.</li>
                      </ol>
      
                      <h2><b>D) Implementación</b></h2>
                      <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.21.1 se muestra el código del programa en C/C++.</p>
                      <h5><b>Tabla 2.21.1. </b>Programa que analiza si un número leído es palíndromo.</h5>
                      <pre><code [highlight]="prefTab2[0].tabla2_21_1"  [lineNumbers]="true"></code></pre> <br>
                      <h2>E) Pruebas</h2>
                      <p>En la Tabla 2.21.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                      <p>En la salida de la Tabla 2.21.2 se puede ver que, al ingresar el número de términos igual a 5, se obtiene la sumatoria de los primeros cinco números, es decir, 1+2+3+4+5, cuyo resultado es 15.</p>
                      <h5><b>Tabla 2.21.2.</b> Salida del programa</h5>
                      <img src="./assets/images/Capitulos/II/media/Tabla 2.21.2.png" style="display:block; margin:auto; "><br>
                     <p>En la Tabla 2.21.3, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada iteración del bucle for() se utiliza un acumulador de sumas donde se acumulan los valores parciales de la sucesión. Finalmente, la ejecución del bucle termina cuando la condición de esta sentencia se hace falsa.</p>
                     <h5><b>Tabla 2.21.3. </b>Prueba de escritorio del programa.</h5>
                      <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>n</td><td>i</td><td>i &gt= n</td><td>sum</td></tr>
                      <tr><td>5</td><td>1</td><td>1 &gt= 5 (V)</td><td>0</td></tr>
                      <tr><td></td><td>2</td><td>2 &gt= 5 (V)</td><td>0 + 1 = 1</td></tr>
                      <tr><td></td><td>3</td><td>3 &gt= 5 (V)</td><td>1 + 2 = 3</td></tr>
                      <tr><td></td><td>4</td><td>4 &gt= 5 (V)</td><td>3 + 3 = 6</td></tr>
                      <tr><td></td><td>5</td><td>5 &gt= 5 (V)</td><td>6 + 4 = 10</td></tr>
                      <tr><td></td><td>6</td><td style="color:(33, 15, 201)">6 &gt= 5 (F)</td><td>10 + 5 = 15</td></tr>
                      
                     </table> <br>


            <h1><b>Caso de Estudio 2.22: Factorial de un Número.</b></h1>
                     <h2><b>A) Problema</b></h2>
                     <p>El factorial de un número se define como el producto de todos los enteros positivos desde 1 hasta n:</p>
                     <table align="right">
                      <td width="350"><em>n! = 1∙2∙3∙4∙5∙6∙7∙...∙n</em></td>
                    <td align="right">(1)</td>
                    </table><br>
                     <p>Por ejemplo: 5!=1∙2∙3∙4∙5=120</p>
                     <p>Donde la fórmula del factorial de un número se puede representar como un producto de números de una sucesión, como se puede ver a continuación:</p>
                     <table align="right">
                      <td width="350"><em> n! = &prod; <sup><font size="2">&#x221e;</font></sup><sub><font size="2">n=1</font></sub> 
                         n</em></td>
                    <td align="right">(2)</td>
                    </table><br>
                    <p>Escribir un programa que permita calcular el factorial de un número, utilizando un bucle.</p>

                     <h2><b>B) Análisis</b></h2>
                     <p>Claramente se puede ver que la única entrada del problema es un número entero positivo. Se requiere una sola salida que es el valor del producto de la sucesión o el factorial de un número. El proceso de cálculo requiere que la sucesión numérica infinita de la ecuación (2), se convierta a una sucesión numérica finita, donde el valor de ‘n’ se convierte en el valor de ‘i’ y el valor de infinito pasa a ser el valor de ‘n’, ya que si se quiere calcular el producto de los cinco primeros términos de la sucesión o el factorial de 5, es decir, 5!, el producto iría desde el valor de i = 1 hasta el valor de i = 5, como se puede ver en la ecuación (3):</p>
                     <table align="right">
                      <td width="350"><em> n! = &prod; <sup><font size="2">&#x221e;</font></sup><sub><font size="2">i=1</font></sub> 
                         i</em></td>
                    <td align="right">(3)</td>
                    </table><br>
                     <p>Como se puede ver en la ecuación (3) se requiere utilizar un solo bucle para calcular el producto de la sucesión.</p>
                     
         <h3><b>B.1) Requerimiento de los Datos</b></h3>
                     <p><b>Entradas del Programa</b></p>
                         
           <table>
                         <tr><td width="200"> n </td><td width="200">/* número entero positivo a calcular */</td></tr>
                       </table><br>
                       <p><b>Salidas del Problema</b></p>
                       <table>
                         <tr><td width="200"> prod </td><td width="200">/* Acumulador de productos */</td></tr>
                      </table><br>
           <p><b>Auxiliares del Problema</b></p>
                     <table>
                       
           <tr><td width="200">i</td><td width="200">/* Contador para controlar el producto */</td></tr>
                    </table><br>
                       <p><b>Fórmulas Relevantes</b></p>
                       <table>
           <tr><td width="120"><em>prod = prod x valor</em></td><td> (1) </td><td>/* Fórmula que representa el acumulador de un producto  */</td></tr>
                       <tr><td width="120"><em>n! = &prod; <sup><font size="2">&#x221e;</font></sup><sub><font size="2">i=1</font></sub> 
                        i</em></td><td width="30"> (2) </td><td width="280">/* Fórmula que representa el producto de la sucesión finita o el factorial de un número */</td></tr>
                        </table> <br>
       
                       <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                       <p>En la Figura 2.22.1 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘n’; b) Salidas: la variable ‘prod’; c) Auxiliares: el contador ‘i’.</p>
                       <img src="./assets/images/Capitulos/II/media/Figura 2.22.1.png" style="display:block; margin:auto; "><br>
                       <h5 style="text-align:center"><b>Figura 2.22.1. </b>Diagrama de Entrada-Salida del Programa.</h5>
                       <h2><b>C) Diseño</b></h2>
                       <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                       
             <p><b>Algoritmo</b></p>
                       <ol type="1">
                         <li>Imprimir el mensaje de información: n! = 1∙2∙3∙4∙5∙6∙7∙…∙n.</li>
                         <li>Leer un número entero positivo, utilizando la variable ‘n’.</li>
           <li>Inicializar con el valor de uno el acumulador de productos cuya variable utilizada es ‘prod’.</li>
          <li>Para el bucle, hacer:</li>
                         <ol type="1" start="4">
                           <li>1. Inicializar el valor del contador ‘i’ en uno. </li>
                         </ol><ol type="1" start="4">
                           <li>2. Mientras el valor de la condición (i <= n), sea verdadera, ejecutar las sentencias del bucle. </li>
                         </ol><ol type="1" start="4">
                           <li>3. Luego de cada iteración incrementar en uno el valor del contador ‘i’. </li>
                         </ol><ol type="1" start="4">
                           <li>4. Asignar al acumulador 'prod' lo que tiene multiplicado por el valor del contador 'i'.</li>
                           </ol>
                         <li>5.	Imprimir el valor del producto calculado o del factorial de un número, utilizando la variable ‘prod’.</li>
                       </ol>
       
                       <h2><b>D) Implementación</b></h2>
                       <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.22.1 se muestra el código del programa en C/C++.</p>
                       <h5><b>Tabla 2.22.1. </b>Programa que calcula el factorial de un número entero positivo.</h5>
                       <pre><code [highlight]="prefTab2[0].tabla2_22_1"  [lineNumbers]="true"></code></pre> <br>
                       <h2>E) Pruebas</h2>
                       <p>En la Tabla 2.22.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                       <p>En la salida de la Tabla 2.22.2 se puede ver que, al ingresar el número de términos igual a 5, se obtiene el producto de los primeros cinco números, es decir, 1*2*3*4*5, cuyo resultado es 120, que corresponde al factorial de 5 (5!).</p>
                       <h5><b>Tabla 2.22.2.</b> Salida del programa</h5>
                       <img src="./assets/images/Capitulos/II/media/Tabla 2.22.2.png" style="display:block; margin:auto; "><br>
                       <p>En la Tabla 2.22.3, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada iteración del bucle for() se utiliza un acumulador de productos donde se acumulan los valores parciales de la sucesión o del factorial de un número. Finalmente, la ejecución del bucle termina cuando la condición de esta sentencia se hace falsa.</p>
                      <h5><b>Tabla 2.22.3. </b>Prueba de escritorio del programa.</h5>
                      <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                        <tr style="color:red"><td>n</td><td>i</td><td>i &gt= n</td><td>prod</td></tr>
                        <tr><td>5</td><td>1</td><td>1 &gt= 5 (V)</td><td>0</td></tr>
                        <tr><td></td><td>2</td><td>2 &gt= 5 (V)</td><td>0 x 1 = 1</td></tr>
                        <tr><td></td><td>3</td><td>3 &gt= 5 (V)</td><td>1 x 2 = 2</td></tr>
                        <tr><td></td><td>4</td><td>4 &gt= 5 (V)</td><td>2 x 3 = 6</td></tr>
                        <tr><td></td><td>5</td><td>5 &gt= 5 (V)</td><td>6 x 4 = 24</td></tr>
                        <tr><td></td><td>6</td><td><font color="blue"> 6 &gt= 5 (F)</font></td><td>24 x 5 = 120</td></tr>
                        
                       </table> <br>
                       <h1><b>Caso de Estudio 2.23: Sucesión de Fibonacci Iterativa.</b></h1>
                       <h2><b>A) Problema</b></h2>
                       <p>La sucesión o serie de Fibonacci es una sucesión infinita de números naturales que comienza con los números 0 y 1, donde a partir de estos números cada término es la suma de los dos anteriores:</p>
                       <p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …</p>
                       <p>A los elementos de esta sucesión se los llama los números de Fibonacci en honor a Leonardo de Pisa, matemático italiano del siglo XIII (Vorobiov, N.N.; 1974). Esta sucesión tiene muchas aplicaciones en varias áreas como las Matemáticas, Computación, Teoría de Juegos, Biología, entre otras. Como, por ejemplo: las ramas de los árboles, la disposición de las hojas en el tallo de un árbol, en las flores de alcachofas, en las flores de los girasoles, en la configuración de las piñas coníferas, en los números de parejas de conejos, etc.</p>
                       <p>Los números de Fibonacci quedan definidos por las ecuaciones:</p>
                       <table align="right">
                        <tr><td width="350"><em> f<sub>0</sub> = 0 <p>f<sub>1</sub>=1</p></em></td>
                          <td align="right">Ec. 2.23.1</td></tr>
                      <tr><td><em>f<sub>n</sub> = f<sub>n-2</sub> + f <sub>n-1</sub></em></td><td>Ec. 2.23.2</td></tr>
                      </table><br><br><br><br><br>
                      <p>Esto produce los siguientes números:</p>
                      <table align="center">
                          <tr><td><em>f<sub>0</sub> = 0</em></td></tr>
                          <tr><td><em>f<sub>1</sub> = 1</em></td></tr>
                          <tr><td><em>f<sub>2</sub> = 1</em></td></tr>
                          <tr><td><em>f<sub>3</sub> = 2</em></td></tr>
                          <tr><td><em>f<sub>4</sub> = 3</em></td></tr>
                          <tr><td><em>f<sub>5</sub> = 5</em></td></tr>
                          <tr><td><em>f<sub>6</sub> = 8</em></td></tr>
                          <tr><td><em>f<sub>7</sub> = 13</em></td></tr>
                          <tr><td><em>f<sub>8</sub> = 21</em></td></tr>
                          <tr><td><em>f<sub>9</sub> = 34</em></td></tr>
                          <tr><td>...</td></tr>
                      </table><br>
                      <p>Esta manera de definir la sucesión se la considera algorítmica y es parte del estudio en las Matemáticas Discretas.</p>
                       <h2><b>B) Análisis</b></h2>
                       <p>Claramente se puede ver que la única entrada del problema es el número de Fibonacci que se desea calcular. Hay una sola salida requerida que es el n-ésimo término de la serie. Para resolver este ejercicio, se va a utilizar tres sentencias if-else anidadas y un bucle for(), que es una solución iterativa muy eficiente. De acuerdo con la Ec. 2.23.2 (caso general), la serie de Fibonacci se puede representar por una sucesión recurrente donde el n-ésimo término se obtiene sumando los dos anteriores términos de la sucesión, partiendo de los casos simples de la Ec. 2.23.1. </p>
           <h3><b>B.1) Requerimiento de los Datos</b></h3>
                       <p><b>Entradas del Programa</b></p>
                           
             <table>
                           <tr><td width="200"> n</td><td width="200">/* término de la sucesión a calcular */</td></tr>
                         </table><br>
                         <p><b>Salidas del Problema</b></p>
                         <table>
                           <tr><td width="200"> c </td><td width="200">/* n-ésimo término de la sucesión calculado */</td></tr>
                            </table><br>
             <p><b>Auxiliares del Problema</b></p>
             <table>
              <tr><td width="200"> a </td><td width="200">/* primer término de la sucesión recurrente */</td></tr>
              <tr><td width="200"> b </td><td width="200">/* segundo término de la sucesión recurrente */</td></tr>
              <tr><td width="200"> i </td><td width="200">/* contador que controla el bucle for() */</td></tr>
            </table><br>
                         <p><b>Fórmulas Relevantes</b></p>
                         <table>
             <tr><td ><em>f<sub>0</sub>=0</em><p><em>f<sub>1</sub>=1</em></p></td><td> (1) </td><td>/* Condiciones iniciales del problema (casos especiales) */</td></tr>
                         <tr><td width="120"><em>f<sub>n</sub> = f<sub>n-2</sub> + f <sub>n-1</sub></em></td><td width="30"> (2) </td><td width="280">/* Fórmula general que calcula el n-ésimo término de la sucesión de Fibonacci */</td></tr>
                            </table> <br>
         
                         <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                         <p>En la Figura 2.23.1 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘n’; b) Salidas: la variable ‘c’; c) Auxiliares: el contador ‘i’; la variable ‘a’; la variable ‘b’.</p>
                         <img src="./assets/images/Capitulos/II/media/Figura 2.23.1.png" style="display:block; margin:auto; "><br>
                         <h5 style="text-align:center"><b>Figura 2.23.1. </b>Diagrama de Entrada-Salida del Programa.</h5>
                         <h2><b>C) Diseño</b></h2>
                         <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                         
               <p><b>Algoritmo</b></p>
                         <ol type="1">
                           <li>Imprimir el mensaje de información: <p>f(n) = 0+1+1+2+3+5+8+13+21+34+55+89+...</p></li>
                           <li>Leer el término de la sucesión recurrente a calcular, utilizando la variable ‘n’.</li>
             <li>Asignar a la variable 'a' el valor de cero.</li>
             <li>Asignar a la variable 'b' el valor de uno.</li> 
             <li>Si el valor de 'n' es igual a cero.</li>   
             <ol type="1" start="5">
              <li>1. Asignar a la la variable 'c' el valor de la variable 'a'.</li>
            </ol>
            <li>Caso contrario, si el valor de 'n' es igual a uno.</li>
            <ol type="1" start="6">
              <li>1. Asignar a la la variable 'c' el valor de la variable 'b'.</li>
            </ol>
             <li>7.	Caso contrario, si el valor de 'n' es mayor o igual a dos.</li>
             <ol type="1" start="7">
              <li>1. Para el bucle, hacer: </li>
            
            <ol type="1" start="7">
             <li>1.1.	Inicializar el valor del contador 'i' en dos. </li>
            </ol><ol type="1" start="7">
                             <li>1.2.	Mientras el valor de la condición (i &gt;= n) sea verdadera, ejecutar las sentencias del bucle. </li>
                           </ol><ol type="1" start="7">
                             <li>1.3.	Luego de cada iteración incrementar en uno el valor del contador ‘i’. </li>
                           </ol><ol type="1" start="7">
                             <li>1.4.	Asignar a la la variable 'c' la suma de a + b.</li>
                             </ol><ol type="1" start="7">
                              <li>1.5.	Asignar a la la variable 'b' el valor de la variable 'c'.</li>
                              </ol></ol> 
                           <li>8.	Imprimir el valor de la variable 'n' y de la variable 'c'.</li>        
                         </ol>
         
                         <h2><b>D) Implementación</b></h2>
                         <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.23.1 se muestra el código del programa en C/C++.</p>
                         <h5><b>Tabla 2.23.1. </b>Programa que analiza si un número leído es palíndromo.</h5>
                         <pre><code [highlight]="prefTab2[0].tabla2_23_1"  [lineNumbers]="true"></code></pre> <br>
                         <h2>E) Pruebas</h2>
                         <p>En la Tabla 2.23.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                         <p>En la salida de la Tabla 2.23.2 se puede ver que, al ingresar el valor de ‘n’ igual a 6, se otiene el sexto término de la sucesión de Fibonacci que es el valor de 8.</p>
                         <h5><b>Tabla 2.23.2.</b> Salida del programa</h5>
                         <img src="./assets/images/Capitulos/II/media/Tabla 2.23.2.png" style="display:block; margin:auto; "><br>
                         <p>En la Tabla 2.23.3, se muestra la prueba de escritorio del programa, donde se puede comprobar que se utilizan tres sentencias if-else anidadas, donde en este caso se evalúa la sentecia if-else cuya condición (n>=2) es verdadera. Luego, se utiliza un bucle for() que comienza con el contador igual a 2 y se ejecuta mientras la condición (n>=2) es verdadera. En cada iteración del bucle, la variable ‘a’ toma el valor de la variable ‘b’ y la variable ‘b’ toma el valor de la variable ‘c’. Finalmente, la ejecución del bucle termina cuando la condición de esta sentencia se hace falsa y se imprime el valor de la variable ‘c’ que corresponde al sexto termino de la sucesión de Fibonacci que es igual al valor de 8.</p>
                        <h5><b>Tabla 2.23.3. </b>Prueba de escritorio del programa.</h5>
                         <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                         <tr style="color:red"><td>n</td><td>a</td><td>b</td><td>c</td><td>n == 0</td><td>n==1</td><td>n &lt;= 2</td><td>i</td><td>i &gt;= n</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          <font color="#900C3F">"f("</font>
                          <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          <font color="black">n</font> 
                          <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          <font color="#900C3F">")="</font>
                          <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          <font color="black">c</font> 
                          <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          <font color="black"> endl;</font>
                        </td></tr>
                        <tr><td>6</td><td>0</td><td>1</td><td>1</td><td>6 == 0 (F)</td><td>6 == 1 (F)</td><td>6 &lt;= 2 (V)</td><td>2</td><td>2 &gt;= 6 (V)</td><td></td></tr>
                        <tr><td></td><td>1</td><td>1</td><td>2</td><td></td><td></td><td></td><td>3</td><td>3 &gt;= 6 (V)</td><td></td></tr>
                        <tr><td></td><td>1</td><td>2</td><td>3</td><td></td><td></td><td></td><td>4</td><td>4 &gt;= 6 (V)</td><td></td></tr>
                        <tr><td></td><td>2</td><td>3</td><td>5</td><td></td><td></td><td></td><td>5</td><td>5 &gt;= 6 (V)</td><td></td></tr>
                        <tr><td></td><td>3</td><td>5</td><td>8</td><td></td><td></td><td></td><td>6</td><td>6 &gt;= 6 (V)</td><td></td></tr>
                        <tr><td></td><td>5</td><td>8</td><td>0</td><td></td><td></td><td></td><td>7</td><td><font color="blue"> 7 &gt;= 6 (F)</font></td><td>f(6) = 8</td></tr>
                         
                        </table> <br>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.4.4. Bucles anidados">
              <ng-template matTabContent>
               <br>
               <h1>Bucles anidados</h1>
                <p>En el lenguaje C/C++ es posible anidar bucles, donde estos bucles anidados constan de un bucle externo con uno o más bucles internos. Cada vez que se repite el bucle externo, los bucles internos se repiten y se ejecutan las sentencias de estos bucles. Se pueden combinar bucles for() entre sí, pero también se pueden combinar bucles for() con bucles while() y do-while() en diferente orden, por ejemplo:</p>
                <p><b>Ejemplo 1:</b>Combinación de un bucle do-while() anidado con un bucle for().</p>
 <pre><code align="left">do &#65371;
      for()
      &#65371;
          sentencia<sub>1</sub>;
          sentencia<sub>2</sub>;
          ...
          sentencia<sub>n</sub>;
      &#65373;
&#65373; while();</code></pre>
                <p><b>Ejemplo 2:</b>Combinación de un bucle for() anidado con un bucle while().</p>
 <pre><code align="left">for() 
&#65371;
      while()
      &#65371;
          sentencia<sub>1</sub>;
          sentencia<sub>2</sub>;
          ...
          sentencia<sub>n</sub>;
      &#65373;
&#65373;</code></pre>
              <p><b>Ejemplo 3:</b>Combinación de tres bucles for() anidados.</p>
<pre><code align="left">for() 
&#65371;
     for()
     &#65371;
          for()
          &#65371;
                sentencia<sub>1</sub>;
                sentencia<sub>2</sub>;
                ...
                sentencia<sub>n</sub>;
          &#65373;
     &#65373;
&#65373;</code></pre>
          <p><b>Ejemplo 4:</b>Combinación de un bucle for() anidado con otros dos bucles for().</p>
<pre><code align="left">for() 
&#65371;
    for()
    &#65371;
          sentencia<sub>1.1</sub>;
          sentencia<sub>1.2</sub>;
          ...
          sentencia<sub>1.n</sub>;
    &#65373;
    for()
    &#65371;
          sentencia<sub>1</sub>;
          sentencia<sub>2</sub>;
          ...
          sentencia<sub>n</sub>;
    &#65373;
&#65373;</code></pre><br>
                 <h4><b>Ejercicio 2.29: </b>Escribir un programa que permita visualizar un triángulo rectángulo isósceles de asteriscos. Así, por ejemplo, si el valor del lado del triángulo es igual a 5, se obtendrá la siguiente figura:</h4>
                   <table border="1" align="center" cellspacing="0" cellpadding="5" >
                     <tr><td width="100"><p>*</p><p>**</p><p>***</p><p>****</p><p>*****</p></td></tr>
                   </table><br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5" >
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="350"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : lado</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          lado;</td>
                      </TR>
                      <TR> <td>2</td>  <td>entero : f</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          f;</td>
                      </TR>
                      <TR> <td>3</td>  <td>entero : a</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          a;</td>
                      </TR>
                      <TR>
                        <td>4</td>
                        <td>Leer el valor del lado</td>
                        <td>cin <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> lado</td>
                      </TR>
                      <TR><td>5</td> <td>Para: <p>1. Inicializar el valor del contador de las filas ‘f’ en uno.</p>
                      <p>2. Mientras la condición (f &lt;= lado) sea verdadera, ejecutar las sentencias del bucle externo.</p>
                    <p>3. Luego de cada ciclo incrementar el valor del contador de las filas ‘f’ en uno</p></td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font> (f = 1; f &lt;= lado; f++) 
                         &#65371;</td> </TR>
                      <TR><td>6</td><td>Para: <p>1. Inicializar el valor del contador de las columnas de asteriscos ‘a’ en uno.</p>
                      <p>2. Mientras la condición (a &lt;= f) sea verdadera, ejecutar las sentencias del bucle interno.</p>
                    <p>3. Luego de cada ciclo incrementar el valor del contador de las columnas de asteriscos ‘a’ en uno.</p></td>
                    <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font> (a = 1; a &lt;= f; a++) &#65371;</td> </TR>   
                    <tr><td>7</td><td>Imprimir un asterisco por columna.</td> <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font>
                          <font color="red">"*"</font>;<p>&#65373;</p></td></tr>
                  <tr><td>8</td><td>Imprimir un salto de línea (INTRO).</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font>
                        endl;<p>&#65373;</p></td></tr>
                        
                    </TABLE> <br>

                    <h5><b>Programa 2.29: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_29"  [lineNumbers]="true"></code></pre>
                   <p>En la salida de la Ejecución 2.29 se puede ver la impresión del triángulo rectángulo isósceles de asteriscos de lado igual a 5.</p>
                    <h5><b>Ejecución 2.29 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.29.png" style="display:block; margin:auto; "><br>
                    <p>En la Tabla 2.29 se puede ver la prueba de escritorio del programa, donde la impresión del triángulo rectángulo isósceles se realiza mediante un bucle externo y un bucle interno. Cada vez que se repite el bucle externo, se ejecuta el bucle interno. </p>
                    <p>El bucle externo se repite cinco veces en este caso, según la condición que depende del valor del lado del triangulo rectángulo y se controla con el contador de las filas ‘f’. El número de repeticiones realizadas por el bucle interno se controla con el contador de los asteriscos ‘a’ cuya condición depende del valor de las filas ‘f’ del triángulo rectángulo, donde este bucle se encarga de manejar la impresión de los asteriscos.</p>
                    <h5><b>Tabla 2.29: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5" style="font-size:x-small"> 
                      <tr style="color:red"><td>lado</td><td>f</td><td>f &lt;= lado</td><td>a</td><td>a &lt;= f</td><td>cout &lt;&lt; "*"; </td><td>cout &lt;&lt; endl;</td></tr>
                      <tr><td HEIGHT="50">5</td><td>1</td><td>1 &lt;= 5 (V)</td><td>1</td><td>1 &lt;= 1 (V)</td><td>*</td><td></td></tr>
                      <tr><td HEIGHT="30"></td><td></td><td></td><td>2</td><td style="color:rgb(33, 15, 201)">2 &lt;= 1 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td>1</td><td>1 &lt;= 2 (V)</td><td>**</td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>3</td><td>2 &lt;= 2 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>3</td><td style="color:rgb(33, 15, 201)">3 &lt;= 2 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td>1</td><td>1 &lt;= 3 (V)</td><td>***</td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>2</td><td>2 &lt;= 3 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>3</td><td>3 &lt;= 3 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>4</td><td style="color:rgb(33, 15, 201)">4 &lt;= 3 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td>1</td><td>1 &lt;= 4 (V)</td><td>****</td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>2</td><td>2 &lt;= 4 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>3</td><td>3 &lt;= 4 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>4</td><td>4 &lt;= 4 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>5</td><td style="color:rgb(33, 15, 201)">5 &lt;= 4 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td>1</td><td>1 &lt;= 5 (V)</td><td>*****</td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td>6</td><td style="color:rgb(33, 15, 201)">2 &lt;= 5 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td>6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (V)</td><td></td><td></td><td></td><td></td></tr>
                       
                    </table>
                    <br>
                   <h4><b>Ejercicio 2.30: </b>Escribir un programa que permita visualizar un rectángulo de asteriscos. Así, por ejemplo, si el valor del lado del triángulo es igual a 5, se obtendrá la siguiente figura:</h4>
                   
		<table border="1" align="center" cellspacing="0" cellpadding="5">
                     <tr><td width="100"><p>*****</p><p>*****</p><p>*****</p><p>*****</p></td></tr>
                   </table><br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : ancho</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          ancho;</td>
                      </TR>
			<TR> <td>2</td>  <td>entero : largo</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          largo;</td>
                      </TR>
                      <TR> <td>3</td>  <td>entero : f</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          f;</td>
                      </TR>
                      <TR> <td>4</td>  <td>entero : a</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          a;</td>
                      </TR>
                      <TR>
                        <td>5</td>
                        <td>Leer el valor del ancho</td>
                        <td>cin <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> ancho</td>
                      </TR>
			<TR>
                        <td>6</td>
                        <td>Leer el valor del largo</td>
                        <td>cin <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> largo</td>
                      </TR>
                      <TR><td>7</td> <td>Para: <p>1. Inicializar el valor del contador de las filas ‘f’ en uno.</p>
                      <p>2. Mientras la condición (f &lt;= largo) sea verdadera, ejecutar las sentencias del bucle externo.</p>
                    <p>3. Luego de cada ciclo incrementar el valor del contador de las filas ‘f’ en uno</p></td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font> (f = 1; f &lt;= largo; f++) 
                         &#65371;</td> </TR>
                      <TR><td>8</td><td>Para: <p>1. Inicializar el valor del contador de las columnas de asteriscos ‘a’ en uno.</p>
                      <p>2. Mientras la condición (a &lt;= ancho) sea verdadera, ejecutar las sentencias del bucle interno.</p>
                    <p>3. Luego de cada ciclo incrementar el valor del contador de las columnas de asteriscos ‘a’ en uno.</p></td>
                    <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font> (a = 1; a &lt;= ancho; a++) &#65371;</td> </TR>   
                    <tr><td>7</td><td>Imprimir un asterisco por columna.</td> <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font>
                          <font color="red">"*"</font>;<p>&#65373;</p></td></tr>
                  <tr><td>8</td><td>Imprimir un salto de línea (INTRO).</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font>
                        endl;<p>&#65373;</p></td></tr>
                        
                    </TABLE> <br>

                    <h5><b>Programa 2.30: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_30"  [lineNumbers]="true"></code></pre>
                   <p>En la salida de la Ejecución 2.30 se puede ver la impresión del rectángulo de asteriscos de ancho igual a 5 y de largo igual a 4.</p>
                    <h5><b>Ejecución 2.30 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.30.png" style="display:block; margin:auto; "><br>
                    <p>En la Tabla 2.30 se puede ver la prueba de escritorio del programa, donde la impresión del rectángulo se realiza mediante un bucle externo y un bucle interno. </p>
			<p>Cada vez que se repite el bucle externo, se ejecuta el bucle interno. El bucle externo se repite cinco veces en este caso, según la condición que depende del valor del largo del rectángulo y se controla con el contador de las filas ‘f’. El número de repeticiones realizadas por el bucle interno se controla con el contador de los asteriscos ‘a’ cuya condición depende del valor del ancho del rectángulo, donde este bucle se encarga de manejar la impresión de los asteriscos.</p>
		<h5><b>Tabla 2.30: </b>Prueba de escritorio del programa.</h5>

                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5" style="font-size:x-small" HEIGHT="50"> 
                      <tr style="color:red"><td>ancho</td><td>largo</td><td>f</td><td>f &lt;= lado</td><td>a</td><td>a &lt;= f</td><td>cout &lt;&lt; "*"; </td><td>cout &lt;&lt; endl;</td></tr>
                      <tr><td>5</td><td>4</td><td>1</td><td>1 &lt;= 4 (V)</td><td>1</td><td>1 &lt;= 5 (V)</td><td>*****</td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td></td><td>2</td><td>2 &lt;= 4 (V)</td><td>1</td><td>1 &lt;= 5 (V)</td><td>*****</td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td></td><td>3</td><td>3 &lt;= 4 (V)</td><td>1</td><td>1 &lt;= 5 (V)</td><td>*****</td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td></td><td>4</td><td>4 &lt;= 4 (V)</td><td>1</td><td>1 &lt;= 5 (V)</td><td>*****</td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td></td><td></td></tr>
                      <tr><td></td><td></td><td></td><td></td><td>6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td>INTRO</td></tr>
                      <tr><td></td><td></td><td>5</td><td style="color:rgb(33, 15, 201)">5 &lt;= 4 (F)</td><td></td><td></td><td></td><td></td></tr>
 
                    </table>
                    <br>
               
                 <h4><b>Ejercicio 2.31: </b>Escribir un programa que permita visualizar un triángulo isósceles de asteriscos. Así, por ejemplo, si el valor de la altura del triángulo es igual a 5, se obtendrá la siguiente figura:</h4>
                   
		<table border="1" align="center" cellspacing="0" cellpadding="5">
                     <tr><td width="100"><p>&#9633;&#9633;&#9633;&#9633;*</p><p>&#9633;&#9633;&#9633;***</p><p>&#9633;&#9633;*****</p><p>&#9633;*******</p><p>**********</p></td></tr>
                   </table><br>

<table border="1" CELLPADDING=5 CELLSPACING=0>
                    <tr VALIGN=top><td width="50"><b> Nota:</b></td><td> Como se puede ver en la figura anterior, en cada fila mientras se reduce el número de espacios en blanco, aumenta el número de asteriscos. Con fines didácticos, el símbolo &#9633; equivale a un espacio en blanco (“ ”).</td></tr>
                  </table>
<br><br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="350"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : altura</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          altura;</td>
                      </TR>
			
                      <TR> <td>2</td>  <td>entero : f</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          f;</td>
                      </TR>

                      <TR> <td>3</td>  <td>entero : b</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          b;</td>
                      </TR>
                      <TR> <td>4</td>  <td>entero : a</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          a;</td>
                      </TR>
                      <TR>
                        <td>5</td>
                        <td>Leer el valor de la altura del triángulo isósceles</td>
                        <td>cin <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> altura</td>
                      </TR>
                      <TR><td>6</td> <td>Para: <p>1. Inicializar el valor del contador de las filas ‘f’ en uno.</p>
                      <p>2. Mientras la condición (f &lt;= altura) sea verdadera, ejecutar las sentencias del bucle externo.</p>
                    <p>3. Luego de cada ciclo incrementar el valor del contador de las filas ‘f’ en uno</p></td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font> (f = 1; f &lt;= altura; f++) 
                         &#65371;</td> </TR>
			<TR><td>7</td> <td>Para: <p>1. Inicializar el valor del contador de las columnas de blancos ‘b’ con el valor de la altura menos el número de filas.</p>
                      <p>2. Mientras la condición (b &gt;= 1) sea verdadera, ejecutar las sentencias del bucle externo.</p>
                    <p>3. Luego de cada ciclo decrementar el valor del contador de las columnas de blanco ‘b’ en uno</p></td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font> (b = altura - f; b &gt;= 1; b--) 
                         &#65371;</td> </TR>
			<TR><td>8</td><td>Imprimir un espacio en blanco por columna.</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font>  
        <font color="red"> " "</font>;<p>&#65373;</p></td></TR>
                      <TR><td>9</td><td>Para: <p>1. Inicializar el valor del contador de las columnas de asteriscos ‘a’ en uno.</p>
                      <p>2. Mientras la condición (a &lt;= ancho * f - 1) sea verdadera, ejecutar las sentencias del bucle interno.</p>
                    <p>3. Luego de cada ciclo incrementar el valor del contador de las columnas de asteriscos ‘a’ en uno.</p></td>
                    <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">for </font> (a = 1; a &lt;= 2 * f - 1; a++) &#65371;</td> </TR>   
                    <tr><td>10</td><td>Imprimir un asterisco por columna.</td> <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font>
                          <font color="red">"*"</font>;<p>&#65373;</p></td></tr>
                  <tr><td>11</td><td>Imprimir un salto de línea (INTRO).</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font>
                        endl;<p>&#65373;</p></td></tr>
                        
                    </TABLE> <br>
                    <h5><b>Programa 2.31: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_31"  [lineNumbers]="true"></code></pre>
                   <p>En la salida de la Ejecución 2.31 se puede ver la impresión del triángulo isósceles de asteriscos de altura igual a 5.</p>
                    
<h5><b>Ejecución 2.31 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.31.png" style="display:block; margin:auto; "><br>
                   <p>En la Tabla 2.31 se puede ver la prueba de escritorio del programa, donde la impresión del triángulo isósceles se realiza mediante un bucle externo y dos bucles internos. Cada vez que se repite el bucle externo, se ejecutan los dos bucles internos. </p>
<p>El bucle externo se repite cinco veces en este caso, según la altura del triángulo y se controla con el contador de las filas ‘f’. El número de repeticiones realizadas por los bucles internos se basan en el valor del contador de las filas ‘f’. El primer bucle interno controla la impresión de los espacios en blanco con el contador ‘b’ y el segundo bucle interno controla la impresión de los asteriscos con el contador ‘a’. </p>
<h5><b>Tabla 2.31: </b>Prueba de escritorio del programa.</h5>

<table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5" style="font-size:x-small" HEIGHT="50"> 
  <tr style="color:red"><td>altura</td><td>f</td><td>f &lt;= altura</td><td>b</td><td>b &gt;= 1</td><td>cout &lt;&lt;= " ";</td><td>a</td><td>a &lt;= 2 * f - 1</td><td>cout &lt;&lt; "*"; </td><td>cout &lt;&lt; endl;</td></tr>
  <tr><td>5</td><td>1</td><td>1 &lt;= 5 (V)</td><td>4</td><td>4 &gt;= 1 (V)</td><td>&#9633;&#9633;&#9633;&#9633;</td><td>1</td><td>1 &lt;= 1 (V)</td><td>*</td><td></td></tr>
  <tr><td></td><td></td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td style="color:rgb(33, 15, 201)">2</td><td style="color:rgb(33, 15, 201)">2 &lt;= 1 (F)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td><td></td><td></td><td>INTRO</td></tr>

  <tr><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td>3</td><td>3 &gt;= 1 (V)</td><td>&#9633;&#9633;&#9633;</td><td>1</td><td>1 &lt;= 3 (V)</td><td>***</td><td></td></tr>
  <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td>2</td><td></td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>3</td><td></td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td style="color:rgb(33, 15, 201)">4</td><td style="color:rgb(33, 15, 201)"> 4 &lt;= 3 (F)</td><td></td><td>INTRO</td></tr>

  <tr><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td>2</td><td> 2 &gt;= 1 (V)</td><td>&#9633;&#9633;</td><td>1</td><td>1 &lt;= 5 (V)</td><td>*****</td><td></td></tr>
  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td>INTRO</td></tr>
  
  <tr><td></td><td>4</td><td>4 &lt;= 4 (V)</td><td>1</td><td>1 &gt;= 1 (V)</td><td>&#9633;</td><td>1</td><td>1 &lt;= 7 (V)</td><td>*******</td><td></td></tr>
  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>2</td><td>2&lt;= 7 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 7 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 7 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 7 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>6</td><td>6 &lt;= 7 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>7</td><td>7 &lt;= 7 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">8</td><td style="color:rgb(33, 15, 201)">8 &lt;= 7 (F)</td><td></td><td>INTRO</td></tr>
  
  <tr><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>1</td><td>1 &lt;= 9 (V)</td><td>*********</td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>2</td><td>2 &lt;= 9 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 9 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 9 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 9 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>6</td><td>6 &lt;= 9 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>7</td><td>7 &lt;= 9 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>8</td><td>8 &lt;= 9 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>9</td><td>9 &lt;= 9 (V)</td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">10</td><td style="color:rgb(33, 15, 201)">10 &lt;= 9 (F)</td><td></td><td>INTRO</td></tr>
  
  <tr><td></td><td style="color:rgb(33, 15, 201)">6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</table>
<br>
<h1><b>Caso de Estudio 2.24: Visualización de un Rombo con Asteriscos.</b></h1>
              <h2><b>A) Problema</b></h2>
              <p>Escribir un programa que permita visualizar un rombo de asteriscos. Así, por ejemplo, si el valor de la Diagonal mayor es igual a 9 o a 10, se obtendrá la siguiente figura:</p>
              <table border="1" align="center" cellspacing="0" cellpadding="5">
                <tr><td width="200"><p>bbbb*</p><p>bbb***</p><p>bb*****</p><p>b*******</p><p>**********</p>
              <p>b*******</p><p>bb*****</p><p>bbb***</p><p>bbbb*</p>	</td></tr>
              </table><br>
              
              <table border="1" CELLPADDING=5 CELLSPACING=0>
                <tr VALIGN=top><td width="50"><b> Nota:</b></td><td>Como se puede ver en la figura anterior, en cada fila mientras se reduce el número de espacios en blanco, aumenta el número de asteriscos, tanto de arriba hacia abajo, como de abajo hacia arriba. Con fines didácticos, la letra ‘b’ en color plomo equivale a un espacio en blanco (“ ”).</td></tr>
              </table><br>
              <h2><b>B) Análisis</b></h2>
              <p>Claramente se puede ver que la única entrada del problema es el valor de la diagonal mayor del rombo. Se requieren dos salidas que son los espacios en blanco y los asteriscos de la figura geométrica controlados por los contadores ‘b’ y ‘a’ respectivamente. Se requiere una variable auxiliar llamada ‘aux’ que tiene el valor de la mitad de la diaginal del rombo. El proceso de cálculo y visualización del rombo con asteriscos requiere la utilización de bucles anidados.</p>
        	<h3><b>B.1) Requerimiento de los Datos</b></h3>
              <p><b>Entradas del Problema</b></p>		
		<table>
                  <tr><td width="200"> diagonalMayor </td><td width="200">/* Tamaño de la diagonal mayor del rombo  */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200"> Mensaje1 </td><td width="200">/* Mensaje que imprime un espacio en blanco */</td></tr>
                  <tr><td width="200"> Mensaje2 </td><td width="200">/* Mensaje que imprime un asterisco */</td></tr>
                  <tr><td width="200"> Mensaje3 </td><td width="200">/* Mensaje que imprime un INTRO */</td></tr>
                </table><br>
		<p><b>Auxiliares del Problema</b></p>
              <table>
    <tr><td width="200">altura</td><td width="200">/* Altura que representa la mitad de la diagonal mayor del rombo */</td></tr>
		<tr><td width="200">f</td><td width="200">/* Número de filas */</td></tr>
		<tr><td width="200">b</td><td width="200">/* Contador para controlar el número de espacios en blanco */</td></tr>
		<tr><td width="200">a</td><td width="200">* Contador para controlar el número de asteriscos */</td></tr>
             </table><br>
                <p><b>Fórmulas Relevantes</b></p>
                <table>
                  <tr><td><em>num = num % 2</em></td><td>(1)</td><td>/* Fórmula que calcula si un número es par */</td></tr>
                  <tr><td ><em>num = (num = 1)/2</em></td><td> (2) </td><td>/* Fórmula que obtiene la mitad de un valor impar y lo convierte a un valor par */</td></tr>
                <tr><td width="120"><em>num = num/2</em></td><td width="30"> (3) </td><td width="280">/* Fórmula que obtiene la mitad de un valor par */</td></tr>
                  <tr><td ><em>b = h - f</em></td><td> (4) </td><td>/* Fórmula que obtiene un número definido de  espacios en blanco de acuerdo al valor de la altura del triánguo isósceles y al valor de la fila */</td></tr>
                <tr><td><em>a = 2 * f - 1</em></td><td>(5)</td><td>/* Fórmula que obtiene un número impar de  asteriscos de acuerdo al valor de la fila */</td></tr>
                </table> <br>

                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.24.1 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘diagonalMayor’; b) Salidas: Mensaje1 que imprime un espacio en blanco; Mensaje2 que imprime un asterisco; Mensaje3 que imprime un INTRO; c) Auxiliares: la variable ‘altura’; la variable ‘f’; la variable ‘b’; la variable ‘a’.</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.24.1.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.24.1. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                
			<p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el valor de la diagonal mayor del rombo.</li>
                  <li>Si el valor de la diagonal mayor es impar, entonces</li>
                  <ol type="1" start="2">
                    <li>1. Asignar a la variable ‘altura’ el valor de la diagonal mayor más uno dividido para dos.</li>
                  </ol>
		<li>Caso contrario,</li>
    <ol type="1" start="3">
      <li>Asignar a la variable ‘altura’ el valor de la mitad de la diagonal mayor.</li>
    </ol>
		<li>Para el bucle externo, hacer: </li>                  
                  <ol type="1" start="4">
                    <li>1. Inicializar el valor del contador de las filas ‘f’ en uno. </li>
                  </ol><ol type="1" start="4">
                    <li>2. Mientras el valor de la condición (f &lt;= altura), sea verdadera, ejecutar las sentencias del bucle. </li>
                  </ol><ol type="1" start="4">
                    <li>3. Luego de cada iteración incrementar en uno el valor del contador de las filas ‘f’. </li>
                  </ol><ol type="1" start="4">
                    <li>4. Para el bucle interno, hacer: </li>
                    <ol type="1" start="4">
                      <li>4.1.	Inicializar el valor de las columnas de blancos ‘b’ con el valor de la variable 'altura' menos el número de filas.  </li></ol>
                      <ol type="1" start="4">
                        <li>4.2.	Mientras la condición (b &gt;= 1) sea verdadera, ejecutar las sentencias del bucle interno.  </li></ol>
                        <ol type="1" start="4">
                          <li>4.3.	Luego de cada iteración decrementar el valor de las columnas de blancos ‘b’ en uno. </li></ol>
                          <ol type="1" start="4">
                            <li>4.4.	Imprimir un espacio en blanco por columna. </li></ol>
                  </ol><ol type="1" start="4">
                    <li>5.	Para el bucle interno, hacer:  </li>
                    <ol type="1" start="4">
                      <li>5.1.	Inicializar el valor de las columnas de asteriscos ‘a’ en uno. </li></ol>
                      <ol type="1" start="4">
                        <li>5.2.	Mientras la condición (a &lt;= 2 * f - 1) sea verdadera, ejecutar las sentencias del bucle interno. </li></ol>
                        <ol type="1" start="4">
                          <li>5.3.	Luego de cada iteración incrementar el valor de las columnas de asteriscos ‘a’ en uno. </li></ol>
                          <ol type="1" start="4">
                            <li>5.4.	Imprimir un asterisco por columna. </li></ol>
                    </ol><ol type="1" start="4">
                    <li>6.	Imprimir un salto de línea (INTRO). </li></ol>
                 <li>Para el bucle externo, hacer: </li>
                 <ol type="1" start="5">
                  <li>1. Inicializar el valor de las filas ‘f’ con el valor de la variable ‘altura’ menos uno. </li>
                </ol><ol type="1" start="5">
                  <li>2. Mientras el valor de la condición (f &gt;= altura), sea verdadera, ejecutar las sentencias del bucle externo. </li>
                </ol><ol type="1" start="5">
                  <li>3. Luego de cada iteración decrementar en uno el valor del contador de las filas ‘f’. </li>
                </ol><ol type="1" start="5">
                  <li>4. Para el bucle interno, hacer: </li>
                  <ol type="1" start="5">
                    <li>4.1.	Inicializar el valor de las columnas de blancos ‘b’ con el valor de la variable 'altura' menos el número de filas.  </li></ol>
                    <ol type="1" start="5">
                      <li>4.2.	Mientras la condición (b &gt;= 1) sea verdadera, ejecutar las sentencias del bucle interno.  </li></ol>
                      <ol type="1" start="5">
                        <li>4.3.	Luego de cada iteración decrementar el valor de las columnas de blancos ‘b’ en uno. </li></ol>
                        <ol type="1" start="5">
                          <li>4.4.	Imprimir un espacio en blanco por columna. </li></ol>
                </ol><ol type="1" start="5">
                  <li>5.	Para el bucle interno, hacer:  </li>
                  <ol type="1" start="5">
                    <li>5.1.	Inicializar el valor de las columnas de asteriscos ‘a’ en uno. </li></ol>
                    <ol type="1" start="5">
                      <li>5.2.	Mientras la condición (a &lt;= 2 * f - 1) sea verdadera, ejecutar las sentencias del bucle interno. </li></ol>
                      <ol type="1" start="5">
                        <li>5.3.	Luego de cada iteración incrementar el valor de las columnas de asteriscos ‘a’ en uno. </li></ol>
                        <ol type="1" start="5">
                          <li>5.4.	Imprimir un asterisco por columna. </li></ol>
                  </ol><ol type="1" start="5">
                  <li>6.	Imprimir un salto de línea (INTRO). </li></ol>
		
                  </ol>

                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.24.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.24.1. </b>Programa que analiza si un número leído es palíndromo.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_24_1"  [lineNumbers]="true"></code></pre> <br>
                <h2>E) Pruebas</h2>
                <p>En la Tabla 2.24.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los obtenidos en una hoja de cuadros o de papel milimetrado.</p>
	            	<p>En la salida de la Tabla 2.24.2 se puede ver que, al ingresar el valor de la diagonal mayor igual a 9 se obiene el rombo de asteriscos compuesto por dos triángulos isósceles, el uno de altura igual a 5 y el otro de altura igual a 4.</p>
                <h5><b>Tabla 2.24.2.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.24.2.png" style="display:block; margin:auto; "><br>
                  <p>En la Tabla 2.24.3 se puede ver la primera parte de la prueba de escritorio del programa, donde se almacena en la variable ‘diagonalMayor’ el valor de 9. Luego se verifica que este valor es impar utilizando el operador de módulo (%). Como este valor es impar, se suma el valor de uno obteniéndose 10 y ese resultado se divide para 2 obteniéndose el valor de 5 en la variable altura, caso contrario, se dividiría directamente para 2.</p>
               <h5><b>Tabla 2.24.3. </b>Prueba de escritorio del programa (primera parte).</h5>
            		<table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                <tr style="color:red"><td>diagonalMayor</td><td>diagonalMayor % 2 != 0</td><td>altura = (diagonalMayor + 1)/2;</td></tr>
                <tr><td>9</td><td>9 % 2 != 0 (V)</td><td>(9 + 1)/2 = 10/2 = 5</td></tr>                
               </table> <br>
                <br>
                <p>En la Tabla 2.24.4 se puede ver la segunda parte de la prueba de escritorio del programa, donde la impresión de la mitad del rombo de asteriscos es un triángulo isósceles cuyo valor de altura es 5, se realiza mediante un bucle externo y dos bucles internos. Cada vez que se repite el bucle externo incremental, se ejecutan los dos bucles internos. El bucle externo incremental se repite cinco veces en este caso, según la altura del triángulo y se controla con el contador de las filas ‘f’. El número de repeticiones realizadas por los bucles internos se basan en el valor del contador de las filas ‘f’. El primer bucle interno controla la impresión de los espacios en blanco con el contador ‘b’ y el segundo bucle interno controla la impresión de los asteriscos con el contador ‘a’.</p>
                <h5><b>Tabla 2.24.4. </b>Prueba de escritorio del programa (segunda parte).</h5>
                <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5" style="font-size:x-small" HEIGHT="50"> 
                  <tr style="color:red"><td>altura</td><td>f</td><td>f &lt;= altura</td><td>b</td><td>b &gt;= 1</td><td>cout &lt;&lt;= " ";</td><td>a</td><td>a &lt;= 2 * f - 1</td><td>cout &lt;&lt; "*"; </td><td>cout &lt;&lt; endl;</td></tr>
                  <tr><td>5</td><td>1</td><td>1 &lt;= 5 (V)</td><td>4</td><td>4 &gt;= 1 (V)</td><td>bbbb</td><td>1</td><td>1 &lt;= 1 (V)</td><td>*</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td style="color:rgb(33, 15, 201)">2</td><td style="color:rgb(33, 15, 201)">2 &lt;= 1 (F)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td><td></td><td></td><td>INTRO</td></tr>
                
                  <tr><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td>3</td><td>3 &gt;= 1 (V)</td><td>bbb</td><td>1</td><td>1 &lt;= 3 (V)</td><td>***</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td>2</td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>3</td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td style="color:rgb(33, 15, 201)">4</td><td style="color:rgb(33, 15, 201)"> 4 &lt;= 3 (F)</td><td></td><td>INTRO</td></tr>
                
                  <tr><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td>2</td><td> 2 &gt;= 1 (V)</td><td>bb</td><td>1</td><td>1 &lt;= 5 (V)</td><td>*****</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td>INTRO</td></tr>
                  
                  <tr><td></td><td>4</td><td>4 &lt;= 4 (V)</td><td>1</td><td>1 &gt;= 1 (V)</td><td>b</td><td>1</td><td>1 &lt;= 7 (V)</td><td>*******</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>2</td><td>2&lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>6</td><td>6 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>7</td><td>7 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">8</td><td style="color:rgb(33, 15, 201)">8 &lt;= 7 (F)</td><td></td><td>INTRO</td></tr>
                  
                  <tr><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>1</td><td>1 &lt;= 9 (V)</td><td>*********</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>2</td><td>2 &lt;= 9 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 9 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 9 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 9 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>6</td><td>6 &lt;= 9 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>7</td><td>7 &lt;= 9 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>8</td><td>8 &lt;= 9 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>9</td><td>9 &lt;= 9 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">10</td><td style="color:rgb(33, 15, 201)">10 &lt;= 9 (F)</td><td></td><td>INTRO</td></tr>
                  
                  <tr><td></td><td style="color:rgb(33, 15, 201)">6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
                </table><br>
               <p>En la Tabla 2.24.5 se puede ver la tercera parte de la prueba de escritorio del programa, donde la impresión de la mitad del rombo de asteriscos es un triángulo isósceles invertido cuyo valor de altura es 4, se realiza mediante un bucle externo y dos bucles internos. Cada vez que se repite el bucle externo decremental, se ejecutan los dos bucles internos. El bucle externo decremental se repite cuatro veces en este caso, según la altura del triángulo y se controla con el contador de las filas ‘f’. El número de repeticiones realizadas por los bucles internos se basan en el valor del contador de las filas ‘f’. El primer bucle interno controla la impresión de los espacios en blanco con el contador ‘b’ y el segundo bucle interno controla la impresión de los asteriscos con el contador ‘a’.</p>
                <h5><b>Tabla 2.24.5. </b>Prueba de escritorio del programa (tercera parte).</h5>
              
                <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5" style="font-size:x-small" HEIGHT="50"> 
                  <tr style="color:red"><td>altura</td><td>f</td><td>f &gt;= 1</td><td>b</td><td>b &gt;= 1</td><td>cout &lt;&lt;= " ";</td><td>a</td><td>a &lt;= 2 * f - 1</td><td>cout &lt;&lt; "*"; </td><td>cout &lt;&lt; endl;</td></tr>
                  
                  <tr><td>5</td><td>4</td><td>4 &gt;= 1 (V)</td><td>1</td><td>1 &gt;= 1 (V)</td><td>b</td><td>1</td><td>1 &lt;= 7 (V)</td><td>*******</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>2</td><td>2&lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>6</td><td>6 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>7</td><td>7 &lt;= 7 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">8</td><td style="color:rgb(33, 15, 201)">8 &lt;= 7 (F)</td><td></td><td>INTRO</td></tr>
                                
                  <tr><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td>2</td><td> 2 &gt;= 1 (V)</td><td>bb</td><td>1</td><td>1 &lt;= 5 (V)</td><td>*****</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td>INTRO</td></tr>
                  
                  <tr><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td>3</td><td>3 &gt;= 1 (V)</td><td>bbb</td><td>1</td><td>1 &lt;= 3 (V)</td><td>***</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td>2</td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>3</td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td style="color:rgb(33, 15, 201)">4</td><td style="color:rgb(33, 15, 201)"> 4 &lt;= 3 (F)</td><td></td><td>INTRO</td></tr>
                
                  <tr><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td>4</td><td>4 &gt;= 1 (V)</td><td>bbbb</td><td>1</td><td>1 &lt;= 1 (V)</td><td>*</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td style="color:rgb(33, 15, 201)">2</td><td style="color:rgb(33, 15, 201)">2 &lt;= 1 (F)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td><td></td><td></td><td>INTRO</td></tr>

                  <tr><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
                </table><br>
                <h1><b>Caso de Estudio 2.25: Visualización de un Rombo con Espacios en Blanco.</b></h1>
                <h2><b>A) Problema</b></h2>
                <p>Escribir un programa que permita visualizar un rombo de asteriscos. Así, por ejemplo, si el valor de la Diagonal mayor es igual a 9 o a 10, se obtendrá la siguiente figura:</p>
                <table border="1" align="center" cellspacing="0" cellpadding="5">
                  <tr><td width="200"><p>************</p><p>*****bb*****</p><p>****bbbb****</p><p>***bbbbbb***</p><p>**bbbbbbbb**</p><p>*bbbbbbbbbbb*</p>
                    <p>**bbbbbbbb**</p><p>***bbbbbb***</p><p>****bbbb****</p><p>*****bb*****</p><p>***********</p>	</td></tr>
                </table><br>
                
                <table border="1" CELLPADDING=5 CELLSPACING=0>
                  <tr VALIGN=top><td width="50"><b> Nota:</b></td><td>Como se puede ver en la figura anterior, la primera y la última fila de la figura es un caso especial. Mientras se reduce el número de ateriscos, aumenta el número de espacios en blanco, tanto de arriba hacia abajo, como de abajo hacia arriba. Con fines didácticos, la letra ‘b’ en color plomo equivale a un espacio en blanco (“ ”).</td></tr>
                </table><br>
                
                
                <h2><b>B) Análisis</b></h2>
                <p>Claramente se puede ver que la única entrada del problema es el valor de la diagonal mayor del rombo. Se requieren dos salidas que son los espacios en blanco y los asteriscos de la figura geométrica controlados por los contadores ‘b’ y ‘a’ respectivamente. Se requiere una variable auxiliar llamada ‘aux’ que tiene el valor de la mitad de la diaginal del rombo. El proceso de cálculo y visualización del rombo con asteriscos requiere la utilización de bucles anidados.</p>

    <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Entradas del Problema</b></p>		
                <table>
                              <tr><td width="200"> diagonalMayor </td><td width="200">/* Tamaño de la diagonal mayor del rombo  */</td></tr>
                            </table><br>
                            <p><b>Salidas del Problema</b></p>
                            <table>
                              <tr><td width="200"> Mensaje1 </td><td width="200">/* Mensaje que imprime un espacio en blanco */</td></tr>
                              <tr><td width="200"> Mensaje2 </td><td width="200">/* Mensaje que imprime un asterisco */</td></tr>
                              <tr><td width="200"> Mensaje3 </td><td width="200">/* Mensaje que imprime un INTRO */</td></tr>
                            </table><br>
                <p><b>Auxiliares del Problema</b></p>
                          <table>
                <tr><td width="200">altura</td><td width="200">/* Altura que representa la mitad de la diagonal mayor del rombo */</td></tr>
                <tr><td width="200">f</td><td width="200">/* Número de filas */</td></tr>
                <tr><td width="200">b</td><td width="200">/* Contador para controlar el número de espacios en blanco */</td></tr>
                <tr><td width="200">a</td><td width="200">* Contador para controlar el número de asteriscos */</td></tr>
                         </table><br>
                            <p><b>Fórmulas Relevantes</b></p>
                            <table>
                              <tr><td><em>num = num % 2</em></td><td>(1)</td><td>/* Fórmula que calcula si un número es par */</td></tr>
                              <tr><td ><em>num = (num = 1)/2</em></td><td> (2) </td><td>/* Fórmula que obtiene la mitad de un valor impar y lo convierte a un valor par */</td></tr>
                            <tr><td width="120"><em>num = num/2</em></td><td width="30"> (3) </td><td width="280">/* Fórmula que obtiene la mitad de un valor par */</td></tr>
                              <tr><td ><em>a = h * 2 + 2</em></td><td> (4) </td><td>/* Fórmula que obtiene el número total de asteriscos en la primera y última fila de acuerdo a la altura del triánguo isósceles */</td></tr>
                            <tr><td><em>a = (h + 1) - f</em></td><td>(5)</td><td>/* Fórmula que obtiene un número determinado de  asteriscos de acuerdo al valor de la fila y de la altura del triánguo isósceles */</td></tr>
                          <tr><td><em>b = 2 * f</em></td><td>(6)</td><td>/* Fórmula que obtiene un número par de  espacios en blanco de acuerdo al valor de la fila */</td></tr>  
                          </table> <br>
                  <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                  <p>En la Figura 2.25.1 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘diagonalMayor’; b) Salidas: Mensaje1 que imprime un asterisco; Mensaje2 que imprime un espacio en blanco; Mensaje3 que imprime un INTRO; c) Auxiliares: la variable ‘altura’; la variable ‘f’; la variable ‘b’; la variable ‘a’.</p>
                  <img src="./assets/images/Capitulos/II/media/Figura 2.25.1.png" style="display:block; margin:auto; "><br>
                  <h5 style="text-align:center"><b>Figura 2.25.1. </b>Diagrama de Entrada-Salida del Programa.</h5>
                  <h2><b>C) Diseño</b></h2>
                  <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                  
        <p><b>Algoritmo</b></p>
                  <ol type="1">
                 <li>Leer el valor de la diagonal mayor del rombo.</li>   
                   <li>Si el valor de la diagonal mayor es impar, entonces</li> 
                   <ol type="1" start="2"><li>1.	Asignar a la variable ‘altura’ el valor de la diagonal mayor más uno dividido para dos.</li></ol>          
      <li>Caso contrario,</li>
      <ol type="1" start="3"><li>1.	Asignar a la variable ‘altura’ el valor de la mitad de la diagonal mayor.</li></ol>
      <li>4.	Para el bucle, hacer:</li>            
      <ol type="1" start="4">
                      <li>1.	Inicializar el valor de las columnas de asteriscos 'a' en uno.</li>
                    </ol><ol type="1" start="4">
                      <li>2.	Mientras la condición (a &lt;= altura * 2 + 2) sea verdadera, ejecutar las sentencias del bucle externo.</li>
                    </ol><ol type="1" start="4">
                      <li>3.	Luego de cada ciclo incrementar el valor de las columnas de asteriscos 'a' en uno.</li>
                    </ol><ol type="1" start="4">
                      <li>4.	Imprimir un asterisco por columna.</li>
                      </ol>
      <li>Imprimir un salto de línea o INTRO.</li>
      <li>Para el bucle externo, hacer: </li>
                    <ol type="1" start="6">
                      <li>1.	Inicializar el valor del contador de las filas ‘f’ en uno. </li>
                    </ol><ol type="1" start="6">
                      <li>2.	Mientras el valor de la condición (f &lt;= altura), sea verdadera, ejecutar las sentencias del bucle externo. </li>
                    </ol><ol type="1" start="6">
                      <li>3.	Luego de cada iteración incrementar en uno el valor del contador de las filas ‘f’. </li>
                    </ol><ol type="1" start="6">
                      <li>4.	Para el bucle interno, hacer: </li>
                            <ol type="1" start="6"><li>4.1.	Inicializar el valor de las columnas de asteriscos ‘a’ con el valor de (altura + 1) - f. </li></ol>
                            <ol type="1" start="6"><li>4.2.	Mientras la condición (a &gt;= 1) sea verdadera, ejecutar las sentencias del bucle interno. </li></ol>
                            <ol type="1" start="6"><li>4.3.	Luego de cada iteración decrementar el valor de las columnas de asteriscos ‘a’ en uno.</li></ol>
                            <ol type="1" start="6"><li>4.4.	Imprimir un asterisco por columna.</li></ol>
            </ol><ol type="1" start="6">
         <li>5. Para el bucle interno, hacer</li>
         <ol type="1" start="6"><li>5.1.	Inicializar el valor de las columnas de blancos ‘b’ con el valor de uno. </li></ol>
         <ol type="1" start="6"><li>5.2.	Mientras la condición (b &lt;= 2 * f) sea verdadera, ejecutar las sentencias del bucle interno. </li></ol>
         <ol type="1" start="6"><li>5.3.	Luego de cada iteración incrementar el valor de las columnas de blancos ‘b’ en uno.</li></ol>
         <ol type="1" start="6"><li>6.5.4.	Imprimir un espacio en blanco por columna.</li></ol>
                    </ol><ol type="1" start="6">
         <li>6.	Para el bucle interno, hacer: .</li>
         <ol type="1" start="6"><li>6.1.	Inicializar el valor de las columnas de asteriscos ‘a’ con el valor de (altura + 1) - f. </li></ol>
         <ol type="1" start="6"><li>6.2.	Mientras la condición (a &gt;= 1) sea verdadera, ejecutar las sentencias del bucle interno. </li></ol>
         <ol type="1" start="6"><li>6.3.	Luego de cada iteración decrementar el valor de las columnas de asteriscos ‘a’ en uno.</li></ol>
         <ol type="1" start="6"><li>6.4.	Imprimir un asterisco por columna.</li></ol>
                    </ol>
      <li>Para el bucle externo, hacer: </li>
      <ol type="1" start="7"><li>1.	Inicializar el valor de las filas ‘f’ con el valor de la variable ‘altura’ menos uno</li></ol>
      <ol type="1" start="7"><li>2.	Mientras la condición (f &gt;= 1) sea verdadera, ejecutar las sentencias del bucle externo. </li></ol>
      <ol type="1" start="7"><li>3.	Luego de cada iteración decrementar en uno el valor del contador de las filas ‘f’. </li></ol>
      <ol type="1" start="7"><li>4.	Para el bucle interno, hacer: </li>
        <ol type="1" start="7"><li>4.1.	Inicializar el valor de las columnas de asteriscos ‘a’ con el valor de (altura + 1) - f. </li></ol>
        <ol type="1" start="7"><li>4.2.	Mientras la condición (a &gt;= 1) sea verdadera, ejecutar las sentencias del bucle interno. </li></ol>
        <ol type="1" start="7"><li>4.3.	Luego de cada iteración decrementar el valor de las columnas de asteriscos ‘a’ en uno.</li></ol>
        <ol type="1" start="7"><li>4.4.	Imprimir un asterisco por columna.</li></ol>
      </ol>
      <ol type="1" start="7"><li>5.	Para el bucle interno, hacer: </li>
        <ol type="1" start="7"><li>5.1.	Inicializar el valor de las columnas de blancos ‘b’ con el valor de uno. </li></ol>
        <ol type="1" start="7"><li>5.2.	Mientras la condición (b &lt;= 2 * f) sea verdadera, ejecutar las sentencias del bucle interno. </li></ol>
        <ol type="1" start="7"><li>5.3.	Luego de cada iteración incrementar el valor de las columnas de blancos ‘b’ en uno.</li></ol>
        <ol type="1" start="7"><li>5.4.	Imprimir un espacio en blanco por columna.</li></ol>
      </ol>
      <ol type="1" start="7"><li>6.	Para el bucle interno, hacer: </li>
        <ol type="1" start="7"><li>6.1.	Inicializar el valor de las columnas de asteriscos ‘a’ con el valor de (altura + 1) - f. </li></ol>
        <ol type="1" start="7"><li></li>7.6.2.	Mientras la condición (a &gt;= 1) sea verdadera, ejecutar las sentencias del bucle interno. </ol>
        <ol type="1" start="7"><li>6.3.	Luego de cada iteración decrementar el valor de las columnas de asteriscos ‘a’ en uno.</li></ol>
        <ol type="1" start="7"><li>6.4.	Imprimir un asterisco por columna.</li></ol>
      </ol>
      <ol type="1" start="7"><li>7. Imprimir un salto de línea (INTRO).</li></ol>
      <li>Para el bucle, hacer:</li>
      <ol type="1" start="8"><li>1.	Inicializar el valor de las columnas de asteriscos 'a' en uno.</li></ol>
      <ol type="1" start="8"><li>2.	Mientras la condición (a &lt;= altura * 2 + 2) sea verdadera, ejecutar las sentencias del bucle externo.</li></ol>
      <ol type="1" start="8"><li>3.	Luego de cada ciclo incrementar el valor de las columnas de asteriscos 'a' en uno.</li></ol>
      <ol type="1" start="8"><li>4.	Imprimir un asterisco por columna.</li></ol>
      <li>Imprimir un salto de línea o INTRO.</li>
                  </ol>
  
                  <h2><b>D) Implementación</b></h2>
                  <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.25.1 se muestra el código del programa en C/C++.</p>
                  <h5><b>Tabla 2.25.1. </b>Programa que analiza si un número leído es palíndromo.</h5>
                  <pre><code [highlight]="prefTab2[0].tabla2_25_1"  [lineNumbers]="true"></code></pre> <br>
                  <h2>E) Pruebas</h2>
                  <p>En la Tabla 2.25.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los obtenidos en una hoja de cuadros o de papel milimetrado.</p>
                  <p>En la salida de la Tabla 2.25.2 se puede ver que, al ingresar el valor de la diagonal mayor igual a 9 se obiene el rombo de espacios en blanco compuesto por dos triángulos isósceles, el uno de altura igual a 5 y el otro de altura igual a 4.</p>
                  <h5><b>Tabla 2.25.2.</b> Salida del programa</h5>
                  <img src="./assets/images/Capitulos/II/media/Tabla 2.25.2.png" style="display:block; margin:auto; "><br>
                  <p>En la Tabla 2.25.3 se puede ver la primera parte de la prueba de escritorio del programa, donde se almacena en la variable ‘diagonalMayor’ el valor de 9. Luego se verifica que este valor es impar utilizando el operador de módulo (%). Como este valor es impar, se suma el valor de uno obteniéndose 10 y ese resultado se divide para 2 obteniéndose el valor de 5 en la variable altura, caso contrario, se dividiría directamente para 2.</p>
                 
                 <h5><b>Tabla 2.25.3. </b>Prueba de escritorio del programa (primera parte).</h5>
                 <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                 <tr style="color:red"><td>diagonalMayor</td><td>diagonalMayor % 2 != 0</td><td>altura = (diagonalMayor + 1)/2;</td></tr>
                 <tr><td>9</td><td>9 % 2 != 0 (V)</td><td>(9 + 1)/2 = 10/2 = 5</td></tr>                
                </table> <br>
                 <br>
                 <p>En la Tabla 2.25.4 se puede ver la segunda parte de la prueba de escritorio del programa, donde se imprime la primera fila de asteriscos mediante un bucle for() y al terminar la ejecución de este bucle se imprime un salto de línea (INTRO).</p>
                 <h5><b>Tabla 2.25.4. </b>Prueba de escritorio del programa (segunda parte).</h5>
                 <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                  <tr style="color:red"><td>altura</td><td>a</td><td>a &lt;= altura * 2 + 2</td><td>cout &lt;&lt; "*"; </td><td>cout &lt;&lt; endl;</td></tr>
                  <tr><td>5</td><td>1</td><td>1 &lt;= 12 (V)</td><td>************</td><td></td></tr>
                  <tr><td></td><td>2</td><td>2 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>3</td><td>3 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>4</td><td>4 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>5</td><td>5 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>6</td><td>6 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>7</td><td>7 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>8</td><td>8 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>9</td><td>9 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>10</td><td>10 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>11</td><td>11 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td>12</td><td>12 &lt;= 12 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td style="color:rgb(33, 15, 201)">13</td><td style="color:rgb(33, 15, 201)">13 &lt;= 12 (V)</td><td></td><td>INTRO</td></tr>
                   </table>
                <br>
                 
                <p>En la Tabla 2.25.5 se puede ver la tercera parte de la prueba de escritorio del programa, donde la impresión de la mitad del rombo de espacios en blanco, es un triángulo isósceles cuyo valor de altura es 5, se realiza mediante un bucle externo y tres bucles internos. Cada vez que se repite el bucle externo incremental, se ejecutan los tres bucles internos. El bucle externo incremental se repite cinco veces en este caso, según la altura del triángulo y se controla con el contador de las filas ‘f’. El número de repeticiones realizadas por los bucles internos se basan en el valor del contador de las filas ‘f’ y de la altura del triángulo isósceles. El primer bucle interno controla la impresión del primer grupo de asteriscos con el contador ‘a’. El segundo bucle interno controla la impresión de los espacios en blanco con el contador ‘b’. El tercer bucle interno controla la impresión del segundo grupo de asteriscos con el contador ‘a’. </p>
                <h5><b>Tabla 2.25.5. </b>Prueba de escritorio del programa (tercera parte).</h5>
                 <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5" style="font-size:x-small" HEIGHT="50"> 
                   <tr style="color:red"><td>altura</td><td>f</td><td>f &lt;= altura</td><td>a</td><td>a &gt;= 1</td><td>cout &lt;&lt;= "*";</td><td>b</td><td>b &lt;= 2 * f</td><td>cout &lt;&lt; " "; </td><td>a</td><td>a &gt;= 1</td><td>cout &lt;&lt; "*";</td><td>cout &lt;&lt; endl;</td></tr>
                   <tr><td>5</td><td>1</td><td>1 &lt;= 5 (V)</td><td>5</td><td>5 &gt;= 1 (V)</td><td>*****</td><td>1</td><td>1 &lt; 2 (V)</td><td>bb</td><td>5</td><td>5 &gt;= 1 (V)</td><td>*****</td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>4</td><td>4 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 2 (V)</td><td></td><td>4</td><td>4 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td style="color:rgb(33, 15, 201)">3</td><td style="color:rgb(33, 15, 201)">3 &lt;= 2 (F)</td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>INTRO</td></tr>
                 
                   <tr><td></td><td>2</td><td>2 &lt;= 5 (V)</td><td>4</td><td>4 &gt;= 1 (V)</td><td>****</td><td>1</td><td>1 &lt; 4 (V)</td><td>bbbb</td><td>4</td><td>4 &gt;= 1 (V)</td><td>****</td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 4 (V)</td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td>3</td><td>3 &lt;= 4 (V)</td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>4</td><td>4 &lt;= 4 (V)</td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td style="color:rgb(33, 15, 201)">5</td><td style="color:rgb(33, 15, 201)">5 &lt;= 4 (F)</td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>INTRO</td></tr>
                 
                   <tr><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td>3</td><td>3 &gt;= 1 (V)</td><td>***</td><td>1</td><td>1 &lt; 6 (V)</td><td>bbbbbbbb</td><td>3</td><td>3 &gt;= 1 (V)</td><td>***</td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>2</td><td>4 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 6 (V)</td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>1</td><td>3 &gt;= 1 (V)</td><td></td><td>3</td><td>3 &lt;= 6 (V)</td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>4</td><td>4 &lt;= 6 (V)</td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 6 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">7</td><td style="color:rgb(33, 15, 201)">7 &lt;=6 (F)</td><td></td><td></td><td></td><td></td><td>INTRO</td></tr>
                 
                   <tr><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td>2</td><td>2 &gt;= 1 (V)</td><td>**</td><td>1</td><td>1 &lt; 8 (V)</td><td>bbbbbbbbbb</td><td>2</td><td>2 &gt;= 1 (V)</td><td>**</td><td></td></tr>
                   <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 8 (V)</td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>3</td><td>3 &lt;= 8 (V)</td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>6</td><td>6 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>7</td><td>7 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>8</td><td>8 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">9</td><td style="color:rgb(33, 15, 201)">9 &lt;=8 (F)</td><td></td><td></td><td></td><td></td><td>INTRO</td></tr>
                 
                   <tr><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td>1</td><td>1 &gt;= 1 (V)</td><td>*</td><td>1</td><td>1 &lt; 10 (V)</td><td>bbbbbbbbbbbb</td><td>1</td><td>1 &gt;= 1 (V)</td><td>*</td><td></td></tr>
                   <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>2</td><td>2 &lt;= 10 (V)</td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>3</td><td>3 &lt;= 10 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 10 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 10 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>6</td><td>6 &lt;= 10 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>7</td><td>7 &lt;= 10 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>8</td><td>8 &lt;= 10 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>9</td><td>9 &lt;= 10 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>10</td><td>10 &lt;= 10 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                   <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">11</td><td style="color:rgb(33, 15, 201)">11 &lt;=8 (F)</td><td></td><td></td><td></td><td></td><td>INTRO</td></tr>
                 
                   <tr><td></td><td style="color:rgb(33, 15, 201)">6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
                 </table><br>
                 <p>En la Tabla 2.25.6 se puede ver la cuarta parte de la prueba de escritorio del programa, donde la impresión de la otra mitad del rombo de espacios en blanco es un triángulo isósceles invertido cuyo valor de altura es 4, se realiza mediante un bucle externo y tres bucles internos. Cada vez que se repite el bucle externo decremental, se ejecutan los tres bucles internos. El bucle externo decremental se repite cuatro veces en este caso, según la altura del triángulo y se controla con el contador de las filas ‘f’. El número de repeticiones realizadas por los bucles internos se basan en el valor del contador de las filas ‘f’ y de la altura del triángulo isósceles. El primer bucle interno controla la impresión del primer grupo de asteriscos con el contador ‘a’. El segundo bucle interno controla la impresión de los espacios en blanco con el contador ‘b’. El tercer bucle interno controla la impresión del segundo grupo de asteriscos con el contador ‘a’.</p>

                 <h5><b>Tabla 2.25.6. </b>Prueba de escritorio del programa (cuarta parte).</h5>
                 <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5" style="font-size:x-small" HEIGHT="50"> 
                  <tr style="color:red"><td>altura</td><td>f</td><td>f &gt;= 1</td><td>a</td><td>a &gt;= 1</td><td>cout &lt;&lt;= "*";</td><td>b</td><td>b &lt;= 2 * f</td><td>cout &lt;&lt; " "; </td><td>a</td><td>a &gt;= 1</td><td>cout &lt;&lt; "*";</td><td>cout &lt;&lt; endl;</td></tr>
                  <tr><td>5</td><td>4</td><td>4 &gt;= 1 (V)</td><td>2</td><td>2 &gt;= 1 (V)</td><td>**</td><td>1</td><td>1 &lt; 8 (V)</td><td>bbbbbbbbbb</td><td>2</td><td>2 &gt;= 1 (V)</td><td>**</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 8 (V)</td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>3</td><td>3 &lt;= 8 (V)</td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>4 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>6</td><td>6 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>7</td><td>7 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>8</td><td>8 &lt;= 8 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">9</td><td style="color:rgb(33, 15, 201)">9 &lt;=8 (F)</td><td></td><td></td><td></td><td></td><td>INTRO</td></tr>
                
                  <tr><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td>3</td><td>3 &gt;= 1 (V)</td><td>***</td><td>1</td><td>1 &lt; 6 (V)</td><td>bbbbbbbb</td><td>3</td><td>3 &gt;= 1 (V)</td><td>***</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>2</td><td>4 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 6 (V)</td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>3 &gt;= 1 (V)</td><td></td><td>3</td><td>3 &lt;= 6 (V)</td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>4</td><td>4 &lt;= 6 (V)</td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5 &lt;= 6 (V)</td><td></td><td></td><td></td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">7</td><td style="color:rgb(33, 15, 201)">7 &lt;=6 (F)</td><td></td><td></td><td></td><td></td><td>INTRO</td></tr>
                
                  <tr><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td>4</td><td>4 &gt;= 1 (V)</td><td>****</td><td>1</td><td>1 &lt; 4 (V)</td><td>bbbb</td><td>4</td><td>4 &gt;= 1 (V)</td><td>****</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 4 (V)</td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td>3</td><td>3 &lt;= 4 (V)</td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td>4</td><td>4 &lt;= 4 (V)</td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td style="color:rgb(33, 15, 201)">5</td><td style="color:rgb(33, 15, 201)">5 &lt;= 4 (F)</td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>INTRO</td></tr>
                
                  <tr><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td>5</td><td>5 &gt;= 1 (V)</td><td>*****</td><td>1</td><td>1 &lt; 2 (V)</td><td>bb</td><td>5</td><td>5 &gt;= 1 (V)</td><td>*****</td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>4</td><td>4 &gt;= 1 (V)</td><td></td><td>2</td><td>2 &lt;= 2 (V)</td><td></td><td>4</td><td>4 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td style="color:rgb(33, 15, 201)">3</td><td style="color:rgb(33, 15, 201)">3 &lt;= 2 (F)</td><td></td><td>3</td><td>3 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td>2</td><td>2 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td><td></td><td></td><td>1</td><td>1 &gt;= 1 (V)</td><td></td><td></td></tr>
                  <tr><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td><td></td><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td>INTRO</td></tr>
                   <tr><td></td><td style="color:rgb(33, 15, 201)">0</td><td style="color:rgb(33, 15, 201)">0 &gt;= 1 (F)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
                </table><br>
              
                <h1><b>Caso de Estudio 2.26: Serie de la Función Exponencial <em>y = e <sup>x</sup></em>.</b></h1>
                <h2><b>A) Problema</b></h2>
                <p>El valor de la función y=e^x se puede aproximar mediante la siguiente serie de Taylor:</p>
                <table align="right">
                  <td width="350">e<sup>x</sup>= 1 + <sup>x</sup>/<sub>1!</sub> + <sup>x<sup>2</sup></sup>/<sub>2!</sub> + <sup>x<sup>3</sup></sup>/<sub>3!</sub> + ... + <sup>x<sup>n</sup></sup>/<sub>n!</sub></td>
                <td align="right">(1)</td>
                </table><br><br>
                <p>La fórmula de la sumatoria de la función es:</p>
                <table align="right">
                  <td width="350">e<sup>x</sup>= &Sigma;<sup><font size="2">&infin;</font></sup><sub><font size="2">n=0</font></sub>  <sup>x<sup>n</sup></sup>/<sub>n!</sub></td>
                <td align="right">(2)</td>
                </table><br><br>
                <p>Escribir un programa que permita aproximar el valor de la función exponencial y=e^x utilizando la serie de Taylor y bucles anidados.</p>
                <h2><b>B) Análisis</b></h2>
                <p>Claramente se puede ver que las entradas del problema son el número de términos de la serie y el valor del exponente de la función exponencial. Se requiere una sola salida que es el valor de la serie aproximada. El proceso de cálculo requiere que la serie numérica infinita de la ecuación (2), se convierta a una serie numérica finita, donde el valor de ‘n’ se convierte en el valor de ‘i’ y el valor de infinito pasa a ser el valor de n-1, ya que si se quiere calcular la sumatoria de los cinco primeros términos de la serie, la sumatoria iría desde el valor de i = 0 hasta el valor de i = 5 - 1, es decir, i = 4, como se puede ver en la ecuación (3):</p>
                <table align="right">
                  <td width="350">e<sup>x</sup>= &Sigma;<sup><font size="2">n-1</font></sup><sub><font size="2">i=0</font></sub>  <sup>x<sup>i</sup></sup>/<sub>i!</sub></td>
                <td align="right">(3)</td>
                </table><br><br>
                 <p>Para calcular el valor del factorial de la función seno se requiere utilizar la sucesión del factorial de un número cuya ecuación es:</p>
                 <table align="right">
                  <td width="350">n! = &prod;<sup><font size="2">&infin;</font></sup><sub><font size="2">n=1</font></sub>  n </td>
                <td align="right">(4)</td>
                </table><br><br>
                <p>Por lo que, el factorial de (i) es:</p>
                <table align="right">
                  <td width="350">i! = &prod;<sup><font size="2">i</font></sup><sub><font size="2">j=1</font></sub>  j</td>
                <td align="right">(5)</td>
                </table><br><br>
                <p>Reemplazando el valor de la ecuación (5) en la ecuación (3) se tiene:</p>
                <table align="right">
                  <td width="350">e<sup>x</sup>= &Sigma;<sup><font size="2">n-1</font></sup><sub><font size="2">i=0</font></sub>  <sup>x<sup>i</sup></sup>/<sub> [ &prod;<sup><font size="1">i</font></sup><sub><font size="1">j=1</font></sub>  j ]</sub></td>
                <td align="right">(6)</td>
                </table><br><br>  <br>              
              <p>Como se puede ver en la ecuación (6) se requiere utilizar dos bucles anidados; un bucle externo para calcular la sumatoria y un bucle interno para calcular el factorial de un número que básicamente es un producto.</p>
                  
    <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Entradas del Programa</b></p>
                    
      <table>
                    <tr><td width="200"> n </td><td width="200">/* número de términos de la serie */</td></tr>
                    <tr><td>x</td><td>/* Exponente de la función exponencial */</td></tr>
                  </table><br>
                  <p><b>Salidas del Problema</b></p>
                  <table>
                    <tr><td width="200"> serie </td><td width="200">/* Resultado de la serie aproximada  */</td></tr>
                  </table><br>
      <p><b>Auxiliares del Problema</b></p>
                <table>
                 <tr><td width="200">i</td><td width="200">/* Contador para controlar la sumatoria */</td></tr>
                <tr><td width="200">j</td><td width="200">/* Contador para controlar el factorial de un número */</td></tr>
                <tr><td width="200">sum</td><td width="200">/* Acumulador de sumas */</td></tr>
                <tr><td width="200">prod</td><td width="200">/* Acumulador de productos */</td></tr>
               </table><br>
                  <p><b>Fórmulas Relevantes</b></p>
                  <table>
                <tr><td ><i>prod = prod ∙ valor </i></td><td> (1) </td><td>/* Fórmula que representa el acumulador de un producto */</td></tr>
                  <tr><td width="120"><i>sum = sum + valor</i></td><td width="30"> (2) </td><td width="280">/* Fórmula que representa el acumulador de una sumatoria */</td></tr>
                    <tr><td >n! = &prod;<sup><font size="2">&infin;</font></sup><sub><font size="2">n=1</font></sub>  n</td><td> (3) </td><td>/* Fórmula que representa el factorial de un número */</td></tr>
                    <tr><td >e<sup>x</sup>= &Sigma;<sup><font size="2">n-1</font></sup><sub><font size="2">i=0</font></sub>  <sup>x<sup>i</sup></sup>/<sub> [ &prod;<sup><font size="1">i</font></sup><sub><font size="1">j=1</font></sub>  j ]</sub></td><td> (4) </td><td>/* Fórmula que representa la serie de la función exponencial incluido el factorial de un número */</td></tr>
                  </table> <br>
  
                  <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                  <p>En la Figura 2.26.1 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘n’; la variable ‘x’; b) Salidas: la variable ‘serie’; c) Auxiliares: el contador ‘i’; el contador ‘j’; la variable ‘prod’; la variable ‘sum’.</p>
                  <img src="./assets/images/Capitulos/II/media/Figura 2.26.1.png" style="display:block; margin:auto; "><br>
                  <h5 style="text-align:center"><b>Figura 2.20.3. </b>Diagrama de Entrada-Salida del Programa.</h5>
                  <h2><b>C) Diseño</b></h2>
                  <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                  
        <p><b>Algoritmo</b></p>
                  
                  <ol type="1">
                    <li>Imprimir el mensaje de información: Serie de la Función Exponencial y=e <sup>x</sup>.</li>
                    <li>Leer el número de términos de la serie, utilizando la variable ‘n’.</li>
                    <li>Leer el valor del exponente de la función exponencial, utilizando la variable ‘x’.</li>
                    <li>Inicializar con el valor de cero el acumulador de sumas cuya variable utilizada es ‘sum’.</li>
                    <li>Para el bucle externo, hacer: </li>
                    <ol type="1" start="5"><li>1.	Inicializar el valor del contador ‘i’ en cero. </li></ol>
                    <ol type="1" start="5"><li>2.	Mientras el valor de la condición (i &lt;=n-1) sea verdadera ejecutar las sentencias del bucle externo. </li></ol>
                    <ol type="1" start="5"><li>3.	Luego de cada iteración incrementar en uno el valor del contador ‘i’. </li></ol>
                    <ol type="1" start="5"><li>4.	Inicializar el acumulador de productos ‘prod’ con el valor de uno.</li></ol>
                    <ol type="1" start="5"><li>5.	Para el bucle interno, hacer: </li>
                      <ol type="1" start="5"><li>5.1.	Inicializar el valor del contador ‘j’ en uno.</li></ol>
                      <ol type="1" start="5"><li>5.2.	Mientras el valor de la condición (j&lt;=i) sea verdadera ejecutar las sentencias del bucle interno.</li></ol>
                      <ol type="1" start="5"><li>5.3.	Luego de cada iteración incrementar en uno el valor del contador ‘j’.</li></ol>
                      <ol type="1" start="5"><li>5.4.	Asignar al acumulador ‘prod’ lo que tiene multiplicado por el valor del contador ‘j’.</li></ol>
                    </ol>
                    <ol type="1" start="5"><li>6.	Asignar al acumulador ‘sum’ lo que tiene sumado el valor del término e-nésimo de la serie.</li></ol>

                    <li>Asignar a la variable serie el valor del acumulador ‘sum’.</li>
                    <li>Imprimir el valor de la serie aproximada.</li>
                  </ol>
  
                  <h2><b>D) Implementación</b></h2>
                  <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.26.1 se muestra el código del programa en C/C++.</p>
                  <h5><b>Tabla 2.26.1. </b>Programa que calcula la serie de la función exponencial y=e <sup>x</sup>..</h5>
                  <pre><code [highlight]="prefTab2[0].tabla2_26_1"  [lineNumbers]="true"></code></pre> <br>
                  <h2>E) Pruebas</h2>
                  <p>En la Tabla 2.26.2 y en la Tabla 2.26.3, se muestran dos ejemplos de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora científica.</p>
                  <p>En la salida de la Tabla 2.26.2 se puede ver que, al ingresar el número de términos igual a 10 y el valor del exponente igual a 1, se obtiene el valor de la serie aproximada igual a 2.71828.</p>
                  <h5><b>Tabla 2.26.2.</b> Salida del programa.</h5>
                  <img src="./assets/images/Capitulos/II/media/Tabla 2.26.2.png" style="display:block; margin:auto; "><br>
                  <p>En la salida de la Tabla 2.26.3 se puede ver que, al ingresar el número de términos igual a 10 y el valor del exponente igual a 2, se obtiene el valor de la serie aproximada igual a 7.38871.</p>
                 <h5><b>Tabla 2.26.3. </b>Salida del programa.</h5>
                 <img src="./assets/images/Capitulos/II/media/Tabla 2.26.3.png" style="display:block; margin:auto; "><br>
                  <p>En la Tabla 2.26.4, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada iteración del bucle externo for() se inicializa el acumulador del producto en 1 y luego se calcula el factorial de (i) utilizando un bucle interno for(). Luego de ejecutarse el bucle interno for() se utiliza un acumulador de sumas donde se acumulan los valores parciales de la serie de la función y la ejecución del bucle externo termina cuando la condición (i <= n - 1) de esta sentencia se hace falsa.</p>
                  <h5><b>Tabla 2.26.4. </b>Prueba de escritorio del programa.</h5>
                  <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                  <tr style="color:red"><td>n</td><td>x</td><td>Sum</td><td>i</td><td>i &lt;= n - 1</td><td>prod</td><td>j</td><td>i &lt;= i</td></tr>
                    <tr><td>6</td><td>1</td><td>0</td><td>0</td><td>0 &lt;= 5 (V)</td><td>1</td><td style="color:rgb(33, 15, 201)">1</td><td style="color:rgb(33, 15, 201)">1 &lt;= 0 (F)</td></tr>
                    <tr><td></td><td></td><td>0 + (1<sup>0</sup> /1)=1</td><td></td><td></td><td></td><td></td><td></td></tr>
                    <tr><td></td><td></td><td></td><td>1</td><td>1 &lt;= 5 (V)</td><td>1</td><td>1</td><td>1 &lt;= 1 (V)</td></tr>
                    <tr><td></td><td></td><td>1 + (1<sup>1</sup> /1)=2</td><td></td><td></td><td>1*1=1</td><td style="color:rgb(33, 15, 201)">2</td><td style="color:rgb(33, 15, 201)">2 &lt;= 1 (F)</td></tr>
                    <tr><td></td><td></td><td></td><td>1</td><td>1 &lt;= 5 (V)</td><td>1</td><td>1</td><td>1 &lt;= 2 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>1*1=1</td><td>2</td><td>1 &lt;= 2 (V)</td></tr>
                    <tr><td></td><td></td><td>1 + (1<sup>2</sup> /2)=2.5</td><td></td><td></td><td>1*2=2</td><td style="color:rgb(33, 15, 201)">3</td><td style="color:rgb(33, 15, 201)">3 &lt;= 2 (F)</td></tr>
                 
                    <tr><td></td><td></td><td></td><td>3</td><td>3 &lt;= 5 (V)</td><td>1</td><td>1</td><td>1 &lt;= 3 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>1*1=1</td><td>2</td><td>2 &lt;= 3 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>1*2=2</td><td>3</td><td>3 &lt;= 3 (V)</td></tr>
                    <tr><td></td><td></td><td>1 + (1<sup>3</sup> /6)=2.66667</td><td></td><td></td><td>2*3=6</td><td style="color:rgb(33, 15, 201)">4</td><td style="color:rgb(33, 15, 201)">4 &lt;= 3 (F)</td></tr>
                 
                    <tr><td></td><td></td><td></td><td>4</td><td>4 &lt;= 5 (V)</td><td>1</td><td>1</td><td>1 &lt;= 4 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>1*1=1</td><td>2</td><td>2 &lt;= 4 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>1*2=2</td><td>3</td><td>3 &lt;= 4 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>2*3=6</td><td>4</td><td>4 &lt;= 4 (V)</td></tr>
                    <tr><td></td><td></td><td>1 + (1<sup>4</sup> /24)=2.70834</td><td></td><td></td><td>6*4=24</td><td style="color:rgb(33, 15, 201)">5</td><td style="color:rgb(33, 15, 201)">5 &lt;= 4 (F)</td></tr>
                  
                    <tr><td></td><td></td><td></td><td>5</td><td>5 &lt;= 5 (V)</td><td>1</td><td>1</td><td>1 &lt;= 5 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>1*1=1</td><td>2</td><td>2 &lt;= 5 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>1*2=2</td><td>3</td><td>3 &lt;= 5 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>2*3=6</td><td>4</td><td>4 &lt;= 5 (V)</td></tr>
                    <tr><td></td><td></td><td></td><td></td><td></td><td>6*4=24</td><td>4</td><td>5 &lt;= 5 (V)</td></tr>
                    <tr><td></td><td></td><td>1 + (1<sup>5</sup> /120)=2.71667</td><td></td><td></td><td>24*5=120</td><td style="color:rgb(33, 15, 201)">6</td><td style="color:rgb(33, 15, 201)">5 &lt;= 5 (F)</td></tr>
                  </table> <br>
                  
                  <h1><b>Caso de Estudio 27: Serie de la Función Seno.</b></h1>
                  <h2><b>A) Problema</b></h2>
                  <p>El valor de la función y=sen(x) se puede aproximar mediante la siguiente serie de Taylor:</p>
                 <table align="right">
                  <td width="350"> <i>sen(x)</i>= x - (x<sup>3</sup> /3!) + (x<sup>5</sup> /5!) - (x<sup>7</sup> /!) + ... + (-1<sup>n</sup>)∙(x<sup>2n+1</sup>)/(2n+1)!
                  </td><td align="right">(1)</td></table> 
                   
                  <p>La fórmula de la sumatoria de la función es:</p>
                  <table align="right">
                    <td width="350"> <i>sen(x)</i>= &Sigma;<sup><font size="2">&infin;</font></sup><sub><font size="2">n=1</font></sub>   (-1<sup>n</sup>)∙(x<sup>2n+1</sup>)/(2n+1)!
                    </td><td align="right">(2)</td></table><br><br><br>
                    <p>Escribir un programa que permita aproximar el valor de la función seno utilizando la serie de Taylor y bucles anidados.</p>
                  <h2><b>B) Análisis</b></h2>
                  <p>Claramente se puede ver que las entradas del problema son el número de términos de la serie y el valor del ángulo en grados de la función seno. Se requiere una sola salida que es el valor de la serie aproximada. El proceso de cálculo requiere que la serie numérica infinita de la ecuación (2), se convierta a una serie numérica finita, donde el valor de ‘n’ se convierte en el valor de ‘i’ y el valor de infinito pasa a ser el valor de n-1, ya que si se quiere calcular la sumatoria de los cinco primeros términos de la serie, la sumatoria iría desde el valor de i = 0 hasta el valor de i = 5 - 1, es decir, i = 4, como se puede ver en la ecuación (3):</p>
                  <table align="right">
                    <td width="350"><i>sen(x)</i>= &Sigma;<sup><font size="2">n-1</font></sup><sub><font size="2">i=0</font></sub>   (-1<sup>i</sup>)∙(x<sup>2i+1</sup>)/(2i+1)!
                      
                    </td><td align="right">(3)</td></table>
                    <p>Para calcular el valor del factorial de la función seno se requiere utilizar la sucesión del factorial de un número cuya ecuación es:</p>
                    <table align="right"><td width="350">n! = &prod;<sup><font size="2">&infin;</font></sup><sub><font size="2">n=1</font></sub>  n </td>
                    <td align="right">(4)</td>
                    </table><br><br>
                    <p>Por lo que, el factorial de (2i+1) es:</p>
                    <table align="right">
                      <td width="350">(2i + 1)! = &prod;<sup><font size="2">2i=1</font></sup><sub><font size="2">j=1</font></sub>  j</td>
                    <td align="right">(5)</td>
                    </table><br><br>
                    <p>Reemplazando el valor de la ecuación (5) en la ecuación (3) se tiene:</p>
                    <table align="right">
                      <td width="350"><i>sen(x)</i>= &Sigma;<sup><font size="2">n-1</font></sup><sub><font size="2">i=0</font></sub>   (-1<sup>i</sup>)∙(x<sup>2i+1</sup>)/( &prod;<sup><font size="1">2i=1</font></sup><sub><font size="1">j=1</font></sub>  j)!                  
                      </td><td align="right">(2)</td></table>
                      <p>Como se puede ver en la ecuación (6) se requiere utilizar dos bucles anidados; un bucle externo para calcular la sumatoria y un bucle interno para calcular el factorial de un número que básicamente es un producto. Además, se tiene que convertir el valor del ángulo de grados a radianes para realizar los cálculos respectivos.</p>

    <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Entradas del Programa</b></p>
                    
      <table> <tr><td width="200"> n </td><td width="200">/* número de términos de la serie */</td></tr>
                    <tr><td>x</td><td>/* Ángulo de la función en grados */</td></tr>
                  </table><br>
                  <p><b>Salidas del Problema</b></p>
                  <table>
                    <tr><td width="200"> serie </td><td width="200">/* Resultado de la serie aproximada  */</td></tr>
                  </table><br>
      <p><b>Auxiliares del Problema</b></p>
                <table>
                 <tr><td width="200">i</td><td width="200">/* Contador para controlar la sumatoria */</td></tr>
                <tr><td width="200">j</td><td width="200">/* Contador para controlar el factorial de un número */</td></tr>
                <tr><td width="200">sum</td><td width="200">/* Acumulador de sumas */</td></tr>
                <tr><td width="200">prod</td><td width="200">/* Acumulador de productos */</td></tr>
               </table><br>
                  <p><b>Fórmulas Relevantes</b></p>
                  <table>
                    <tr><td><i>x = (x∙π)/180</i></td><td>1</td><td>Fórmula para convertir de grados a radianes </td></tr>
                <tr><td ><i>prod = prod ∙ valor </i></td><td> (2) </td><td>/* Fórmula que representa el acumulador de un producto */</td></tr>
                  <tr><td width="120"><i>sum = sum + valor</i></td><td width="30"> (3) </td><td width="280">/* Fórmula que representa el acumulador de una sumatoria */</td></tr>
                    <tr><td >n! = &prod;<sup><font size="2">&infin;</font></sup><sub><font size="2">n=1</font></sub>  n</td><td> (4) </td><td>/* Fórmula que representa el factorial de un número */</td></tr>
                    <tr><td ><i>sen(x)</i>= &Sigma;<sup><font size="2">n-1</font></sup><sub><font size="2">i=0</font></sub>   (-1<sup>i</sup>)∙(x<sup>2i+1</sup>)/( &prod;<sup><font size="1">2i=1</font></sup><sub><font size="1">j=1</font></sub>  j)!                  
                    </td><td> (5) </td>
                      <td>/* Fórmula que representa la serie del seno incluido el factorial de un número */</td></tr>
                  </table> <br>
  
                  <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                  <p>En la Figura 2.27.1 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘n’; la variable ‘x’; b) Salidas: la variable ‘serie’; c) Auxiliares: el contador ‘i’; el contador ‘j’; la variable ‘prod’; la variable ‘sum’; la constante PI.</p>
                  <img src="./assets/images/Capitulos/II/media/Figura 2.27.1.png" style="display:block; margin:auto; "><br>
                  <h5 style="text-align:center"><b>Figura 2.27.1. </b>Diagrama de Entrada-Salida del Programa.</h5>
                  <h2><b>C) Diseño</b></h2>
                  <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                  
        <p><b>Algoritmo</b></p>
                  
                  <ol type="1">
                    <li>Imprimir el mensaje de información: Serie del Seno <sup>x</sup>.</li>
                    <li>Leer el número de términos de la serie, utilizando la variable ‘n’.</li>
                    <li>Leer el valor del ángulo en grados de la función seno, utilizando la variable ‘x’..</li>
                    <li>Convertir el valor del ángulo ‘x’ de grados a radianes, utilizando la fórmula (1).</li>
                    <li>Inicializar con el valor de cero el acumulador de sumas cuya variable utilizada es ‘sum’.</li>
                    <li>Para el bucle externo, hacer: </li>
                    <ol type="1" start="6"><li>1.	Inicializar el valor del contador ‘i’ en cero. </li></ol>
                    <ol type="1" start="6"><li>2.	Mientras el valor de la condición (i &lt;=n-1) sea verdadera ejecutar las sentencias del bucle externo. </li></ol>
                    <ol type="1" start="6"><li>3.	Luego de cada iteración incrementar en uno el valor del contador ‘i’. </li></ol>
                    <ol type="1" start="6"><li>4.	Inicializar el acumulador de productos ‘prod’ con el valor de uno.</li></ol>
                    <ol type="1" start="6"><li>5.	Para el bucle interno, hacer: </li>
                      <ol type="1" start="6"><li>5.1.	Inicializar el valor del contador ‘j’ en uno.</li></ol>
                      <ol type="1" start="6"><li>5.2.	Mientras el valor de la condición (j&lt;=i*i+1) sea verdadera ejecutar las sentencias del bucle interno.</li></ol>
                      <ol type="1" start="6"><li>5.3.	Luego de cada iteración incrementar en uno el valor del contador ‘j’.</li></ol>
                      <ol type="1" start="6"><li>5.4.	Asignar al acumulador ‘prod’ lo que tiene multiplicado por el valor del contador ‘j’.</li></ol>
                    </ol>
                    <ol type="1" start="6"><li>6.	Asignar al acumulador ‘sum’ lo que tiene sumado el valor del término e-nésimo de la serie.</li></ol>

                    <li>Asignar a la variable serie el valor del acumulador ‘sum’.</li>
                    <li>Imprimir el valor de la serie aproximada.</li>
                  </ol>                    


                    <h2><b>D) Implementación</b></h2>
                    <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.27.1 se muestra el código del programa en C/C++.</p>
                    <h5><b>Tabla 2.27.1. </b>Programa que calcula la serie de la función seno.</h5>
                    <pre><code [highlight]="prefTab2[0].tabla2_27_1"  [lineNumbers]="true"></code></pre> <br>
                    <h2>E) Pruebas</h2>
                    <p>En la Tabla 2.27.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                    <p>En la salida de la Tabla 2.27.2 se puede ver que, al ingresar el número de términos igual a 10 y el valor del ángulo en grados igual a 30, se obtiene el valor de la serie aproximada igual a 0.5.</p>
                    <h5><b>Tabla 2.27.2.</b> Salida del programa</h5>
                    <img src="./assets/images/Capitulos/II/media/Tabla 2.27.2.png" style="display:block; margin:auto; "><br>
                    <p>En la Tabla 2.27.3, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada iteración del bucle externo for() se inicializa el acumulador del producto en 1 y luego se calcula el factorial de (2i+1) utilizando un bucle interno for(). Luego de ejecutarse el bucle interno for() se utiliza un acumulador de sumas donde se acumulan los valores parciales de la serie de la función y la ejecución del bucle externo termina cuando la condición de esta sentencia se hace falsa.</p>
                   <h5><b>Tabla 2.27.3. </b>Prueba de escritorio del programa.</h5>
                   <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                    <tr style="color:red"><td>n</td><td>x</td><td>Sum</td><td>i</td><td>i &lt;= n - 1</td><td>prod</td><td>j</td><td>j &lt;= 2*i+1</td></tr>
                      <tr><td>3</td><td>π/6</td><td>0</td><td>0</td><td>0 &lt;= 3 (V)</td><td>1</td><td>1</td><td>1 &lt;= 1 (V)</td></tr>
                      <tr><td></td><td></td><td>0 + π/6 = π/6 = 0.523599</td><td></td><td></td><td>1*1=1</td><td style="color:rgb(33, 15, 201)">2</td><td style="color:rgb(33, 15, 201)">2 &lt;= 1 (F)</td></tr>
                      <tr><td></td><td></td><td></td><td>1</td><td>1 &lt;= 3 (V)</td><td>1</td><td>1</td><td>1 &lt;= 3 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>1*1=1</td><td>2</td><td>2 &lt;= 3 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>1*2=2</td><td>3</td><td>3 &lt;= 3 (V)</td></tr>
                      <tr><td></td><td></td><td>0.523599 - (π/6)<sup>3</sup>/6=0.49967</td><td></td><td></td><td>2*3=6</td><td style="color:rgb(33, 15, 201)">4</td><td style="color:rgb(33, 15, 201)">4 &lt;= 3 (F)</td></tr>
                      <tr><td></td><td></td><td></td><td>2</td><td>2 &lt;= 3 (V)</td><td>1</td><td>1</td><td>1 &lt;= 5 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>1*1=1</td><td>2</td><td>2 &lt;= 5 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>1*2=2</td><td>3</td><td>3 &lt;= 5 (V)</td></tr>                      
                      <tr><td></td><td></td><td></td><td></td><td></td><td>2*3=6</td><td>4</td><td>4 &lt;= 5 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>6*4=24</td><td>5</td><td>5 &lt;= 5 (V)</td></tr>
                      <tr><td></td><td></td><td>0.499674 + (π/6)<sup>5</sup>/120 = 0.5000002</td><td></td><td></td><td>24*5=120</td><td style="color:rgb(33, 15, 201)">6</td><td style="color:rgb(33, 15, 201)">6 &lt;= 5 (F)</td></tr>
                   
                      <tr><td></td><td></td><td></td><td>3</td><td>3 &lt;= 3 (V)</td><td>1</td><td>1</td><td>1 &lt;= 7 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>1*1=1</td><td>2</td><td>2 &lt;= 7 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>1*2=2</td><td>3</td><td>3 &lt;= 7 (V)</td></tr>                      
                      <tr><td></td><td></td><td></td><td></td><td></td><td>2*3=6</td><td>4</td><td>4 &lt;= 7 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>6*4=24</td><td>5</td><td>5 &lt;= 7 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>24*5=120</td><td>6</td><td>6 &lt;= 7 (V)</td></tr>
                      <tr><td></td><td></td><td></td><td></td><td></td><td>120*6=720</td><td>7</td><td>7 &lt;= 7 (V)</td></tr>
                      <tr><td></td><td></td><td>0.5000002 - (π/6)<sup>7</sup>/5040 = 0.5</td><td></td><td></td><td>720*7=5040</td><td style="color:rgb(33, 15, 201)">8</td><td style="color:rgb(33, 15, 201)">8 &lt;= 7 (F)</td></tr>
                                      
                      <tr><td></td><td></td><td style="color:rgb(33, 15, 201)">4</td><td style="color:rgb(33, 15, 201)">4&lt;= 3 (F)</td><td></td><td></td><td></td><td></td></tr>
                    </table> <br> 


              </ng-template>
            </mat-tab>
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Resumen">
        <ng-template matTabContent>
          <br><h1>Resumen</h1>
          <ol type="1">
            <li>Un algoritmo es un método para resolver un problema. La solución de un problema de programación implica la aplicación de cuatro fases: a) Análisis del problema; b) Diseño del algoritmo; c) Desarrollo y codificación; Implementación y pruebas.</li>
            <li>Un programa es un conjunto de instrucciones que producirán la ejecución de una determinada tarea para conseguir un fin.</li>
            <li>El pseudocódigo es un lenguaje que se utiliza para describir algoritmos y ayuda a la codificación de un programa.</li>
            <li>La programación estructurada enseña la descomposición de un programa en módulos más simples de programar que permitirá la escritura de programas fáciles de leer y modificar. En un programa estructurado el flujo lógico se gobierna por las estructuras de control básicas: a) estructuras secuenciales; b) estructuras de decisión; c) estructuras repetitivas. El estudio de las estructuras de control se realiza en base al diseño de algoritmos y a la creación de programas en lenguaje C/C++.</li>
            <li>La estructura de control secuencial es aquella en la que una instrucción se ejecuta a continuación de otra de modo de secuencia.</li>
            <li>La estructura de control de selección es aquella en la que las instrucciones se ejecutan entre acciones alternativas. Las principales sentencias de decisión son: a) La sentencia if; b) La sentencia if-else; c) Sentencias if-else anidadas; d) Secuencia de Sentencias if; e) Secuencia de Sentencias if-else; f) Sentencia de control switch.</li>
            <li>La estructura de control conocida como bucle es aquella que realiza la repetición o iteración de acciones o grupos de sentencias. Las principales sentencias de repetición son: a) La sentencia while; b) La sentencia do-while; c) La sentencia for; d) Bucles anidados.</li>
            <li>En el lenguaje C/C++ es posible anidar bucles, donde estos bucles anidados constan de un bucle externo con uno o más bucles internos. Cada vez que se repite el bucle externo, los bucles internos se repiten y se ejecutan las sentencias de estos bucles</li>
          </ol>
        </ng-template>
      </mat-tab>

      <mat-tab label="Test de Conocimientos">
        <ng-template matTabContent>

        </ng-template>
      </mat-tab>

      <mat-tab label="Ejercicios Propuestos">
        <ng-template matTabContent>
          <h2><strong>Ejercicios Propuestos</strong></h2>
          <p>1.	Escribir un programa que calcule el área y el perímetro de un cuadrado, utilizando las siguientes fórmulas matemáticas:</p>
          <img src="./assets/images/Capitulos/II/media/a92.png" style="display:block; margin:auto; "><br>
          <p>Siendo ‘l’ el valor del lado del cuadrado. </p>
          <p>2.	Escribir un programa para calcular e imprimir el perímetro, la apotema y el área de un hexágono, utilizando las siguientes fórmulas matemáticas:</p>
          <img src="./assets/images/Capitulos/II/media/a93.png" style="display:block; margin:auto; "><br>
          <p>Siendo ‘l’ el valor del lado del hexágono.</p>
          <p>3.	Escribir un programa para calcular e imprimir el área y el volumen de un cilindro, utilizando las siguientes fórmulas matemáticas:</p>
          <img src="./assets/images/Capitulos/II/media/a94.png" style="display:block; margin:auto; "><br>
          <p>Siendo ‘r’ el valor del radio del cilindro y ‘h’ el valor de la altura del cilindro.</p>
          <p>4.	Partiendo de un sistema general de dos ecuaciones con dos incognitas:</p>
          <img src="./assets/images/Capitulos/II/media/a95.png" style="display:block; margin:auto; "><br>
          <p>Se puede resolver este sistema con la Regla de Cramer utilizando las siguientes fórmulas basadas en determinantes, para calcular los valores de ‘x’ e ‘y’:</p>
          <img src="./assets/images/Capitulos/II/media/a96.png" style="display:block; margin:auto; "><br>
          <p>Escribir un programa que lea los coeficientes numéricos de las dos ecuaciones: ‘a’, ‘b’ y ‘c’ de la primera ecuación; ‘d’, ‘e’ y ‘f’ de la segunda ecuación. Luego, calcular los valores de ‘x’ e ‘y’, para lo cual se deben validar los denominadores de las expresiones matemáticas, ya que que la división para cero no está definida.</p>
          <p>5.	Escribir un programa con bucles anidados que permita visualizar la siguiente figura: <br> n: 4</p>
          <img src="./assets/images/Capitulos/II/media/a97.png" style="display:block; margin:auto; "><br>
          <p>La letra ‘b’ en color plomo es equivalente a un espacio en blanco.</p>
          <p>6.	Escribir un programa con funciones que ingrese una suma determinada de dinero en centavos (menor que un $1,00 USD) y las salidas desplieguen el mayor número de monedas de 25 centavos, 10 centavos, 5 centavos y un centavo, necesitados para hacer esta suma. Por ejemplo:</p>
          <img src="./assets/images/Capitulos/II/media/a98.png" style="display:block; margin:auto; "><br>
          
        </ng-template>
      </mat-tab>

      <mat-tab label="Bibliografía">
        <ng-template matTabContent>
          <h2>Bibliografía</h2>
          <ul>
            <li>Ceballos, F.J., 2007. C/C++: Curso de Programación. Tercera Edición. Editorial RA-MA, España. ISBN: 978-84-9964-322-9.</li>
            <li>Davies, P., 1995. The Indispensable Guide to C with Engineering Applications. First Edition. Addison-Wesley Publishing Company, USA. ISBN: 0-201624389.</li>
            <li>Deitel, H., Deitel, P., 2003. Cómo Programar en C++. Cuarta Edición. Pearson Educación, México. ISBN: 970-26-0254-8.</li>
            <li>Granizo, E., 2016. Lenguaje C. Teoría y Ejercicios. Tercera Edición. Edicumbre Editorial Corporativa, Ecuador. ISBN: En Trámite.</li>
            <li>Hanly, H., Koffman, E., 2013. Problem Solving and Program Design in C. Seventh Edition. Pearson Education, USA. ISBN: 978-9332518810.</li>
            <li>Hanly, H., Koffman, E., Horvath, J., 1995. C Program Design for Engineers. First Edition. Addison-Wesley Publishing Company, USA. ISBN: 0-201590646.</li>
            <li>Jones, B., Aitken, P., 2003. C in 21 Days. Sixth Edition. SAMS Teach Yourself, USA. ISBN: 0-672-32448-2.</li>
            <li>Joyanes Aguilar, L., 2008. Fundamentos de Programación. Algoritmos, estructuras de datos y objetos. Cuarta Edición. McGraw-Hill, España. ISBN: 978-84-481-6111-8.</li>
            <li>Joyanes Aguilar, L., Zahonero Martínez, I., 2005. Programación en C. Metodología, algoritmos y estructuras de datos. Segunda Edición. McGraw-Hill, España. ISBN: 978-8448198442.</li>
            <li>Luna, F., 2004. C++ Programming for Game Developers. Module I. Game Institute. E-Institute, Inc., USA.</li>
            <li>Pressman, R., 2010. Ingeniería del Software. Un Enfoque Práctico. Séptima Edición. ISBN: 978-0-07-337597-7. Editorial McGraw-Hill, México.</li>
            <li>Ritchie, D., Kernighan, B., 1988. C Programming Language. Second Edition. Prentice Hall, USA. ISBN: 0-13-110362-8.</li>
            <li>Stroustrup, B., 1997. The C++ Programming Language. Special Edition. Addison-Wesley, USA. ISBN: 0-201-88954-4.</li>
            <li>Wirth Niklaus, 1971. Program Development by Stepwise Refinement. Communications of the ACM, Vol. 14 (4), pp. 221-227.</li>
            <li>Serway, R., Jewett, J., 2005. Física para Ciencias e Ingeniería. Volumen 1. Séptima Edición. ISBN: 978-607-481-357-9. Cengage Learning Editores, México.</li>
            <li>Arce, E., 2011. Introducción al Diseño Básico de los Procesos Químicos. Instituto Politécnico Nacional, México.</li>
            <li>Mallar, M.A., 2010. La Gestión por Procesos: Un Enfoque de Gestión Eficiente. Revista Científica “Visión Futuro”. ISSN: 1669-7634. Universidad Nacional de Misiones Argentina.</li>
            
          </ul>
        </ng-template>
      </mat-tab>

    </mat-tab-group>
  <button mat-button (click)="selectTabNext()" *ngIf="positionCurrentNext">{{titleNext}} <mat-icon>navigate_next</mat-icon></button>
    <button mat-button (click)="selectTabBefore()" *ngIf="positionCurrentBefore"><mat-icon>navigate_before</mat-icon> Atras  &nbsp; &nbsp; &nbsp;&nbsp;</button>

</div>
<!-- EXAMPLES
<mat-tab label="Pracniques">
  <ng-template matTabContent>
    <mat-tab-group>
      &lt;!&ndash; <mat-tab *ngFor="let tab of asyncTabs | async"> &ndash;&gt;
      <mat-tab *ngFor="let tab of praqnique" label="{{tab.label}}">
        <br>
        <table>
          <tr>
            <td>
              <h2 style="color:green;"><strong>{{tab.tituloN}}</strong></h2>
            </td>
            <td>
              <h2>{{tab.titulo}}</h2>
            </td>
          </tr>
        </table>
        <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
          <TR>
            <TABLE>
              <TR><strong>SINOPSIS</strong></TR>
              <TR>{{tab.sinopsisDescrip}}</TR>
            </TABLE>
          </TR>
          <TR>
            <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
              <TR *ngFor="let item of tab.sinopsis">
                <TD><strong>{{item.titulo}}</strong>{{item.descrip}}</TD>
              </TR>
            </TABLE>
          </TR>
        </TABLE><br>
        <a href="{{tab.link}}" download="ProgramaPracnique">
          <mat-icon>save_alt</mat-icon><strong>Descargar {{tab.tituloN}} PracniqueCompGraf.zip</strong>
        </a>
        <br><br>
        <h3><strong>{{tab.A.subtitulo}}</strong></h3>
        <p>{{tab.A.problema}}</p>
        <img src="{{tab.A.fotoPath}}" style="display:block; margin:auto;"><br>
        <h5><strong>{{tab.A.fotoN}}</strong>{{tab.A.fotoDescrip}}</h5><br>
        <p>{{tab.A.problema1}}</p>
        <ul *ngFor="let x of tab.A.problemalist">
          <div>{{x}}</div>
        </ul>
        <h3><strong>{{tab.B.subtitulo}}</strong></h3>
        <div *ngFor="let itemPasos of tab.B.pasosB">
          <h3><strong>{{itemPasos.subtitulo2}}</strong></h3>
          <p><strong>{{itemPasos.tituloproblema}}</strong></p>
          <p>{{itemPasos.parrafo}}</p>
          <img src="{{itemPasos.fotoPath}}" style="display:block; margin:auto; ">
          <p>{{itemPasos.parrafo2}}</p>
          <p>{{itemPasos.parrafo3}}</p>
          <p><strong>{{itemPasos.titulosolucion}}</strong></p>
          <div *ngFor="let item of itemPasos.solucion">
            <mathjax [content]=item.parrafo class='box'></mathjax>
            <img src="{{item.fotoPath}}" style="display:block; margin:auto; ">
          </div>
        </div>
        <h3><strong>{{tab.C.subtitulo}}</strong></h3>
        <dl *ngFor="let itemAlgoritmos of tab.C.algoritmosC">
          <dt>{{itemAlgoritmos.titulo}}</dt>
          <dd>
            <ul *ngFor="let p of itemAlgoritmos.pasos; index as i">
              <div value="{{i+1}}">{{p}}</div>
            </ul>
            <ul *ngFor="let p of itemAlgoritmos.pasosFormulas; index as i">
              <div value="{{i+1}}">{{p}}</div>
            </ul>
          </dd>
        </dl>
        <h3><strong>{{tab.D.subtitulo}}</strong></h3>
        <div *ngFor="let itemCodigos of tab.D.listaCodigo">
          <p>{{itemCodigos.problema}}</p>
          <h5><strong>{{itemCodigos.tablaN}}</strong>{{itemCodigos.tablaDescrip}}</h5><br>
          <pre><code [highlight]="itemCodigos.tablaDatos" (highlighted)="onHighlight($event)" [lineNumbers]="true"></code></pre><br>
        </div>
        <h3><strong>{{tab.E.subtitulo}}</strong></h3>
        <div *ngFor="let item of tab.E.listaPrueba">
          <p>{{item.problema}}</p>
          <img src="{{item.fotoPath}}" style="display:block; margin:auto; width: 75%;"><br>
          <h5><strong>{{item.fotoN}}</strong>{{item.fotoDescrip}}</h5><br>
        </div>
      </mat-tab>
    </mat-tab-group>
  </ng-template>
</mat-tab>
<mat-tab label="Pracniques Propuestos">
  <ng-template matTabContent>
    <mat-tab-group>
      &lt;!&ndash; <mat-tab *ngFor="let tab of asyncTabs | async"> &ndash;&gt;
      <mat-tab *ngFor="let tab of praqniquePropuesto" label="{{tab.label}}">
        <br>
        <table>
          <tr>
            <td>
              <h2 style="color:green;"><strong>{{tab.tituloN}}</strong></h2>
            </td>
            <td>
              <h2>{{tab.titulo}}</h2>
            </td>
          </tr>
        </table>
        <h3><strong>{{tab.subtitulo}}</strong></h3>
        <div *ngFor="let item of tab.listaGeneral">
          <div *ngFor="let i of item.listaParrafoFotos">
            <mathjax [content]=i.problema class='box'></mathjax><br>
            <img src="{{i.fotoPath}}" style="display:block; margin:auto; width: 50%;"><br>
            <h5><strong>{{i.fotoN}}</strong>{{i.fotoDescrip}}</h5><br>
          </div>
          <div *ngFor="let i of item.listaParrafos">
            <mathjax [content]=i.problema class='box'></mathjax><br>
          </div>
          <div *ngFor="let i of item.listaFotos">
            <img src="{{i.fotoPath}}" style="display:block; margin:auto; width: 50%;"><br>
            <h5><strong>{{i.fotoN}}</strong>{{i.fotoDescrip}}</h5><br>
          </div>
        </div>
        <a href="{{tab.linkAnexo}}" download="Anexo">
          <mat-icon>{{tab.iconodescarga}}</mat-icon><strong>{{tab.tituloAnexo}}</strong>
        </a>
      </mat-tab>
    </mat-tab-group>
  </ng-template>
</mat-tab>
<mat-tab label="Evaluación">
  <ng-template matTabContent>
    <div class="Evaluacion">
      <app-quiz [propagarNumCapitulo]="num_capitulo"></app-quiz>
    </div>
  </ng-template>
</mat-tab>
<mat-tab label="Juegos">
  <ng-template matTabContent>
    <div class="Snake">
      <app-snake></app-snake>
    </div>
  </ng-template>

</mat-tab>
<mat-tab label="Resumen">
  <ng-template matTabContent>
    <br>
    <h1>Resumen</h1>
    <ul>
      <li>La forma más conveniente de especificar un segmento de línea en la pantalla de una computadora es proporcionan.</li>
      <li>El componente o subsistema GDI (Graphics Device Interface) trabaja junto con el núcleo y la API de Windows do las coordenadas de sus dos puntos finales.</li>
      <li>Un punto es el objeto geométrico más simple y elemental, que permite representar líneas, planos, vectores y todo tipo de figuras geométricas complejas en 2D y 3D como curvas, superficies y sólidos.</li>
      <li>La estructura Point (Point Struct), representa un par ordenado de coordenadas x e y enteras que define un punto en un plano bidimensional.</li>
      <li>La estructura PointF (PointF Struct), representa un par ordenado de coordenadas x e y de punto flotante que define un punto en un plano bidimensional.</li>
      <li>Cuando se necesita trabajar con varios puntos para graficar una Figura Geométrica como un polígono o una curva se puede utilizar un arreglo de puntos.</li>
      <li>Un punto se puede mover desde una localidad a otra de dos maneras: a) Primero, se puede trasladar un punto desde su posición actual a una nueva; b) Segundo, se puede rotar ese punto con respecto a otro en el plano o en los ejes dentro de un espacio a una nueva posición.</li>
      <li>El rectángulo (Rectangle) es una estructura (struct) que almacena un conjunto de cuatro enteros que representan la localización y el tamaño de un rectángulo en un lienzo o canvas.</li>
      <li>Un vector es un ente matemático que tiene módulo (magnitud), dirección y sentido.</li>
      <li>Se pueden graficar las líneas y puntos notables de un triángulo utilizando Geometría Aplicada y utilizando las ecuaciones de traslación de un punto a otro en el mundo de la Computación Gráfica.</li>
      <li>Un vector 2D tiene dos componentes en el plano (x,y) que se lo puede representar gráficamente utilizando líneas con puntos y con flechas, aplicando Geometría Aplicada y utilizando las ecuaciones de traslación de un punto a otro en el mundo de la Computación Gráfica.</li>
      <li>Un vector 3D tiene tres componentes en el plano (x,y,z) que se lo puede representar gráficamente utilizando líneas con puntos y con flechas, aplicando Geometría Aplicada y utilizando las ecuaciones de traslación de un punto a otro en el mundo de la Computación Gráfica.</li>
    </ul>
  </ng-template>
</mat-tab>
<mat-tab label="Bibliografía">
  <ng-template matTabContent>
    <br>
    <h1>Bibliografía</h1>
    <ul>
      <li>Ammeraal, L., Zhang, K., 2017. Computer Graphics for Java Programmers. Springer. Third Edition.</li>
      <li>Lengyel, E., 2011. Mathematics for 3D Game Programming and Computer Graphics. Charles River Media. Third Edition.</li>
      <li>Steeb, W.H., Hardy, A., 2008. Mathematical Tools in Computer Graphics with C# Implementations. World Scientific Pub. Co. Inc. First Edition.</li>
      <li>Spiegel, M., Lipschutz, S., Spellman, D., 2011. Análisis Vectorial. 2° edición. SCHAUM, McGraw-Hill, Interamericana Editores, S.A., México. ISBN: 978-607-15-0550-7.</li>
      <li>Kimberling, C., 1994. Encyclopedia of Triangle Centers. Evansville University. Disponible en: https://faculty.evansville.edu/ck6/encyclopedia/ETC.html</li>
      <li>Beer, F., Jhonston, E.R., Mazurek, D., Eisenberg, E., 2010. Mecánica Vectorial para Ingenieros. Estática. Novena Edición. McGraw-Hill/Interamericana Editores, S.A., México. ISBN: 978-607-15-0277-3.</li>
    </ul>
  </ng-template>
</mat-tab>-->
