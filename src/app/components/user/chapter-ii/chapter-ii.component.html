<div style="margin: 50px;">
    <ng-container *ngIf="(asyncTabs | async) === null">
        Loading tabs...
    </ng-container>
    <table>
        <tr>
            <td>
                <h1><b> CAPÍTULO 2 ALGORITMOS Y ESTRUCTURAS DE CONTROL EN LENGUAJE C/C++
                </b></h1>
            </td>
            <td></td>
            <td>
                <a href="https://drive.google.com/uc?id=1yQtGhmytRdEwydcquFPeafxYunAMHTux&export=download" download="Capitulo12021">
                    <mat-icon>cloud_download</mat-icon>Descargar Archivo Capítulo II
                </a>
            </td>
        </tr>
    </table>

    <mat-tab-group [selectedIndex]="selectedIndex.value" (selectedIndexChange)="selectedIndex.setValue($event)">
        <mat-tab label="Introducción">
            <ng-template matTabContent>
              <br>
              <h1>Introducción</h1>
              <p>En este capítulo se aprenderán a diseñar algoritmos y a utilizar la computadora como una herramienta para resolver problemas creando programas con estructuras de control en el lenguaje C/C++. Para la solución de problemas de programación se aplican aspectos de Ingeniería de Software y el método científico que permiten identificar a la programación con un enfoque sistemático. 
              </p>
              <p>
                En un programa estructurado el flujo lógico se gobierna por tres estructuras de control básicas: a) estructuras secuenciales; b) estructuras de decisión; c) estructuras repetitivas. El estudio de las estructuras de control se realiza en base al diseño de algoritmos y a la creación de programas en un lenguaje de programación estructurado como es el Lenguaje C/C++.
              </p>
            </ng-template>
        </mat-tab>
        <mat-tab label="Objetivos">
            <ng-template matTabContent>
              <br>
                <h1>Objetivos</h1>
                <ul>
                    <li>Revisar los principales conceptos en torno a algoritmos y a estructuras de control.</li>
                    <li>Entender cómo trabajan los algoritmos y las estructuras de control y cómo se aplican con el lenguaje C/C++ en la construcción de programas.</li>
                    <li>Aprender a crear algoritmos en Pseudocódigo y en Lenguaje C/C++.</li>
                    <li>Diseñar y crear programas en lenguaje C/C++ utilizando algoritmos y estructuras de control.</li>
                    <li>Resolver casos de estudio con algoritmos y estructuras de control aplicadas al área matemática.</li>
                </ul>
                  </ng-template>
        </mat-tab>
      <mat-tab label="Algoritmo">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="2.1.1. Definición de Algoritmo">
              <ng-template matTabContent>
                <br>
              <h1>Definición de Algoritmo</h1>
              <p>Un algoritmo es un conjunto de pasos o instrucciones ordenadas y finitas que permiten resolver un problema (Joyanes,L., 2008). Etimológicamente hablando la palabra algoritmo proviene del latín, dixit algorithmus y este del griego arithmos, que significa número y también con la influencia del matemático persa Muhammad Al-Juarismi que vivió durante el siglo IX y alcanzó gran reputación por el enunciado de las reglas paso a paso para sumar, restar, multiplicar y dividir números decimales. Euclides, el gran matemático griego que vivió en el siglo IV antes de Cristo, inventó un método para encontrar el Máximo Común Divisor (MCD) de dos números en base a divisiones sucesivas. A Euclides y a Al-Juarismi se les consideran los padres de la algoritmia que es una ciencia que se dedica al estudio de los algoritmos.
              </p>
              </ng-template>
            </mat-tab>
            <mat-tab  label="2.1.2. Características de los Algoritmos">
              <ng-template matTabContent>
                <br>
                <h1>Características de los Algoritmos </h1>
                <p>
                  Un algoritmo tiene las siguientes tres características (Joyanes, L., 2008):
                </p>
                <br>
                <li><strong>Preciso: </strong>Un algoritmo debe definirse de manera rigurosa sin ambigüedades.
                </li>
                <li><strong>Definido: </strong>Si se sigue un algoritmo dos veces, se debe obtener el mismo resultado.</li>
                <li><strong>Finito: </strong>Un algoritmo debe terminar en algún momento.</li>
                <br>
                <p>
                  Considerando estas características un algoritmo puede tener elementos de entrada y debe producir un resultado claro y conciso, que puede ser escrito en un lenguaje de programación como C/C++.   
                </p>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.3. Etapas para la Solución de un Problema">
              <ng-template matTabContent>
                <br>
                <h1>Etapas para la Solución de un Problema</h1>
            
                <p>
                  Los Ingenieros en Sistemas en la industria de la computación han encontrado que la ingeniería y el método científico para la solución de problemas pueden ser adaptados para el desarrollo confiable de sistemas de software (Hanly, J., Koffman, E., Horvath, J., 1995). Desde hace varias décadas la Ingeniería de Software ha sido utilizada para identificar la programación con un enfoque sistemático (Pressman, R., 2010). En este capítulo se van a aplicar cuatro fases en la resolución de problemas de programación, considerando los aspectos de la ingeniería y el método científico dentro de cada fase.
                </p>
                <br>
                <ol type="1" style="font-weight: normal;" >
                  <li><strong>Análisis del Problema: </strong>En esta fase, se estudia la especificación del problema, se identifican las entradas y salidas requeridas. Se revisan los principios teóricos y científicos que se aplican en la solución de un problema y se listan las fórmulas o relaciones relevantes.</li>
                  <li><strong>Diseño del Algoritmo: </strong>En esta fase, se escribe el algoritmo y se lista los sub-problemas a detalle. Se puede aplicar el proceso llamado “divide y vencerás” (divide and conquer), donde el problema se divide en sub-problemas.</li>
                  <li><strong>Desarrollo y Codificación: </strong>En esta fase, se presenta la codificación del programa en Lenguaje C/C++, debidamente comentado y explicado conforme a los algoritmos diseñados, considerando la especificación de requerimientos, datos, constantes y fórmulas requeridas para resolver el problema.</li>
                  <li><strong>Implementación y Pruebas: </strong>En esta fase, se verifica que la solución del problema es correcta y el programa trabaja adecuadamente, para lo cual se corre el programa varias veces y se prueba con diferentes valores. Además, se pueden contemplar pruebas de escritorio del programa mostrando el funcionamiento de algunas partes del mismo o en su totalidad considerando los datos y los cálculos que se necesitan procesar.</li>
                </ol>

              </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.4. Programas y Algoritmos">
              <ng-template matTabContent>
                <br>
                <h1>Programas y Algoritmos</h1>
               
                <p>Un algoritmo como se mencionó en la sección 2.1.1, es un conjunto de pasos o instrucciones que se siguen para resolver un problema. Un programa implementa uno o más algoritmos y lo traduce a lenguaje máquina. Según Joyanes Aguilar, et al. (2005), un algoritmo se puede expresar de tres maneras: a) forma gráfica, utilizando un diagrama de flujo; b) pseudocódigo que es un lenguaje de descripción algorítmica; c) lenguaje de programación que es una manera explícita de representar un algoritmo. En este capítulo se van a diseñar algoritmos mediante pseudocódigo y se los van a implementar utilizando el Lenguaje de Programación C/C++.</p>
              <p>Los programas se pueden dividir en sub-programas utilizando funciones, de modo que la complejidad algorítmica se reduce a tener un solo programa completo, lo cual ayuda a mejorar el rendimiento del mismo. Esta práctica es muy utilizada y se conoce como refinamiento progresivo. De acuerdo con Wirth Niklaus (1971), un programa está formado por algoritmos y estructuras de datos.</p>
              <p>La programación como tal puede tener muchos enfoques o paradigmas de programación lo cual permite formular la resolución de un problema de diferentes formas. Los dos paradigmas de programación más utilizados son: a) Paradigma de Programación Estructurada, que permite mejorar la calidad, claridad y tiempo de desarrollo de un programa recurriendo al uso de subrutinas y estructuras de control; b) Paradigma de Programación Orientada a Objetos, que permite innovar la programación utilizando objetos que manipulan datos y diferentes mecanismos de abstracción como herencia y polimorfismo (Granizo E., 2016).</p>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.5. Pseudocódigo como Técnica de Representación de un Algoritmo">
              <ng-template matTabContent>
                <br>
                <h1>Pseudocódigo como Técnica de Representación de un Algoritmo</h1>
         
              <p>Pseudocódigo es un lenguaje de especificación o descripción de algoritmos. El uso de este lenguaje ayuda a la codificación de un programa de una manera relativamente fácil (Joyanes Aguilar, L., 2008). Este lenguaje nació en inglés y era un medio de representación básico de las estructuras de control de la programación estructurada. Actualmente, se lo puede utilizar también en español sustituyendo las palabras originales del idioma inglés. En esta obra de programación se utilizará la técnica del pseudocódigo para diseñar los algoritmos de los programas y el Lenguaje C/C++ para implementar los mismos.</p>
              <p>Por ejemplo, algunas de las palabras reservadas y operadores que maneja el Pseudocódigo son:</p>
            <ol>
                <li value="1">Leer (Read)</li>
                <li>Imprimir (Print/Write)</li>
                <li>Calcular (Calculate)</li>
                <li>Repetir (Repeat)</li>
                <li>Asignar a 'x', el valor de 'y':
                  <ul>
                    <li>	x &larr; y; (Opción 1)</li>
                  <li>	x := y; (Opción 2)</li>
                  <li>	x = y; (Opción 3)</li>
                  </ul>
                </li>
            </ol>  
                <p>En la sección 2.2 se presentará el algoritmo en Pseudocódigo y la implementación de programas en Lenguaje C/C++, utilizando estructuras de control secuenciales, selectivas y repetitivas. Además, se presentan varios Casos de Estudio donde se cumplen con las etapas para la solución de un problema, aplicando el método científico.</p>

            </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.6. Diseño Conceptual de Procesos Aplicado a Programas">
              <ng-template matTabContent>
                <br>
                <h1>Diseño Conceptual de Procesos Aplicado a Programas</h1>
               
                <p>Un proceso es un sistema formado por unidades, componentes o equipos interconectados en forma organizada para procesar, modificar o transformar las propiedades de elementos o corrientes de proceso en productos de interés (Mallar, M.A., 2010). Un proceso se puede representar por: a) Diagrama de Entrada-Salida (input-output); b) Diagrama de Bloques (operaciones principales); c) Diagrama de Flujos (Flowsheet); d) Diagrama de tuberías e instrumentación (PID).</p>
                <p>El Diagrama de Entrada-Salida (input-output) se utiliza para representar flujos de materiales considerando las entradas y salidas de los procesos de fabricación de un producto. En la Figura 2.1 se muestra un ejemplo de un Proceso Químico donde las entradas son: a) Recursos económicos; b) Materias primas; c) Energía; las salidas son: a) Recursos económicos; b) Productos; c) Energía; d) Residuos.</p>
                <br>
                <img src="./assets/images/Capitulos/II/media/Figura 2.1..png" style="display:block; margin:auto; "><br>
                
                <h5 style="text-align:center"><b>Figura 2.1. </b>Diagrama de Entrada-Salida de un Proceso Químico (Adaptado de: Arce, E., 2011).</h5>
                <br>
                <p>Este tipo de diagramas también se pueden utilizar para representar un programa como un proceso. Conceptualmente un programa puede ser considerado como una caja negra (Joyanes Aguilar, L., 2008), donde la caja negra es el proceso o algoritmo de resolución, las entradas y las auxiliares son un grupo de datos que van a ser procesados para obtener las salidas o resultados, como se puede ver en la Figura 2.2. En el resto de capítulos y lecciones se utilizará el Diagrama de Entrada-Salida para entender el funcionamiento de un algoritmo como un proceso.</p>
                <br>
                <img src="./assets/images/Capitulos/II/media/Figura 2.2..png" style="display:block; margin:auto; "><br>
                
                <h5 style="text-align:center"><b>Figura 2.2. </b>Diagrama de Entrada-Salida de un Programa (Adaptado de: Joyanes Aguilar, L., 2008).</h5>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.7. Aplicaciones de Algoritmos en la Vida Cotidiana">
              <ng-template matTabContent>
                <br>
                <h1>Aplicaciones de Algoritmos en la Vida Cotidiana</h1>
              
                <p>Un …………………..xyz</p>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.1.8. Estructuras de Control en Lenguaje C/C++">
              <ng-template matTabContent>
                <br>
                <h1>Estructura de Control en Lenguaje C/C++</h1>
               
                <p>Las estructuras de control permiten manejar y modificar el flujo de ejecución de las instrucciones de un programa (Granizo E., 2016). Entre las principales estructuras de control están:</p>
                <ol type="a">
                  <li>Estructuras de control secuenciales.</li>
                  <li>Estructuras de control selectivas.</li>
                  <li>Estructuras de control repetitivas.</li>
                </ol>
              </ng-template>
            </mat-tab>
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Estructuras de Control Secuenciales">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="Introducción">
              <ng-template matTabContent>
                <br>
               <h1>Estructuras de Control Secuenciales</h1>
              
               <p>La estructura de control secuencial es aquella en la que una instrucción se ejecuta a continuación de otra a modo de secuencia, es decir, una instrucción no se ejecuta hasta que finaliza la anterior (Joyanes Aguilar, L., 2008). Las operaciones se suceden de tal modo que la salida de una es la entrada de la siguiente y así sucesivamente hasta el fin del proceso. Los principales componentes de las estructuras de control secuenciales son:</p>
               <ol type="a">
                 <li>Escritura</li>
                 <li>Lectura</li>
                 <li>Asignación
                   <ul>
                     <li>Asignación Simple</li>
                     <li>Asignación Contador</li>
                     <li>Asignación Acumulador</li>
                     <li>Asignación de Trabajo</li>
                   </ul>
                 </li>
               </ol>
               </ng-template>
            </mat-tab>
            <mat-tab  label="2.2.1. Escritura">
              <ng-template matTabContent>
                <br>
                <h1>Escritura</h1>

                <p>La escritura consiste en enviar por un dispositivo de salida un resultado o mensaje. En la sección 1.4.1 se explica a detalle la función de escritura en el Lenguaje C/C++. Esta operación se puede representar mediante pseudocódigo y Lenguaje C/C++ como se indica a continuación: </p>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="200"> <b> Pseudocódigo </b> </th>
                    <th width="200"> <b> Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR>
                    <td><p>entero : a</p>
                    <p>a &#8592; 7</p>
                    <p>Imprimir 'a'</p></td>
                    <td> <p>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> a;</font></p>
                    <p>a=7;</p>
                    <p>cout 
                      <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font>
                       a;</p></td>
                  </TR>
                </TABLE>

              </ng-template>
            </mat-tab>
            <mat-tab  label="2.2.2. Lectura">
              <ng-template matTabContent>
                <br>
                <h1>Lectura</h1>
              
                <p>La lectura consiste en recibir desde un dispositivo de entrada un valor. En la sección 1.4.2 se explica a detalle la función de lectura en el Lenguaje C/C++. Esta operación se puede representar mediante pseudocódigo y Lenguaje C/C++ como se indica a continuación:</p>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="200"> <b> Pseudocódigo </b> </th>
                    <th width="200"> <b> Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR>
                    <td><p>entero : a</p>
                    <p>Leer 'a'</p></td>
                    <td> <p>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> a;</font></p>
                    <p>cin 
                      <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                       a;</p></td>
                  </TR>
                </TABLE><br>
                <p><b>Ejercicio 2.1: </b>Escribir un programa que permita sumar dos números enteros, para lo cual se puede utilizar la siguiente expresión matemática: num3 = num1 + num2, considerando que se deben utilizar tres variables.</p>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> 
                    <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                    <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR>
                    <td>1</td>  <td>entero : num1</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> num1;</font>
                    </td>
                  </TR>
                  <TR>
                    <td>2</td>
                    <td>entero : num2</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> num2;</font>
                    </td>
                  </TR>
                  <TR>
                    <td>3</td> <td>entero : num3</td> <td> 
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> num3;</font>
                    </td>
                  </TR>
                  <TR><td>4</td><td>Leer num1</td><td>cin <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font> num1;</td></TR>
                  <TR><td>5</td><td>Leer num1</td><td>cin <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&lt;&lt;</font> num2;</td></TR>
                  <TR><td>6</td><td>num3 &#8592; num1 + num2</td><td>num3 = num1 + num2;</td></TR>
                  <TR><td>7</td><td>Imprimir mensaje: "Resultado de la suma: "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                    <font color="red">"Resultado de la suma: "</font>;</td></TR>
                  <TR><td>8</td><td>Imprimir num3</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> num3</td></TR>
                </TABLE>
                <br><h5><b>Programa 2.1.</b> Código del programa.</h5>
                <pre><code [highlight]="prefTab2[0].programa2_1"  [lineNumbers]="true"></code></pre><br>
                <p>La Ejecución 2.1, correspondiente a la salida del programa, muestra que al ingresar el primer número que es el 8 y el segundo número que es el 2, se obtiene la suma entre los dos números que es el 9.</p>
                <h5><b>Ejecución 2.2.</b>Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Ejecución 2.1.png" style="display:block; margin:auto; "><br>
                
              </ng-template>
            </mat-tab>
            <mat-tab  label="2.2.3. Asignación">
              <ng-template matTabContent>
                <br><h1>Asignación</h1>
                <p>La asignación consiste en el paso de valores a una zona de la memoria RAM, tal y como se describió en la sección 1.5.4 sobre el funcionamiento del operador de asignación igual. En la memoria RAM se almacenan temporalmente las variables que reciben valores de procesos lectura y de cálculos. La asignación se puede clasificar en cuatro tipos: a) Asignación simple; b) Asignación contador; c) Asignación acumulador; d) Asignación de trabajo.</p>
                <ol type="a">
                  <li><b>Asignación simple: </b>Esta asignación consiste en pasar un valor a una variable. Esta operación se puede representar mediante pseudocódigo y Lenguaje C/C++ como se indica a continuación:</li>
                </ol>
                <h4><b>Ejercicio 2.2: </b>Escribir un programa que permita probar la asignación simple, donde se asigna un valor a una variable, luego ese mismo valor se asigna a otra utilizando la misma variable y finalmente se imprime los valores de las dos variables. </h4>
                
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> 
                    <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                    <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR> <td>1</td>  <td>entero : a</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      a;</td>
                  </TR>
                  <TR>
                    <td>2</td>
                    <td>entero : b</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      <font color="black"> b;</font>
                    </td>
                  </TR>
                  <TR><td>3</td> <td>a &#8592; 7 </td> <td>a=7;</td> </TR>
                  <TR><td>4</td><td>b &#8592; a</td><td>b=a;</td></TR>
                  <TR><td>5</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>6</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  <TR><td>7</td><td>Imprimir mensaje: "Valor de 'b': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                    <font color="red">"Valor de 'b': "</font>;</td></TR>
                  <TR><td>8</td><td>Imprimir b</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> b</td></TR>
                </TABLE> <br>
                <h5><b>Programa 2.2. </b> Código del programa</h5>
                <pre><code [highlight]="prefTab2[0].programa2_2"  [lineNumbers]="true"></code></pre><br>
               <p>La Ejecución 2.2, correspondiente a la salida del programa, muestra que al ingresar el valor igual a 7 en la variable ‘a’, se asigna este mismo valor a la variable ‘b’ y se imprimen sus valores.</p>
               <h4><b>Ejecución 2.2. </b>Salida del programa</h4>
               <img src="./assets/images/Capitulos/II/media/Ejecución 2.2.png" style="display:block; margin:auto; "><br>
                
               <ol type="a" start="2">
                  <li><b>Asignación Contador: </b>Esta asignación consiste en usarla como un verificador del número de veces que se realiza un proceso. Esta operación se puede representar mediante pseudocódigo y Lenguaje C/C++ como se indica a continuación:</li>
                </ol>
                <h4><b>Ejercicio 2.3: </b>Escribir un programa que permita contar desde el uno hasta el cinco, utilizando un contador, donde inicialmente se le asigna el valor de cero a la variable que opera como contador, luego se utiliza este contador para contar hasta cinco y también se imprimen los valores del mismo.</h4>
                
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th><th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR> <td>1</td>  <td>entero : a</td><td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font> a;</td>
                  </TR>
                  <TR>
                    <td>2</td><td>a &#8592; 0</td><td>a=0;</td>
                  </TR>
                  <TR><td>3</td> <td>a &#8592; a+1 </td> <td>a=a+1;</td> </TR>
                  <TR><td>4</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>5</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  <TR><td>6</td> <td>a &#8592; a+1 </td> <td>a = a+1;</td> </TR>
                  <TR><td>7</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>8</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  <TR><td>9</td> <td>a &#8592; a+1 </td> <td>a = a+1;</td> </TR>
                  <TR><td>10</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>11</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  <TR><td>12</td> <td>a &#8592; a+1 </td> <td>a = a+1;</td> </TR>
                  <TR><td>13</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>14</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  <TR><td>15</td> <td>a &#8592; a+1 </td> <td>a = a+1;</td> </TR>
                  <TR><td>16</td><td>Imprimir mensaje: "Valor de 'a': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de 'a': "</font>; </td></TR>
                  <TR><td>17</td><td>Imprimir 'a'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> a;</td></TR>
                  
                </TABLE> <br>
                <h5><b>Programa 2.3. </b> Código del programa</h5>
                <pre><code [highlight]="prefTab2[0].programa2_3"  [lineNumbers]="true"></code></pre><br>
                <p>La Ejecución 2.3, correspondiente a la salida del programa, muestra que el valor del contador ‘a’ varía entre uno y cinco.</p>
                <h4><b>Ejecución 2.3. </b>Salida del programa</h4>
                <img src="./assets/images/Capitulos/II/media/Ejecución 2.3.png" style="display:block; margin:auto; "><br>

                <ol type="a" start="3">
                  <li><b>Asignación Acumulador: </b>Esta asignación consiste en usarla como un sumador o un producto en un proceso. </li>
                  <ul>
                    <li>Un sumador generalmente se inicializa con el neutro aditivo que es el valor de cero y se aplica la siguiente fórmula: sum = sum + valor; donde el valor depende de lo que se quiere acumular.</li>
                    <li>Un producto generalmente se inicializa con el neutro multiplicativo que es el valor de uno y se aplica la siguiente fórmula: prod = prod * valor; donde el valor depende de lo que se quiere acumular.</li>
                  </ul>
                  Estas operaciones se pueden representar mediante pseudocódigo y Lenguaje C/C++ como se indican a continuación en los siguientes ejercicios:
                </ol>
                <h4><b>Ejercicio 2.4: </b>Escribir un programa que permita realizar la sumatoria de los cinco primeros dígitos, es decir, 1+2+3+4+5, utilizando cinco variables y un acumulador de sumas. A cada variable se le asigna uno de los dígitos y luego se le asigna al acumulador cada variable, para finalmente imprimir el valor del acumulador.</h4>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> 
                    <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                    <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR> <td>1</td>  <td>entero : n1</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n1;</td>
                  </TR>
                  <TR> <td>2</td>  <td>entero : n2</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n2;</td>
                  </TR>
                  <TR> <td>3</td>  <td>entero : n3</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n3;</td>
                  </TR>
                  <TR> <td>4</td>  <td>entero : n4</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n4;</td>
                  </TR>
                  <TR> <td>5</td>  <td>entero : n5</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n5;</td>
                  </TR>
                  <TR> <td>6</td>  <td>entero : sum</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      sum;</td>
                  </TR>
                  <TR><td>7</td> <td>n1 &#8592; 1 </td> <td>n1 = 1;</td> </TR>
                  <TR><td>8</td> <td>n2 &#8592; 2 </td> <td>n2 = 2;</td> </TR>
                  <TR><td>9</td> <td>n3 &#8592; 3 </td> <td>n3 = 3;</td> </TR>
                  <TR><td>10</td> <td>n4 &#8592; 4 </td> <td>n4 = 4;</td> </TR>
                  <TR><td>11</td> <td>n5 &#8592; 5 </td> <td>n5 = 5;</td> </TR>
                  <TR><td>12</td><td>sum &#8592; 0</td><td>sum = 0;</td></TR>
                  <TR><td>13</td><td>sum &#8592; sum + n1</td><td>sum = sum + n1;</td></TR>
                  <TR><td>14</td><td>sum &#8592; sum + n2</td><td>sum = sum + n2;</td></TR>
                  <TR><td>15</td><td>sum &#8592; sum + n3</td><td>sum = sum + n3;</td></TR>
                  <TR><td>16</td><td>sum &#8592; sum + n4</td><td>sum = sum + n4;</td></TR>
                  <TR><td>17</td><td>sum &#8592; sum + n5</td><td>sum = sum + n5;</td></TR>
                  <TR><td>18</td><td>Imprimir mensaje: "Valor del acumulador 'sum': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor del acumulador 'sum': "</font>; </td></TR>
                  <TR><td>19</td><td>Imprimir 'sum'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> sum;</td></TR>
                </TABLE> <br>

                <h5><b>Programa 2.4. </b> Código del programa</h5>
                <pre><code [highlight]="prefTab2[0].programa2_4"  [lineNumbers]="true"></code></pre><br>
                <p>La Ejecución 2.4, correspondiente a la salida del programa, muestra que la variable ‘sum’ tiene acumulado el valor de 15 que representa la sumatoria de los cinco primeros dígitos.</p>
                <h4><b>Ejecución 2.4. </b>Salida del programa</h4>
                <img src="./assets/images/Capitulos/II/media/Ejecución 2.4.png" style="display:block; margin:auto; "><br>

                <h4><b>Ejercicio 2.5: </b>Escribir un programa que permita realizar el producto de los cinco primeros dígitos, es decir, 1*2*3*4*5, utilizando cinco variables y un acumulador de productos. A cada variable se le asigna uno de los dígitos y luego se le asigna al acumulador cada variable, para finalmente imprimir el valor del acumulador.</h4>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> 
                    <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                    <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR> <td>1</td>  <td>entero : n1</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n1;</td>
                  </TR>
                  <TR> <td>2</td>  <td>entero : n2</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n2;</td>
                  </TR>
                  <TR> <td>3</td>  <td>entero : n3</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n3;</td>
                  </TR>
                  <TR> <td>4</td>  <td>entero : n4</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n4;</td>
                  </TR>
                  <TR> <td>5</td>  <td>entero : n5</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      n5;</td>
                  </TR>
                  <TR> <td>6</td>  <td>entero : prod</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      prod;</td>
                  </TR>
                  <TR><td>7</td> <td>n1 &#8592; 1 </td> <td>n1 = 1;</td> </TR>
                  <TR><td>8</td> <td>n2 &#8592; 2 </td> <td>n2 = 2;</td> </TR>
                  <TR><td>9</td> <td>n3 &#8592; 3 </td> <td>n3 = 3;</td> </TR>
                  <TR><td>10</td> <td>n4 &#8592; 4 </td> <td>n4 = 4;</td> </TR>
                  <TR><td>11</td> <td>n5 &#8592; 5 </td> <td>n5 = 5;</td> </TR>
                  <TR><td>12</td><td>prod &#8592; 0</td><td>prod = 0;</td></TR>
                  <TR><td>13</td><td>prod &#8592; prod * n1</td><td>prod = prod * n1;</td></TR>
                  <TR><td>14</td><td>prod &#8592; prod * n2</td><td>prod = prod * n2;</td></TR>
                  <TR><td>15</td><td>prod &#8592; prod * n3</td><td>prod = prod * n3;</td></TR>
                  <TR><td>16</td><td>prod &#8592; prod * n4</td><td>prod = prod * n4;</td></TR>
                  <TR><td>17</td><td>prod &#8592; prod * n5</td><td>prod = prod * n5;</td></TR>
                  <TR><td>18</td><td>Imprimir mensaje: "Valor del acumulador 'prod': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor del acumulador 'prod': "</font>; </td></TR>
                  <TR><td>19</td><td>Imprimir 'prod'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> prod;</td></TR>
                </TABLE> <br>
                <h5><b>Programa 2.5. </b> Código del programa</h5>
                <pre><code [highlight]="prefTab2[0].programa2_5"  [lineNumbers]="true"></code></pre><br>
                <p>La Ejecución 2.5, correspondiente a la salida del programa, muestra que la variable ‘prod’ tiene acumulado el valor de 120 que representa el producto de los cinco primeros dígitos.</p>
                <h4><b>Ejecución 2.5. </b>Salida del programa</h4>
                <img src="./assets/images/Capitulos/II/media/Ejecución 2.5.png" style="display:block; margin:auto; "><br>

                <ol type="a" start="4">
                  <li><b>Asignación de Trabajo: </b>Esta asignación consiste en recibir el resultado de una operación o fórmula matemática que involucre muchas variables. Esta operación se puede representar mediante pseudocódigo y Lenguaje C/C++ como se indica a continuación:</li>
                </ol>
                <h4><b>Ejercicio 2.6: </b>Escribir un programa que permita probar la siguiente expresión matemática: d = (a * c) + (c / 2), para lo cual se deben utilizar cuatro variables, donde las variables ‘a’, ‘b’ y ‘c’ tienen los valores de 5, 2 y 7 respectivamente.</h4>
                <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                  <TR>
                    <th width="10"> <b> N° </b> </th> 
                    <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                    <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                  </TR>
                  <TR> <td>1</td>  <td>entero : a</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      a;</td>
                  </TR>
                  <TR> <td>2</td>  <td>entero : b</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      b;</td>
                  </TR>
                  <TR> <td>3</td>  <td>entero : c</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      c;</td>
                  </TR>
                  <TR> <td>4</td>  <td>entero : d</td>
                    <td>
                      <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int</font>
                      d;</td>
                  </TR>
                  <TR><td>5</td> <td>a &#8592; 5 </td> <td>a = 5;</td> </TR>
                  <TR><td>6</td> <td>b &#8592; 2 </td> <td>b = 2;</td> </TR>
                  <TR><td>7</td> <td>c &#8592; 7 </td> <td>c = 7;</td> </TR>
                  <TR><td>8</td> <td>d &#8592; (a*c) + (c/2) </td> <td>d = (a*c) + (c/2) ;</td> </TR>
                  <TR><td>9</td><td>Imprimir mensaje: "Valor de la expresión 'd': "</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> 
                    <font color="red">"Valor de la expresión 'd': "</font>; </td></TR>
                  <TR><td>10</td><td>Imprimir 'd'</td><td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> d;</td></TR>
                </TABLE> <br>
                <h5><b>Programa 2.6. </b> Código del programa</h5>
                <pre><code [highlight]="prefTab2[0].programa2_6"  [lineNumbers]="true"></code></pre><br>
                <p>La Ejecución 2.6, correspondiente a la salida del programa, muestra que el valor de la expresión matemática evaluada es igual a 38.</p>
                <h4><b>Ejecución 2.6. </b>Salida del programa</h4>
                <img src="./assets/images/Capitulos/II/media/Ejecución 2.6.png" style="display:block; margin:auto; "><br>

              </ng-template>
            </mat-tab>
            <mat-tab  label="2.2.4. Casos de Estudio">
              <ng-template matTabContent>
                <br>
                <h1><b>Caso de Estudio 2.1: Encontrar el Perímetro y el Área de un Círculo.</b></h1>
                <h2><b>A) Problema</b></h2>
                <p>Escribir un programa para calcular e imprimir el perímetro y el área de un círculo. (Ver Figura 2.1.1)</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.1.1.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.1.1. </b>El círculo y sus fórmulas</h5>
                
                <h2><b>B) Análisis</b></h2>
                <p>Claramente, se puede ver que la entrada del problema es el radio del círculo. Hay dos salidas requeridas: el perímetro y el área del círculo. Partiendo de un conocimiento básico de geometría, se sabe que hay una relación entre el radio del círculo con el perímetro y con el área de la figura geométrica. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
                <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Constante del Problema</b></p>
                <p>PI=3.141596</p>
                <p><b>Entradas del Problema</b></p>
                <table>
                  <tr><td width="200">radio</td><td width="200">/* radio del círculo */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200">perímetro</td><td width="200">/* perímetro del círculo */</td></tr>
                  <tr><td>área</td><td>/* área del círculo */</td></tr>
                </table><br>
                <p><b>Fórmulas Relevantes</b></p>
                <table>
                  <tr><td width="60"><em>P= 2 &pi; r</em></td><td width="30"> (1) </td><td width="270">/* Fórmula del perímetro de un círculo */</td></tr>
                  <tr><td ><em>A=&pi; r <sup>2</sup></em></td><td> (2) </td><td>/* Fórmula del área de un círculo */</td></tr>
                  
                </table> <br>
                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.1.2 se muestra el Diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘radio’; b) Salidas: las variables ‘perimetro’ y ‘area’; c) Auxiliares: la constante PI.</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.1.2.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.1.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <br>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                <p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el radio del círculo.</li>
                  <li>Calcular el perímetro.</li>
                    <ol type="1" start="2">
                      <li>1. Asignar el producto de dos veces PI por el radio a la variable ‘perimetro’.</li>
                    </ol>
                  <li>Calcular el área.</li>
                  <ol type="1" start="3">
                    <li>1.	Asignar el producto de PI por el cuadrado del radio a la variable ‘area’.</li>
                  </ol>
                  <li>Imprimir el valor de la variable 'perímetro' y de la variable 'área'</li>
                </ol>
                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.1.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.1.1. </b>Programa que calcula el perímetro y el área del círculo.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_1_1"  [lineNumbers]="true"></code></pre>
                <br>
                <h2>E) Pruebas</h2>
                <p>La Tabla 2.1.2 muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora, donde como se puede ver en la siguiente salida del programa, se le pide al usuario que ingrese un valor para el radio que puede ser ‘5’ y el programa calcula los valores del perímetro y del área como son ‘31.41’ y ‘78.53’ respectivamente.</p>
                <h5><b>Tabla 2.1.2.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.1.2.png" style="display:block; margin:auto; "><br>
                
                <h1><b>Caso de Estudio 2.2: Encontrar el Perímetro y el Área de un Rectángulo.</b></h1>
                <h2><b>A) Problema</b></h2>
                <p>Escribir un programa para calcular e imprimir el perímetro y el área de un rectángulo. (Ver Figura 2.2.1)</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.2.1.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.2.1. </b>El rectángulo y sus fórmulas</h5>
                <h2><b>B) Análisis</b></h2>
                <p>Claramente, se puede ver que las entradas del problema son el ancho y el largo del rectángulo. Hay dos salidas requeridas: el perímetro y el área del rectángulo. Partiendo de un conocimiento básico de geometría, se sabe que hay una relación entre el ancho y el largo del rectángulo con el perímetro y con el área de la figura geométrica. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
                <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Entradas del Problema</b></p>
                <table>
                  <tr><td width="200">ancho</td><td width="200">/* ancho del rectángulo */</td></tr>
                  <tr><td width="200">largo</td><td width="200">/* largo del rectángulo */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200">perímetro</td><td width="200">/* perímetro del rectángulo  */</td></tr>
                  <tr><td width="200">área</td><td width="200">/* área del rectángulo */</td></tr>
                </table><br>
                <p><b>Fórmulas Relevantes</b></p>
                <table>
                  <tr><td width="70"><em>P= 2a + 2b</em></td><td width="30"> (1) </td><td width="280">/* Fórmula del perímetro de un rectángulo */</td></tr>
                  <tr><td ><em>A= ab <sup>2</sup></em></td><td> (2) </td><td>/* Fórmula del área de un rectángulo */</td></tr>
                </table> <br>
                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.2.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas y salidas del problema como son: a) Entradas: las variables ‘ancho’ y ‘largo’; b) Salidas: las variables ‘perimetro’ y ‘area’.</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.2.2.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.2.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                <p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el ancho del rectángulo.</li>
                  <li>Leer el largo del rectángulo.</li>
                  <li>Calcular el perímetro.</li>
                  <ol type="1"  start="3">
                    <li>1. Asignar el producto de dos veces el ancho por dos veces el largo a la variable ‘perimetro’.</li>
                  </ol>
                  <li>Calcular el área.</li>
                  <ol type="1" start="4">
                    <li>1. Asignar el producto del ancho por el largo a la variable ‘area’.</li>
                    
                  </ol>
                  <li>Imprimir el valor de la variable ‘perimetro’ y de la variable ‘area’.</li>
                </ol>

                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.2.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.2.1. </b>Programa que calcula el perímetro y el área del rectángulo.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_2_1"  [lineNumbers]="true"></code></pre>
                <br>
                <h2>E) Pruebas</h2>
                <p>La Tabla 2.2.2 muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <h5><b>Tabla 2.2.2. </b>Salida del programa.</h5>

                <img src="./assets/images/Capitulos/II/media/Tabla 2.2.2.png" style="display:block; margin:auto; "><br>
                
                <h1><b>Caso de Estudio 2.3: Encontrar la Generatriz, el Área y el Volumen de un Cono.</b> </h1>
                
                <h2><b>A) Problema</b></h2>
                <p>Escribir un programa para calcular e imprimir la generatriz, el área y el volumen de un cono. (Ver Figura 2.2.1)</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.3.1.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.2.1. </b>El Cono y sus fórmulas.</h5>
                <h5></h5>
                <h2><b>B) Análisis</b></h2>
                <p>Claramente, se puede ver que las entradas del problema son el radio y la altura del cono. Hay tres salidas requeridas: la generatriz, el área y el volumen del cilindro. Partiendo de un conocimiento básico de geometría, se sabe que hay una relación entre el radio y la altura del rectángulo con la generatriz, con el área y con el volumen de la figura geométrica. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
                <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Constante del Problema</b></p>
                <p>PI=3.141596</p>
                <p><b>Entradas del Problema</b></p>
                <table>
                  <tr><td width="200">r</td><td width="200">/* radio del Cono */</td></tr>
                  <tr><td width="200">h</td><td width="200">/* altura del cono */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200">perímetro</td><td width="200">/* generatriz del cono  */</td></tr>
                  <tr><td width="200">área</td><td width="200">/* área del cono*/</td></tr>
                  <tr><td>volumen</td><td>/* volumen del cono */</td></tr>
                </table><br>

                <p><b>Fórmulas Relevantes</b></p>
                <table>
                  <tr><td width="120"><em>g= &#8730;(r<sup>2</sup> + h<sup>2</sup> ) </em></td><td width="30"> (1) </td><td width="280">/* Fórmula de la generatriz de un cono */</td></tr>
                  <tr><td ><em>A= &pi;∙r∙g + &pi;∙r<sup>2</sup></em></td><td> (2) </td><td>/* Fórmula del área de un cono */</td></tr>
                  <tr><td><em>V= <sup>1</sup>/<sub>3</sub> &pi;∙r<sup>2</sup>∙h</em></td><td>(3)</td> <td>/* Fórmula del volumen de un cono */</td></tr>
                </table> <br>

                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.3.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘r’ (radio) y la variable ‘h’ (altura); b) Salidas: las variables ‘g’ (generatriz), ‘area’ y ‘volumen’; c) Auxiliares: la constante PI.</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.3.2.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.3.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h3><b>B.3) Diagrama de Proceso</b></h3>
                <p>En la Figura 2.3.2 se muestra el diagrama de procesos del problema donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘r’ (radio) y la variable ‘h’ (altura); b) Salidas: las variables ‘g’ (generatriz), ‘area’ y ‘volumen’; c) Auxiliares: la constante PI.</p>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                <p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el radio del cono, utilizando la variable ‘r’.</li>
                  <li>Leer la altura del cono, utilizando la variable ‘h’.</li>
                  <li>Calcular la generatriz del cono.</li>
                  <ol type="1" start="3">
                    <li>1. Asignar la raíz cuadrada de la suma del cuadrado del radio más el cuadrado de la altura (‘h’), a la variable ‘g’ (generatriz).</li>
                  </ol>
                  <li>Calcular el área.</li>
                  <ol type="1" start="4">
                    <li>1. Asignar la suma entre el producto de PI por el radio y por la altura más el producto de PI por el cuadrado del radio, a la variable ‘area’.</li>
                    
                  </ol>
                  <li>Calcular el volumen.</li>
                  <ol type="1" start="5">
                    <li>1. Asignar el producto de un tercio por PI por el cuadrado del radio y por la altura, a la variable ‘volumen’.</li>
                  </ol>
                  <li>Imprimir el valor de la variable ‘g’ (generatriz), de la variable ‘area’ y de la variable ‘volumen’.</li>
                </ol>


                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.3.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.3.1. </b>Programa que calcula la generatriz, el área y el volumen del cono.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_3_1"  [lineNumbers]="true"></code></pre> <br>
                <h2>E) Pruebas</h2>
                <p>La Tabla 2.3.2 muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <h5><b>Tabla 2.3.2.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.3.2.png" style="display:block; margin:auto; "><br>
                
                <h1><b>Caso de Estudio 2.4: Encontrar la distancia, tiempo de vuelo y la altura alcanzada por un proyectil.</b> </h1>
                <h2><b>A) Problema</b></h2>
                <p>Escribir un programa para calcular e imprimir la distancia ‘d’, el tiempo de vuelo ‘t’ y la altura ‘h’ alcanzada por un proyectil que es disparado con un ángulo θ (‘theta’) en grados con respecto a la horizontal y a una velocidad inicial ‘v’ en m/seg. La trayectoria parabólica del proyectil se muestra en la Figura 2.4.1 y cuyas fórmulas son las siguientes:</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.4.1.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.4.1. </b>Tiro Parabólico de un Proyectil.</h5>
                <h5></h5>
                <h2><b>B) Análisis</b></h2>
                <p>Claramente, se puede ver que las entradas del problema son la velocidad inicial de lanzamiento del proyectil y el ángulo de lanzamiento theta en grados. Hay tres salidas requeridas: el tiempo de vuelo, la distancia y la altura alcanzada por un proyectil. Partiendo de un conocimiento básico de Física, se sabe que hay una relación entre la velocidad y el ángulo de lanzamiento con la distancia, el tiempo de vuelo y la altura. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
                <h3><b>B.1) Requerimiento de los Datos</b></h3>
                <p><b>Constante del Problema</b></p>
                <p>PI= 3.141596</p>
                <p>g= 9.8</p>
                <p><b>Entradas del Problema</b></p>
                <table>
                  <tr><td width="200">v</td><td width="200">/* velocidad de lanzamiento  */</td></tr>
                  <tr><td width="200">theta</td><td width="200">/* ángulo de lanzamiento  */</td></tr>
                </table>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200">d</td><td width="200">/* distancia alcanzada por el proyectil */</td></tr>
                  <tr><td width="200">t</td><td width="200">/* tiempo de vuelo */</td></tr>
                  <tr><td>h</td> <td>/* altura alcanzada por el proyectil */</td></tr>
                </table>

                <p><b>Fórmulas Relevantes</b></p>
                <table>
                  <tr><td width="100"><em>d=(v<sup>2</sup>∙sen(2θ))/g</em></td><td width="30"> (1) </td><td width="280">/* Fórmula de la distancia alcanzada por el proyectil */</td></tr>
                  <tr><td ><em>t=(v∙sen(2θ))/g</em></td><td> (2) </td><td>/* Fórmula del tiempo de vuelo del proyectil */</td></tr>
                  <tr><td><em>h=(v<sup>2</sup>∙sen<sup>2</sup>(θ))/g</em></td><td>(3)</td><td>/* Fórmula de la altura alcanzada por el proyectil */</td></tr>
                </table><br>

                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.4.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘v’ (velocidad) y la variable ‘theta’ (ángulo); b) Salidas: las variables ‘d’ (distancia), ‘t’ (tiempo) y ‘h’ (altura); c) Auxiliares: la constante ‘PI’ y la constante ‘g’ (gravedad).</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.4.2.PNG" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.4.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conocen las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                <p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el valor de la velocidad en m/seg, utilizando la variable ‘v’.</li>
                  <li>Leer el valor del ángulo theta en grados, utilizando la variable ‘theta’.</li>
                  <li>Convertir el ángulo theta de grados a radianes.</li>
                  <ol type="1" start="3">
                    <li>1. Asignar a la variable theta el producto del ángulo theta por la constante PI y dividirlo para el valor de 180 grados.</li>
                  </ol>
                  <li>Calcular la distancia alcanzada por el proyectil.</li>
                  <ol type="1" start="4">
                    <li>1.	Asignar a la variable ‘d’ (distancia) los valores que contempla la fórmula de la distancia (1), según la Física Clásica</li>
                  </ol>
                  <li>Calcular el tiempo de vuelo del proyectil</li>
                  <ol type="1" start="5">
                    <li>1.	Asignar a la variable ‘t’ (tiempo) los valores que contempla la fórmula del tiempo de vuelo (2), según la Física Clásica.</li>
                  </ol>
                  <li>Calcular la altura alcanzada por el proyectil.</li>
                  <ol type="1" start="6">
                    <li>1.	Asignar a la variable ‘h’ (altura) los valores que contempla la fórmula de la altura (3), según la Física Clásica.</li>
                  </ol>
                  <li>Imprimir los valores de la variable ‘d’ (distancia), de la variable ‘t’ (tiempo) y de la variable ‘h’ (altura).</li>
                </ol>

                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.4.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.4.1. </b>Programa que calcula la distancia, tiempo de vuelo y la altura alcanzada por un proyectil.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_4_1"  [lineNumbers]="true"></code></pre> <br>
                <h2>E) Pruebas</h2>
                <p>En la Tabla 2.4.2 se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <h5><b>Tabla 2.4.2. </b>Salida del programa.</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.4.2.png" style="display:block; margin:auto; "><br>
                
              </ng-template>
            </mat-tab>
            
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Estructuras de Control de Selección">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="2.3.1. La sentencia if">
              <ng-template matTabContent>
              </ng-template>
            </mat-tab>
            <mat-tab  label="2.3.2. La sentencia if-else">
              <ng-template matTabContent>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.3.3. Sentencias if-else Anidadas">
              <ng-template matTabContent>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.3.4. Secuencia de Sentencias if">
              <ng-template matTabContent>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.3.5. Secuencia de Sentencias if-else">
            </mat-tab>

            <mat-tab  label="2.3.6. Sentencia de Control switch">
            </mat-tab>
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Estructuras de Control Repetitivas o Bucles">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
              <mat-tab  label="Introducción">
                <ng-template matTabContent>
                  <br>
                  <h1>Estructuras de Control Repetitivas o Bucles</h1>
                  <p>La estructura de control conocida como bucle es aquella que realiza la repetición o iteración de acciones. La sentencia o grupos de sentencias que se repiten en un bloque se denominan cuerpo del bucle y cada repetición del cuerpo del bucle se llama iteración del bucle. Las principales sentencias de repetición son:
                  </p>
                  <ol type="a">
                    <li>La sentencia while </li>
                    <li>	La sentencia do-while </li>
                     <li>	La sentencia for </li>
                    <li>	Bucles anidados  </li> 
                  </ol>
                </ng-template>
              </mat-tab>
              <mat-tab  label="2.4.1. La sentencia while">
                <ng-template matTabContent>
                  <br><h1>La sentencia while()</h1>
                  <p>La sentencia while() crea un bucle que se repite hasta que la expresión lógica o condición del bucle se vuelva falsa. El cuerpo del bucle while() se ejecutará cero o más veces dependiendo de la condición del bucle. El formato de esta sentencia tiene la siguiente sintaxis:</p>
                  <p><b>Sintaxis 1:</b></p>
                  <pre><code align="left">while(Condición_Bucle)
      sentencia;</code></pre>
                    <table>
                      <tr VALIGN=top><td><code>Condición_Bucle</code></td>
                        <td>Expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva.</td></tr>
                        <tr VALIGN=top><td><code>sentencia</code></td>
                        <td>La sentencia o acción se ejecuta si la expresión lógica es verdadera dentro del bucle.</td></tr>
                    </table>
                    <br>
                    <table border="1" CELLPADDING=5 CELLSPACING=0>
                      <tr VALIGN=top><td width="50"><b> Nota:</b></td><td>  En esta sintaxis no es necesario utilizar llaves ya que se tiene una sola sentencia o instrucción.</td></tr>
                    </table>
                    <br>
                    <p><b>Sintaxis 2:</b></p>
                  <pre><code align="left">while(Condición_Bucle)
  &#65371;
        sentencia<sub>1</sub>;
        sentencia<sub>2</sub>;
        ...
        sentencia<sub>n</sub>;
  &#65373; 
  </code></pre>
                    <table>
                      <tr VALIGN=top><td><code>Condición_Bucle</code></td>
                        <td>Expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva.</td></tr>
                        <tr VALIGN=top><td><code>sentencia</code></td>
                        <td>Las acciones o sentencias se ejecutan si la expresión lógica es verdadera dentro del bucle.</td></tr>
                    </table>
                    <br>
                    <h4><b>Ejercicio 2.17: </b>Escribir un programa que permita imprimir de manera ascendente los números del 1 al 10 utilizando un bucle while().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en uno</td>
                        <td>i = 1;  </td>
                      </TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &gt;=10) &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Incrementar el valor del contador en uno.</td>
<td><pre>i++;
  &#65373; 
</pre> </td></TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.17: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_17"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.17 se puede ver la impresión del 1 al 10 de manera creciente.</p>
                    <h5><b>Ejecución 2.17 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.17.png" style="display:block; margin:auto; "><br>
                    <p>En la Tabla 2.17 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se incrementa en uno, mientras la condición del bucle sea verdadera.</p>
                    <h5><b>Tabla 2.17: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>1</td><td>1 &gt;=10 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>2</td><td>2 &gt;=10 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>3</td><td>3 &gt;=10 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>4</td><td>4 &gt;=10 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>5</td><td>5 &gt;=10 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>6</td><td>6 &gt;=10 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>7</td><td>7 &gt;=10 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>8</td><td>8 &gt;=10 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>9</td><td>9 &gt;=10 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>10</td><td>10 &gt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>11</td><td style="color:rgb(33, 15, 201)">11 &gt;=10 (F)</td><td> </td></tr>
                      
                    </table>
                    <br>
                    <h4><b>Ejercicio 2.18: </b>Escribir un programa que permita imprimir de manera descendente los números del 10 al 1 utilizando un bucle while().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en diez</td>
                        <td>i = 10;  </td>
                      </TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &lt;=1) &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Decrementar el valor del contador en uno.</td>
<td><pre>i--;
  &#65373; 
</pre> </td></TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.18: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_18"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.18 se puede ver la impresión del 10 al 1 de manera decreciente.</p>
                    <h5><b>Ejecución 2.18 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.18.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.18 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en uno, mientras la condición del bucle sea verdadera.</p>
                    <h5><b>Tabla 2.18: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &lt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>10</td><td>10 &lt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>9</td><td>9 &lt;=1 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>8</td><td>8 &lt;=1 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>7</td><td>7 &lt;=1 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>6</td><td>6 &lt;=1 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>5</td><td>5 &lt;=1 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>4</td><td>4 &lt;=1 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>3</td><td>3 &lt;=1 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>2</td><td>2 &lt;=1 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>1</td><td>1 &lt;=1 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>0</td><td style="color:rgb(33, 15, 201)">0 &lt;=1 (F)</td><td> </td></tr>
                      
                    </table><br>
                    <h4><b>Ejercicio 2.19: </b>Escribir un programa que permita imprimir de manera ascendente los números pares del 2 al 10 utilizando un bucle while().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en dos</td>
                        <td>i = 2;  </td>
                      </TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &gt;=1) &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Incrementar el valor del contador en dos.</td>
<td><pre>i=i+2;
  &#65373; 
</pre> </td></TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.19: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_19"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.19 se puede ver la impresión de los números pares del 2 al 10 de manera creciente.</p>
                    <h5><b>Ejecución 2.19 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.19.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.19 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se incrementa en dos, mientras la condición del bucle sea verdadera.
</p>
                    <h5><b>Tabla 2.19: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>2</td><td>2 &gt;=10 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>4</td><td>4 &gt;=10 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>6</td><td>6 &gt;=10 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>8</td><td>8 &gt;=10 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>10</td><td>10 &gt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>12</td><td>12 &gt;=10 (F)</td><td> </td></tr>                      
                    </table> <br>
 <h4><b>Ejercicio 2.20: </b>Escribir un programa que permita imprimir de manera descendente los números impares del 9 al 1 utilizando un bucle while().
</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en nueve</td>
                        <td>i = 9;  </td>
                      </TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &lt;=1) &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Decrementar el valor del contador en dos.</td>
<td><pre>i=i-2;
  &#65373; 
</pre> </td></TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.20: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_20"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.20 se puede ver la impresión del 9 al 1 de manera decreciente.
</p>
                    <h5><b>Ejecución 2.20 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.20.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.20 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en dos, mientras la condición del bucle sea verdadera.

</p>
                    <h5><b>Tabla 2.20: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=1</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>9</td><td>9 &gt;=1 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>7</td><td>7 &gt;=1 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>5</td><td>5 &gt;=1 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>3</td><td>3 &gt;=1 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>1</td><td>1 &gt;=1 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>-1</td><td>-1 &gt;=1 (F)</td><td> </td></tr>                      
                    </table> <br>
                    <h1><b>Caso de Estudio 2.17: Sumatoria y Promedio de un Grupo de Notas.</b></h1>
                    <h2><b>A) Problema</b></h2>
                    <p>Escribir un programa que permita calcular la sumatoria y el promedio de un grupo de notas leídas desde el teclado.</p>
                    <h2><b>B) Análisis</b></h2>
                    <p>Claramente se puede ver que las entradas del problema son el número de notas representada por la variable ‘n’ y el valor de una nota representada por la variable ‘nota’. Hay dos salidas requeridas que son la sumatoria de un grupo de notas representada por la variable ‘sum’ y el promedio de un grupo de notas representada por la variable ‘prom’. Se requiere un dato auxiliar que es el contador del bucle representado por la variable ‘i’. El requerimiento de los datos y las fórmulas requeridas se muestran a continuación. </p>
                    <h3><b>Requerimiento de los Datos</b></h3>
                    <p><b>Entradas del Programa</b></p>
                    <table>
                      <tr><td width="200">n</td><td width="200">/* Número de notas */</td></tr>
                      <tr><td width="200">nota</td><td width="200">/* Valor de una nota */</td></tr>
                    </table><br>
                    <p><b>Salidas del Problema</b></p>
                    <table>
                      <tr><td width="200">sum</td><td width="200">/* Sumatoria de un grupo de notas  */</td></tr>
                      <tr><td width="200">prom</td><td width="200">/* Media o promedio de un grupo de notas */</td></tr>
                     </table><br>
                    <p><b>Auxiliares del Problema</b></p>
                    <table>
                      <tr><td width="200">i</td><td width="200">/* Contador del bucle  */</td></tr>
                   </table><br>
                   <p><b>Fórmulas Relevantes</b></p>
                      <table>
                        <tr><td width="120"><em>sum = sum + valor </em></td><td width="30"> (1) </td><td width="280">/* Fórmula que representa el acumulador de una sumatoria */</td></tr>
                        <tr><td ><em>prom = <sup>sum</sup> / <sub>n</sub></em></td><td> (2) </td><td>/* Fórmula que calcula el promedio de un grupo de elementos en función del valor de la sumatoria  */</td></tr>
                      </table> <br>
                      <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.17.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘n’; la variable ‘nota’; b) Salidas: la variable ‘sum’; la variable ‘prom’; c) Auxiliares: el contador ‘i’.
</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.17.2.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.17.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                
		<p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Impresión de un mensaje de información.</li>
                  <li>Leer el valor del número de notas que se desea ingresar.</li>
		<li>Inicializar el valor del contador en uno.</li>
		<li>Inicializar el valor de la sumatoria en cero.</li>                  
		<li>Mientras el valor del contador ‘i’ sea menor o igual que cero, hacer:</li>
                  <ol type="1" start="5">
                    <li>1. Leer el valor de una nota.</li>
                  </ol><ol type="1" start="5">
                    <li>2. Asignar al acumulador de sumas ‘sum’ el valor que tiene acumulado más el valor de una nueva nota, utilizando la ecuación (1).</li>
                  </ol><ol type="1" start="5">
                    <li>3. Incrementar el valor del contador ‘i’ en uno.</li>
                  </ol>
                  <li>Calcular el valor del promedio de un grupo de notas, utilizando la ecuación (2).</li>
                  <li>Imprimir el valor de la sumatoria de un grupo de notas.</li>
                  
                  <li>Imprimir el valor del promedio de un grupo de notas.</li>
                </ol>
                
                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.17.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.17.1. </b>Programa que convierte un número decimal en un número binario.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_17_1"  [lineNumbers]="true"></code></pre> <br>
                <h2>E) Pruebas</h2>
                <p>En la Tabla 2.17.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <p>En la salida de la Tabla 2.17.2 se puede ver que, se solicita al usuario que ingrese el número de notas que para este ejemplo es 10. Luego, el usuario ingresa cada una de las 10 notas y el programa calcula la sumatoria y el promedio.</p>
		<h5><b>Tabla 2.17.2.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.17.2.png" style="display:block; margin:auto; "><br>
		<p>En la Tabla 2.17.3, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada ciclo del bucle while() se lee el valor de una nota y se suma en un acumulador el valor que tiene con el valor de una nueva nota ingresada desde el teclado y se incrementa en uno el valor del contador. Finalmente, la ejecución de la sentencia while() termina cuando la condición del bucle se hace falsa.</p>
               <h5><b>Tabla 2.17.2. </b>Prueba de escritorio del programa.</h5>

               <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                <tr style="color:red"><td>n</td><td>i</td><td>i &gt;=n</td><td>nota</td><td>sum</td><td>prom</td></tr>
                <tr><td>10</td><td>1</td><td>1 &gt;=10 (V)</td><td>11.8</td><td>0</td><td>13.983</td></tr>
                <tr><td></td><td>2</td><td>2 &gt;=10 (V)</td><td>12.6</td><td>0+11.8=11.8</td><td></td></tr>
                <tr><td></td><td>3</td><td>3 &gt;=10 (V)</td><td>16.5</td><td>11.8+12.6=24.4</td><td></td></tr>
                <tr><td></td><td>4</td><td>4 &gt;=10 (V)</td><td>18.03</td><td>24.4+16.5=40.9</td><td></td></tr>
                <tr><td></td><td>5</td><td>5 &gt;=10 (V)</td><td>14.8</td><td>40.9+18.03=58.93</td><td></td></tr>
                <tr><td></td><td>6</td><td>6 &gt;=10 (V)</td><td>10.3</td><td>58.93+14.8=73.73</td><td></td></tr>
                <tr><td></td><td>7</td><td>7 &gt;=10 (V)</td><td>7.4</td><td>73.73+10.3=84.03</td><td></td></tr>
                <tr><td></td><td>8</td><td>8 &gt;=10 (V)</td><td>17.6</td><td>84.03+7.4=91.43</td><td></td></tr>
                <tr><td></td><td>9</td><td>9 &gt;=10 (V)</td><td>16.2</td><td>91.43+1706=109.03</td><td></td></tr>
                <tr><td></td><td>10</td><td>10 &gt;=10 (V)</td><td>14.6</td><td>109.03+16.2=125.23</td><td></td></tr>
                <tr><td></td><td>11</td><td style="color:blue">11 &gt;=10 (F)</td><td>11.8</td><td>125.23+14.6=139.83</td><td></td></tr>
                        
              </table> <br>
              <h1><b>Caso de Estudio 2.18: Máximo Común Divisor y mínimo común múltiplo entre dos números.</b></h1>
              <h2><b>A) Problema</b></h2>
              <p>Escribir un programa que permita calcular el Máximo Común Divisor (MCD) y el mínimo común múltiplo (mcm) entre dos números enteros. Así, por ejemplo, el MCD entre 1032 y 180 es 12 y el mcm es 15480.</p>
              <h2><b>B) Análisis</b></h2>
              <p>Claramente se puede ver que las entradas del problema son dos números enteros. Hay dos salidas requeridas que son el MCD y el mcm. Se requieren tres datos auxiliares que son: el dividendo de la división, el divisor de la división y el residuo de la división. El proceso manual de cálculo del MCD se basa en el Algoritmo de Euclides donde se utilizan divisiones sucesivas para calcular los restos de las divisiones, donde en cada división resultante, el divisor obtenido pasa a ser el nuevo Dividendo y el Residuo obtenido pasa a ser el nuevo divisor, como se puede ver en la Figura 2.18.1.</p>
              <img src="./assets/images/Capitulos/II/media/Figura 2.18.1.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 2.18.1. </b>Divisiones sucesivas del Algoritmo de Euclides.</h5>
              <p>En la Tabla 2.18.1 se presenta el resumen de los resultados de los cocientes, Dividendos, divisores y Residuos de las divisiones sucesivas realizadas para calcular el MCD entre los números 1032 y 180.</p>
              <h5><b>Tabla 2.18.1. </b>Resumen de resultados del Algoritmo de Euclides.</h5>
            <table border="1" cellspacing="0" cellpadding="5">
              <tr><td>Cociente</td><td width="30"></td><td width="30">5</td><td width="30">1</td><td width="30">2</td><td width="30">1</td><td width="30">3</td><td width="30"></td></tr>
              <tr><td>Dividendos/Divisores</td><td>1032</td><td>180</td><td>132</td><td>48</td><td>36</td><td>12</td><td>0</td></tr>
              <tr><td>Restos</td><td>132</td><td>48</td><td>36</td><td>12</td><td>0</td><td></td><td></td></tr>
            </table>  <br>
            <p>En la solución computacional del MCD se cumple con el Algoritmo de Euclides donde se utiliza un bucle que controla las divisiones sucesivas, donde en cada división resultante, el divisor obtenido pasa a ser el nuevo Dividendo y el Residuo obtenido pasa a ser el nuevo divisor. El requerimiento de los datos y las fórmulas requeridas se muestran a continuación. </p>
            <h3><b>Requerimiento de los Datos</b></h3>
              <p><b>Entradas del Programa</b></p>
              		
		<table>
                  <tr><td width="200"> a </td><td width="200">/* primer número entero  */</td></tr>
                  <tr><td width="200"> b </td><td width="200">/* segundo número entero */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200"> MCD </td><td width="200">/* Máximo Común Divisor  */</td></tr>
                  <tr><td> mcm </td><td>/* mínimo común múltiplo */</td></tr>
                </table><br>
		<p><b>Auxiliares del Problema</b></p>
              <table>
                <tr><td width="200">D</td><td width="200">/* Dividendo de la división */</td></tr>
		<tr><td width="200">d</td><td width="200">/* divisor de la división */</td></tr>
		<tr><td width="200">R</td><td width="200">/* Residuo de la división */</td></tr>
             </table><br>
                <p><b>Fórmulas Relevantes</b></p>
                <table>
                  <tr><td width="120"><em>R=D MOD2 </em></td><td width="30"> (1) </td><td width="280">/* Fórmula que calcula el residuo de una división */</td></tr>
                  <tr><td ><em>mcm = <sup>a∙b</sup> / <sub>MCD</sub></em></td><td> (2) </td><td>/* Fórmula que calcula el mcm entre dos números ‘a’ y ‘b’ utilizando el MCD */</td></tr>
                </table> <br>

                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 2.18.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘a’; la variable ‘b’; b) Salidas: la variable ‘MCD’; la variable ‘mcm’; c) Auxiliares: la variable ‘D’; la variable ‘d’; la variable ‘R’.
</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.18.2.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.18.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                
			<p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el valor del primer número entero.</li>
                  <li>Leer el valor del segundo número entero.</li>
		<li>Asignar a la variable Dividendo el valor del primer número.</li>
		<li>Asignar a la variable divisor el valor del segundo número.</li>                  
		<li>Mientras el divisor sea diferente de cero, hacer:</li>
                  <ol type="1" start="5">
                    <li>1. Calcular el valor del Residuo entre el Dividendo y el divisor.</li>
                  </ol><ol type="1" start="5">
                    <li>2. Asignar a la variable Dividendo el valor del divisor.</li>
                  </ol><ol type="1" start="5">
                    <li>3. Asignar a la variable divisor el valor del Residuo.</li>
                  </ol>
                  <li>Asignar a la variable MCD el valor final del Dividendo.</li>
                  <li>Calcular el valor del mínimo común múltiplo.</li>
                   <li>Imprimir el valor del Máximo Común Divisor (MCD).</li>
                  <li>Imprimir el valor del mínimo común múltiplo (mcm).</li>
                </ol>


                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.18.2 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.18.2. </b>Programa que calcula el MCD y el mcm entre dos números.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_18_2"  [lineNumbers]="true"></code></pre> <br>
                <h2>E) Pruebas</h2>
                <p>En la Tabla 2.18.3, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <p>En la salida de la Tabla 2.18.3 se puede ver que, al ingresar el primer número que es 1032 y al ingresar el segundo número que es 180, se obtiene el valor del MCD que es 12 y el valor del mcm que es 15480.</p>
	            	<h5><b>Tabla 2.18.3.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.18.3.png" style="display:block; margin:auto; "><br>
            		<p>En la Tabla 2.18.4, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada división sucesiva el divisor de una división pasa a ser el nuevo Dividendo de la siguiente división y el Residuo de la división pasa a ser el nuevo divisor de la siguiente división. También, se puede comprobar que el MCD resultante es el valor final del Dividendo calculado y la ejecución de la sentencia while() termina cuando la condición del bucle se hace falsa.</p>
               <h5><b>Tabla 2.18.4. </b>Prueba de escritorio del programa.</h5>
            		<table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                <tr style="color:red"><td>a</td><td>b</td><td>D</td><td>D</td><td>d &lt; 0</td><td>R = D % d</td></tr>
                <tr><td>1032</td><td>180</td><td>1032</td><td>180</td><td>180 &lt; 0 (V)</td><td>132</td></tr>
	            	<tr><td></td><td></td><td>180</td><td>132</td><td>132 &lt; 0 (V)</td><td>48</td></tr>
            		<tr><td></td><td></td><td>132</td><td>48</td><td>48 &lt; 0 (V)</td><td>36</td></tr>
            		<tr><td></td><td></td><td>48</td><td>36</td><td>36 &lt; 0 (V)</td><td>12</td></tr>
                <tr><td></td><td></td><td>36</td><td>12</td><td>12 &lt; 0 (V)</td><td>0</td></tr>
                <tr><td></td><td></td><td>12</td><td>0</td><td style="color:blue">0 &lt;=0 (F)</td><td></td></tr>
                        
               </table> <br>
            </ng-template>
            </mat-tab>
            <mat-tab  label="2.4.2. La sentencia do-while">
              <ng-template matTabContent>
                <br>
                <h1>La sentencia do-while()</h1>
                <p>La sentencia do-while() crea un bucle que se repite hasta que la expresión lógica o condición del bucle se vuelva falsa. El cuerpo del bucle do-while() se ejecutará una o varias veces, pero al menos una vez, dependiendo de la condición del bucle. El formato de esta sentencia tiene la siguiente sintaxis:</p>
                <p><b>Sintaxis 1:</b></p>
                <pre><code align="left">
do
    sentencia;
while(Condición_Bucle);
</code></pre>
                  <table>
                    <tr VALIGN=top><td><code>Condición_Bucle</code></td>
                      <td>Expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva.</td></tr>
                      <tr VALIGN=top><td><code>sentencia</code></td>
                      <td>La sentencia o acción se ejecuta si la expresión lógica es verdadera dentro del bucle.</td></tr>
                  </table>
                  <br>
                  <table border="1" CELLPADDING=5 CELLSPACING=0>
                    <tr VALIGN=top><td width="50"><b> Nota:</b></td><td>  En esta sintaxis no es necesario utilizar llaves ya que se tiene una sola sentencia o instrucción.</td></tr>
                  </table>
                  <br>
                  <p><b>Sintaxis 2:</b></p>
                <pre><code align="left">
do
&#65371;
      sentencia<sub>1</sub>;
      sentencia<sub>2</sub>;
      ...
      sentencia<sub>n</sub>;
&#65373; while(Condición_Bucle);
</code></pre>
                  <table>
                    <tr VALIGN=top><td><code>Condición_Bucle</code></td>
                      <td>Expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva.</td></tr>
                      <tr VALIGN=top><td><code>sentencia</code></td>
                      <td>Las acciones o sentencias se ejecutan si la expresión lógica es verdadera dentro del bucle.</td></tr>
                  </table>
                  <br>
         
                  <h4><b>Ejercicio 2.21: </b>Escribir un programa que permita imprimir de manera ascendente los números del 1 al 10 utilizando un bucle do-while().</h4>
                  <br>
                  <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                    <TR>
                      <th width="10"> <b> N° </b> </th> 
                      <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                      <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                    </TR>
                    <TR> <td>1</td>  <td>entero : i</td>
                      <td>
                        <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                        i;</td>
                    </TR>
                    <TR>
                      <td>2</td>
                      <td>Inicializar el valor del contador en uno</td>
                      <td>i = 1;  </td>
                    </TR>
                    <TR><td>3</td> <td>Hacer:</td> 
                      <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">do </font>
                       &#65371;</td> </TR>
                    <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                      <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                        i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                     <TR><td>5</td><td>Incrementar el valor del contador en uno.</td> <td>i++; </td></TR>
    <TR><td>6</td><td>Mientras la condicion sea verdadera.</td><td>&#65373; 
    <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>(i &gt; 10);</td></TR>
                  </TABLE> <br>
                  <h5><b>Programa 2.21: </b>Código del programa</h5>
                  <pre><code [highlight]="prefTab2[0].programa2_21"  [lineNumbers]="true"></code></pre>
                  <p>En la salida de la Ejecución 2.21 se puede ver la impresión del 1 al 10 de manera creciente.</p>
                  <h5><b>Ejecución 2.21 </b>Salida del programa.</h5>
                  <img src="./assets/images/Capitulos/II/media/Ejecución 2.21.png" style="display:block; margin:auto; "><br>
                  <p>En la Tabla 2.21 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se incrementa en uno, mientras la condición del bucle sea verdadera.</p>
                  <h5><b>Tabla 2.21: </b>Prueba de escritorio del programa.</h5>
                  <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                    <tr style="color:red"><td>i</td><td>i &gt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                    <tr><td>1</td><td>1 &gt;=10 (V)</td><td>1 INTRO</td></tr>
                    <tr><td>2</td><td>2 &gt;=10 (V)</td><td>2 INTRO</td></tr>
                    <tr><td>3</td><td>3 &gt;=10 (V)</td><td>3 INTRO</td></tr>
                    <tr><td>4</td><td>4 &gt;=10 (V)</td><td>4 INTRO</td></tr>
                    <tr><td>5</td><td>5 &gt;=10 (V)</td><td>5 INTRO</td></tr>
                    <tr><td>6</td><td>6 &gt;=10 (V)</td><td>6 INTRO</td></tr>
                    <tr><td>7</td><td>7 &gt;=10 (V)</td><td>7 INTRO</td></tr>
                    <tr><td>8</td><td>8 &gt;=10 (V)</td><td>8 INTRO</td></tr>
                    <tr><td>9</td><td>9 &gt;=10 (V)</td><td>9 INTRO</td></tr>
                    <tr><td>10</td><td>10 &gt;=10 (V)</td><td>10 INTRO</td></tr>
                    <tr><td>11</td><td style="color:rgb(33, 15, 201)">11 &gt;=10 (F)</td><td> </td></tr>
                    
                  </table>
                  <br>
                  <h4><b>Ejercicio 2.22: </b>Escribir un programa que permita imprimir de manera descendente los números del 10 al 1 utilizando un bucle do-while().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en diez</td>
                        <td>i = 10;  </td>
                      </TR>
                      <TR><td>3</td> <td>Hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">do </font>&#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Decrementar el valor del contador en uno.</td><td>i--;</td></TR>
			<TR><td>6</td> <td>Mientras la condición sea verdadera</td> 
			<td>&#65373;<font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &lt;=1); </td> </TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.22: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_22"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.22 se puede ver la impresión del 10 al 1 de manera decreciente.</p>
                    <h5><b>Ejecución 2.22 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.22.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.22 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en uno, mientras la condición del bucle sea verdadera.</p>
                    <h5><b>Tabla 2.22: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &lt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>10</td><td>10 &lt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>9</td><td>9 &lt;=1 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>8</td><td>8 &lt;=1 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>7</td><td>7 &lt;=1 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>6</td><td>6 &lt;=1 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>5</td><td>5 &lt;=1 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>4</td><td>4 &lt;=1 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>3</td><td>3 &lt;=1 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>2</td><td>2 &lt;=1 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>1</td><td>1 &lt;=1 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>0</td><td style="color:rgb(33, 15, 201)">0 &lt;=1 (F)</td><td> </td></tr>
                      
                    </table><br>
                    <h4><b>Ejercicio 2.23: </b>Escribir un programa que permita imprimir de manera ascendente los números pares del 2 al 10 utilizando un bucle do-while().</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR>
                        <td>2</td>
                        <td>Inicializar el valor del contador en dos</td>
                        <td>i = 2;  </td>
                      </TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">do </font>
                          &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Incrementar el valor del contador en dos.</td>
			<td>i=i+2; </td></TR>
			<TR><td>6</td> <td>Mientras la condición sea verdadera</td> 
                        <td>&#65373; <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &gt;=10);</td> </TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.23: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_23"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.23 se puede ver la impresión de los números pares del 2 al 10 de manera creciente.</p>
                    <h5><b>Ejecución 2.23 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.23.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.23 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se incrementa en dos, mientras la condición del bucle sea verdadera.
</p>
                    <h5><b>Tabla 2.23: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &gt;=10</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>2</td><td>2 &gt;=10 (V)</td><td>2 INTRO</td></tr>
                      <tr><td>4</td><td>4 &gt;=10 (V)</td><td>4 INTRO</td></tr>
                      <tr><td>6</td><td>6 &gt;=10 (V)</td><td>6 INTRO</td></tr>
                      <tr><td>8</td><td>8 &gt;=10 (V)</td><td>8 INTRO</td></tr>
                      <tr><td>10</td><td>10 &gt;=10 (V)</td><td>10 INTRO</td></tr>
                      <tr><td>12</td><td>12 &gt;=10 (F)</td><td> </td></tr>                      
                    </table> <br>   
                  <h4><b>Ejercicio 2.24: </b>Escribir un programa que permita imprimir de manera descendente los números impares del 9 al 1 utilizando un bucle do-while().
</h4>
                    <br>
                    <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                      <TR>
                        <th width="10"> <b> N° </b> </th> 
                        <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                        <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                      </TR>
                      <TR> <td>1</td>  <td>entero : i</td>
                        <td>
                          <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                          i;</td>
                      </TR>
                      <TR><td>2</td><td>Inicializar el valor del contador en nueve</td><td>i = 9;  </td></TR>
                      <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                        <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">do </font>
                        &#65371;</td> </TR>
                      <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                        <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                          i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                       <TR><td>5</td><td>Decrementar el valor del contador en dos.</td><td>i=i-2;</td></TR>
			<TR><td>6</td> <td>Mientras la condición sea verdadera.</td> 
                        <td>&#65373; <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                          (i &lt;=1);</td> </TR>
                    </TABLE> <br>
                    <h5><b>Programa 2.24: </b>Código del programa</h5>
                    <pre><code [highlight]="prefTab2[0].programa2_24"  [lineNumbers]="true"></code></pre>
                    <p>En la salida de la Ejecución 2.24 se puede ver la impresión del 9 al 1 de manera decreciente.
</p>
                    <h5><b>Ejecución 2.24 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/II/media/Ejecución 2.24.png" style="display:block; margin:auto; "><br>
 <p>En la Tabla 2.24 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en dos, mientras la condición del bucle sea verdadera.

</p>
                    <h5><b>Tabla 2.24: </b>Prueba de escritorio del programa.</h5>
                    <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                      <tr style="color:red"><td>i</td><td>i &lt;=1</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                      <tr><td>9</td><td>9 &gt;=1 (V)</td><td>9 INTRO</td></tr>
                      <tr><td>7</td><td>7 &gt;=1 (V)</td><td>7 INTRO</td></tr>
                      <tr><td>5</td><td>5 &gt;=1 (V)</td><td>5 INTRO</td></tr>
                      <tr><td>3</td><td>3 &gt;=1 (V)</td><td>3 INTRO</td></tr>
                      <tr><td>1</td><td>1 &gt;=1 (V)</td><td>1 INTRO</td></tr>
                      <tr><td>-1</td><td>-1 &gt;=1 (F)</td><td> </td></tr>                      
                    </table> <br>
                    <h4><b>Ejercicio 2.24: </b>Escribir un programa que permita imprimir de manera descendente los números impares del 9 al 1 utilizando un bucle do-while().
                    </h4>
                    <br>
                                        <TABLE border="1" align="center" cellspacing="0" cellpadding="5">
                                          <TR>
                                            <th width="10"> <b> N° </b> </th> 
                                            <th width="200"> <b> Algoritmo en Pseudocódigo </b> </th>
                                            <th width="210"> <b> Algoritmo en Lenguaje C/C++ </b> </th>
                                          </TR>
                                          <TR> <td>1</td>  <td>entero : i</td>
                                            <td>
                                              <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">int </font>
                                              i;</td>
                                          </TR>
                                          <TR><td>2</td><td>Inicializar el valor del contador en nueve</td><td>i = 9;  </td></TR>
                                          <TR><td>3</td> <td>Mientras la condición sea verdadera, hacer:</td> 
                                            <td><font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">do </font>
                                            &#65371;</td> </TR>
                                          <TR><td>4</td><td>Imprimir el valor del contador. "</td>
                                            <td>cout <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font>
                                              i <font color="green" face="Bookman Old Style, Book Antiqua, Garamond">&gt;&gt;</font> endl;</td></TR>
                                           <TR><td>5</td><td>Decrementar el valor del contador en dos.</td><td>i=i-2;</td></TR>
                          <TR><td>6</td> <td>Mientras la condición sea verdadera.</td> 
                                            <td>&#65373; <font color="blue" face="Bookman Old Style, Book Antiqua, Garamond">while </font>
                                              (i &lt;=1);</td> </TR>
                                        </TABLE> <br>
                                        <h5><b>Programa 2.24: </b>Código del programa</h5>
                                        <pre><code [highlight]="prefTab2[0].programa2_24"  [lineNumbers]="true"></code></pre>
                                        <p>En la salida de la Ejecución 2.24 se puede ver la impresión del 9 al 1 de manera decreciente.
                    </p>
                                        <h5><b>Ejecución 2.24 </b>Salida del programa.</h5>
                                        <img src="./assets/images/Capitulos/II/media/Ejecución 2.24.png" style="display:block; margin:auto; "><br>
                     <p>En la Tabla 2.24 se puede ver la prueba de escritorio del programa, donde se puede ver que en cada iteración del bucle el contador se decrementa en dos, mientras la condición del bucle sea verdadera.
                    
                    </p>
                                        <h5><b>Tabla 2.24: </b>Prueba de escritorio del programa.</h5>
                                        <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                                          <tr style="color:red"><td>i</td><td>i &gt;=1</td><td>cout &gt;&gt; i &gt;&gt; endl;</td></tr>
                                          <tr><td>9</td><td>9 &gt;=1 (V)</td><td>9 INTRO</td></tr>
                                          <tr><td>7</td><td>7 &gt;=1 (V)</td><td>7 INTRO</td></tr>
                                          <tr><td>5</td><td>5 &gt;=1 (V)</td><td>5 INTRO</td></tr>
                                          <tr><td>3</td><td>3 &gt;=1 (V)</td><td>3 INTRO</td></tr>
                                          <tr><td>1</td><td>1 &gt;=1 (V)</td><td>1 INTRO</td></tr>
                                          <tr><td>-1</td><td>-1 &gt;=1 (F)</td><td> </td></tr>                      
                                        </table> <br>
                     <h1><b>Caso de Estudio 2.19: Conversión de Decimal a Binario.</b></h1>
              <h2><b>A) Problema</b></h2>
              <p>Escribir un programa que permita convertir un número en sistema decimal o base 10 a sistema binario o base 2, utilizando divisiones sucesivas. Así, por ejemplo, el número 233 en binario es 11101001.</p>
              <h2><b>B) Análisis</b></h2>
              <p>Claramente se puede ver que la entrada del problema es el número decimal. Hay una sola salida requerida que es el número binario o en base dos. Se requieren cinco datos auxiliares que son: el dividendo de la división, el cociente de la división, el residuo de la división, una sumatoria para acumular valores y un contador para las potencias de 10. El proceso manual de cálculo de conversión de un número decimal a binario se basa en divisiones sucesivas y los restos obtenidos de abajo hacia arriba generan el número binario como se puede ver en la Figura 2.19.1.
</p>
              <img src="./assets/images/Capitulos/II/media/Figura 2.19.1.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 2.19.1. </b>Proceso manual de cálculo de un número binario.</h5>
             
 <p>En la solución computacional del número binario hay un bucle que controla las divisiones sucesivas, que permiten obtener los restos de las divisiones que se acumulan en una sumatoria que acumula los resultados parciales del producto del residuo por 10 elevado a una potencia de ‘n’ y un contador que controla los valores de la potencia de ‘n’. De manera sucesiva el resultado del cociente de una división pasa a ser el dividendo de la siguiente división, asignando a la variable dividendo el valor del cociente en cada iteración del bucle. Finalmente, el valor de la sumatoria obtenida viene a ser el valor del número binario calculado, como se puede ver en la Figura 2.19.2. El requerimiento de los datos y las fórmulas requeridas se muestran a continuación. 
</p>              <img src="./assets/images/Capitulos/II/media/Figura 2.19.2.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 2.19.2. </b>Solución computacional del número binario.</h5>
    
	<h3><b>B.1) Requerimiento de los Datos</b></h3>
              <p><b>Entradas del Programa</b></p>
              		
		<table>
                  <tr><td width="200"> num </td><td width="200">/* número en sistema decimal o base 10  */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200"> bin </td><td width="200">/* número en binario o base 2 */</td></tr>
                </table><br>
		<p><b>Auxiliares del Problema</b></p>
              <table>
                <tr><td width="200">D</td><td width="200">/* Dividendo de la división */</td></tr>
		<tr><td width="200">c</td><td width="200">/* cociente de la división */</td></tr>
		<tr><td width="200">R</td><td width="200">/* Residuo de la división */</td></tr>
<tr><td width="200">sum</td><td width="200">/* sumatoria */</td></tr>
<tr><td width="200">i</td><td width="200">/* contador */</td></tr>
             </table><br>
                <p><b>Fórmulas Relevantes</b></p>
                <table>
		<tr><td ><em>c = <sup>D</sup> / <sub>2</sub></em></td><td> (2) </td><td>/* Fórmula que calcula el cociente de una división */</td></tr>
                <tr><td width="120"><em>R=D MOD2 </em></td><td width="30"> (1) </td><td width="280">/* Fórmula que calcula el residuo de una división */</td></tr>
                  <tr><td ><em>sum = sum + R∙10<sup>n</sup> </em></td><td> (2) </td><td>/* Fórmula que acumula el valor de una sumatoria más el producto entre el residuo por 10 elevado a la potencia de n */</td></tr>
                </table> <br>

                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>
En la Figura 2.19.3 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘num’; b) Salidas: la variable ‘bin’; c) Auxiliares: la variable ‘D’; la variable ‘c’; la variable ‘R’; la variable ‘sum’; la variable ‘i’.

</p>
                <img src="./assets/images/Capitulos/II/media/Figura 2.19.3.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 2.19.3. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                
			<p><b>Algoritmo</b></p>
                <ol type="1">
                  <li>Leer el valor del número decimal.</li>
                  <li>Asignar a la variable Dividendo el valor del número decimal.</li>
		<li>Inicializar la variable sumatoria con el valor de cero.</li>
		<li>Inicializar el contador ‘i’ con el valor de cero.</li>                  
		<li>Hacer:</li>
                  <ol type="1" start="5">
                    <li>1. Calcular el valor del cociente entre el Dividendo y el valor de 2.</li>
                  </ol><ol type="1" start="5">
                    <li>2. Calcular el valor del Residuo entre el Dividendo y el valor de 2.</li>
                  </ol><ol type="1" start="5">
                    <li>3. Asignar a la sumatoria el valor que tiene acumulado más el producto entre el Residuo con el valor de 10 elevado a la potencia de ‘i’.</li>
                  </ol><ol type="1" start="5">
                    <li>4. Asignar a la variable Dividendo el valor del cociente.</li>
                  </ol><ol type="1" start="5">
                    <li>5. Incrementar el valor del contador ‘i’ en uno.</li>
			Mientras el cociente de la división sea diferente de cero.
                  </ol>
                  <li>Asignar a la variable ‘bin’ el valor de la sumatoria que corresponde al número binario calculado.</li>
                  <li>Imprimir el valor del número binario.</li>
                </ol>

                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.19.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 2.19.1. </b>Programa que convierte un número decimal en un número binario.</h5>
                <pre><code [highlight]="prefTab2[0].tabla2_19_1"  [lineNumbers]="true"></code></pre> <br>
                <h2>E) Pruebas</h2>
                <p>En la Tabla 2.19.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <p>En la salida de la Tabla 2.19.2 se puede ver que, al ingresar el número 233 en sistema de numeración decimal, se obtiene el número 11101001 en sistema de numeración binario.</p>
	            	<h5><b>Tabla 2.19.2.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/II/media/Tabla 2.19.2.png" style="display:block; margin:auto; "><br>
            		<p>En la Tabla 2.19.3, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada división sucesiva el cociente de una división pasa a ser el dividendo de la siguiente división. También, se puede comprobar que el resultado de la sumatoria es el número binario calculado y la ejecución de la sentencia do-while() termina cuando la condición del bucle se hace falsa.
</p>
               <h5><b>Tabla 2.19.3. </b>Prueba de escritorio del programa.</h5>
               <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                <tr style="color:red"><td>num</td><td>D</td><td>Sum</td><td>i</td><td>c</td><td>R</td><td>c! = 0</td></tr>
                <tr><td>233</td><td>233</td><td>0</td><td>0</td><td></td><td></td><td></td></tr>
	            	<tr><td></td><td>116</td><td>0+1&#88;10<sup>0</sup>=1</td><td>1</td><td>116</td><td>1</td><td>116 != 0 (V)</td></tr>
            		<tr><td></td><td>58</td><td>1+0&#88;10<sup>1</sup>=1</td><td>2</td><td>58</td><td>0</td><td>58 != 0 (V)</td></tr>
            		<tr><td></td><td>29</td><td>1+0&#88;10<sup>2</sup>=1</td><td>3</td><td>29</td><td>0</td><td>29 != 0 (V)</td></tr>
                <tr><td></td><td>14</td><td>1+1&#88;10<sup>3</sup>=1001</td><td>4</td><td>14</td><td>1</td><td>14 != 0 (V)</td></tr>
                <tr><td></td><td>7</td><td>1001+0&#88;10<sup>4</sup>=1001</td><td>5</td><td>7</td><td>0</td><td>7 != 0 (V)</td></tr>
                <tr><td></td><td>3</td><td>1001+1&#88;10<sup>5</sup>=101001</td><td>6</td><td>3</td><td>1</td><td>3 != 0 (V)</td></tr>
                <tr><td></td><td>1</td><td>101001+1&#88;10<sup>6</sup>=1101001</td><td>7</td><td>1</td><td>1</td><td>1 != 0 (V)</td></tr>
                <tr><td></td><td>0</td><td>1101001+1&#88;10<sup>7</sup>=11101001</td><td>8</td><td>0</td><td>1</td><td style="color:blue">0! = 0 (F)</td></tr>    
               </table> <br>

               <h1><b>Caso de Estudio 2.20: Análisis de Números Palíndromos.</b></h1>
               <h2><b>A) Problema</b></h2>
               <p>Escribir un programa que permita analizar si un número es palíndromo o no lo es. Un número palíndromo es aquel número que invertido o dado la vuelta resulta ser el mismo número. Así, por ejemplo, los números 1234321, 55555, 333, son números palíndromos. Analizar además el número de cifras que tiene el número, visualizar el número original al revés y desplegar un mensaje donde se mencione si el número ingresado por teclado es o no palíndromo.
 
 </p>
               <h2><b>B) Análisis</b></h2>
               <p>Claramente se puede ver que la entrada del problema es un número entero. Hay dos salidas requeridas que son el número de cifras del número y el número original invertido. Se requieren seis datos auxiliares que son: un contador de cifras para el número, el dividendo de la división, el cociente de la división, el residuo de la división, una sumatoria para acumular valores y un contador para las potencias de 10. 
 </p>
     <p>En la solución computacional de análisis de un número palíndromo se plantea primeramente un bucle que cuenta el número de cifras del número entero leído desde el teclado, como se puede ver en la Figura 2.20.1.
 </p>
               <img src="./assets/images/Capitulos/II/media/Figura 2.20.1.png" style="display:block; margin:auto; "><br>
               <h5 style="text-align:center"><b>Figura 2.20.1. </b>Proceso para contar el número de cifras de un número entero.</h5>
              
  <p>Luego, hay un bucle que controla las divisiones sucesivas, que permiten obtener los restos de las divisiones que se acumulan en una sumatoria que acumula los resultados parciales del producto del residuo por 10 elevado a una potencia de ‘n’ y un contador que controla los valores de la potencia de ‘n’. Antes de ingresar a este bucle, el contador se inicializa con el valor del número de cifras menos el valor de uno. De manera sucesiva, el resultado del cociente de una división pasa a ser el dividendo de la siguiente división, asignando a la variable dividendo el valor del cociente en cada iteración del bucle. Finalmente, el valor de la sumatoria obtenida viene a ser el valor del número invertido calculado, como se puede ver en la Figura 2.20.2. El requerimiento de los datos y las fórmulas requeridas se muestran a continuación.
 </p>              <img src="./assets/images/Capitulos/II/media/Figura 2.20.2.png" style="display:block; margin:auto; "><br>
               <h5 style="text-align:center"><b>Figura 2.20.2. </b>Proceso para invertir un número entero.</h5>
     
   <h3><b>B.1) Requerimiento de los Datos</b></h3>
               <p><b>Entradas del Programa</b></p>
                   
     <table>
                   <tr><td width="200"> num </td><td width="200">/* número entero original  */</td></tr>
                 </table><br>
                 <p><b>Salidas del Problema</b></p>
                 <table>
                   <tr><td width="200"> numeroCifras </td><td width="200">/* número de cifras decimales del entero  */</td></tr>
                   <tr><td width="200"> numInvertido </td><td width="200">/* número entero invertido */</td></tr>
                   <tr><td width="200"> Mensaje </td><td width="200">/* que indica que el número ingresado es palíndromo o no es palíndromo */</td></tr>
                 </table><br>
     <p><b>Auxiliares del Problema</b></p>
               <table>
                 <tr><td width="200">cont</td><td width="200">/* contador de cifras decimales de un entero */</td></tr>
     <tr><td width="200">D</td><td width="200">/* Dividendo de la división */</td></tr>
     <tr><td width="200">c</td><td width="200">/* cociente de la división */</td></tr>
     <tr><td width="200">R</td><td width="200">/* Residuo de la división */</td></tr>
     <tr><td width="200">sum</td><td width="200">/* sumatoria */</td></tr>
     <tr><td width="200">i</td><td width="200">/* contador */</td></tr>
              </table><br>
                 <p><b>Fórmulas Relevantes</b></p>
                 <table>
     <tr><td ><em>c = <sup>D</sup> / <sub>10</sub></em></td><td> (2) </td><td>/* Fórmula que calcula el cociente de una división */</td></tr>
                 <tr><td width="120"><em>R=D MOD2 </em></td><td width="30"> (1) </td><td width="280">/* Fórmula que calcula el residuo de una división */</td></tr>
                   <tr><td ><em>sum = sum + R∙10<sup>n</sup> </em></td><td> (2) </td><td>/* Fórmula que acumula el valor de una sumatoria más el producto entre el residuo por 10 elevado a la potencia de n */</td></tr>
                 </table> <br>
 
                 <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                 <p>En la Figura 2.20.3 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘num’; b) Salidas: la variable ‘numeroCifras’; la variable ‘numInvertido’; un mensaje de información que indica que el número ingresado es palíndromo o no es palíndromo; c) Auxiliares: la variable ‘cont’; la variable ‘D’; la variable ‘c’; la variable ‘R’; la variable ‘sum’; la variable ‘i’.
 </p>
                 <img src="./assets/images/Capitulos/II/media/Figura 2.20.3.png" style="display:block; margin:auto; "><br>
                 <h5 style="text-align:center"><b>Figura 2.20.3. </b>Diagrama de Entrada-Salida del Programa.</h5>
                 <h2><b>C) Diseño</b></h2>
                 <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                 
       <p><b>Algoritmo</b></p>
                 <ol type="1">
                   <li>Imprimir el mensaje de información: Analizar si un número es palíndromo.</li>
                   <li>Leer el valor de un número entero.</li>
     <li>Asignar a la variable Dividendo el valor del número entero.</li>
     <li>Inicializar el contador ‘cont’ con el valor de cero.</li>                  
     <li>Hacer:</li>
                   <ol type="1" start="5">
                     <li>1. Calcular el valor del cociente entre el Dividendo y el valor de 10.</li>
                   </ol><ol type="1" start="5">
                     <li>2. Calcular el valor del Residuo entre el Dividendo y el valor de 10.</li>
                   </ol><ol type="1" start="5">
                     <li>3. Asignar a la variable Dividendo el valor del cociente.</li>
                   </ol><ol type="1" start="5">
                     <li>4. Incrementar el valor del contador ‘i’ en uno.</li>
     Mientras el cociente de la división sea diferente de cero.
                   </ol>
                   <li>Asignar a la variable 'numeroCifras' el valor del contador 'cont' que corresponde al valor del número de cifras del número entero ingresado.</li>
     <li>Imprimir el número de cifras del número entero ingresado por teclado.</li>
     <li>Asignar a la variable Dividendo el valor del número entero.</li>
     <li>Inicializar la variable sumatoria con el valor de cero.</li>
     <li>Inicializar el contador 'i' con el valor del número de cifras menos uno.</li>
     <li>Hacer:</li>
                   <ol type="1" start="11">
                     <li>1. Calcular el valor del cociente entre el Dividendo y el valor de 10.</li>
                   </ol><ol type="1" start="11">
                     <li>2. Calcular el valor del Residuo entre el Dividendo y el valor de 10.</li>
                   </ol><ol type="1" start="11">
                     <li>3. 11.3.	Asignar a la sumatoria el valor que tiene acumulado ás el producto entre el Residuo con el valor de 10 elevado a la potencia de ‘i’.</li>
                   </ol><ol type="1" start="11">
                     <li>4. Asignar a la variable Dividendo el valor del cociente.</li>
                   </ol><ol type="1" start="11">
                     <li>5. Decrementar el valor del contador ‘i’ en uno.</li>
      Mientras el cociente de la división sea diferente de cero.
                   </ol>
     <li>Asignar a la variable 'numInvertido' el valor de la sumatoria 'sum' que corresponde al valor del número entero invertido.</li>                  
     <li>Imprimir el número entero invertido.</li>
     <li>Si el valor de la variable 'num' que tiene el valor del número entero original es igual al valor de la variable 'numInvertido' que tiene el valor del número entero invertido.</li>
     <ol type="1" start="14">
                     <li>1. Imprimir el mensaje: El número ingresado es palíndromo.</li>
                   </ol>
     <li>Caso contrario, el valor de la variable 'num' es diferente del valor de la variable 'numInvertido'.</li>
     <ol type="1" start="15">
                     <li>1. Imprimir el mensaje: El número ingresado no es palíndromo.</li>
                   </ol>
                 </ol>
 
                 <h2><b>D) Implementación</b></h2>
                 <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.20.1 se muestra el código del programa en C/C++.</p>
                 <h5><b>Tabla 2.19.1. </b>Programa que analiza si un número leído es palíndromo.</h5>
                 <pre><code [highlight]="prefTab2[0].tabla2_20_1"  [lineNumbers]="true"></code></pre> <br>
                 <h2>E) Pruebas</h2>
                 <p>En la Tabla 2.20.2, se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                 <p>En la salida de la Tabla 2.20.2 se puede ver que, al ingresar el número 55555, el programa indica que este número tiene 5 cifras decimales. Luego, se obtiene el número invertido que en este caso resulta ser el mismo número, y por lo tanto el número ingresado es palíndromo.
 </p>
                 <h5><b>Tabla 2.20.2.</b> Salida del programa</h5>
                 <img src="./assets/images/Capitulos/II/media/Tabla 2.20.2.png" style="display:block; margin:auto; "><br>
                 <p>En la Tabla 2.20.3, se muestra la prueba de escritorio del primer bucle do-while() del programa que cuenta el número de cifras que tiene el número ingresado por el teclado que en este caso es el número 55555 cuyo número de cifras es 5.  
 </p>
                <h5><b>Tabla 2.20.3. </b>Prueba de escritorio del programa del primer bucle do-while() del programa.</h5>
                 <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                 <tr style="color:red"><td>num</td><td>D</td><td>cont</td><td>C</td><td>c!=0</td></tr>
                 <tr><td>55555</td><td>55555</td><td>0</td><td></td><td></td></tr>
                 <tr><td></td><td>5555</td><td>1</td><td>5555</td><td>5555 != 0 (V)</td></tr>
                  <tr><td></td><td>555</td><td>2</td><td>555</td><td>555 != 0 (V)</td></tr>
                  <tr><td></td><td>55</td><td>3</td><td>55</td><td>55 != 0 (V)</td></tr>
                  <tr><td></td><td>5</td><td>4</td><td>5</td><td>5 != 0 (V)</td></tr>
                  <tr><td></td><td>0</td><td>5</td><td>0</td><td style="color:rgb(33, 15, 201)">0!= 0 (F)</td></tr>
                </table> <br>
                <p>En la Tabla 2.20.4, se muestra la prueba de escritorio del segundo bucle do-while() del programa que invierte el número original que es el 55555 y se obtiene nuevamente el mismo número 55555. En cada división sucesiva el cociente de una división pasa a ser el dividendo de la siguiente división. También, se puede comprobar que el resultado de la sumatoria es el número invertido calculado mediante la suma de cada residuo multiplicado por una potencia de diez comenzando con la potencia igual al número de cifras menos uno hasta llegar al valor de cero. Finalmente, la ejecución de la sentencia do-while() termina cuando la condición del bucle se hace falsa. En este caso el número 55555 resulta ser palíndromo.</p>
                <h5><b>Tabla 2.20.4. </b>Prueba de escritorio del programa del segundo bucle do-while() del programa.</h5>
                <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
                <tr style="color:red"><td>num</td><td>D</td><td>Sum</td><td>i</td><td>C</td><td>R</td><td>c!=0</td></tr>
                <tr><td>55555</td><td>55555</td><td>0</td><td>4</td><td></td><td></td><td></td></tr>
                <tr><td></td><td>5555</td><td>0+50&#88;10<sup>4</sup>=50000</td><td>3</td><td>5555</td><td>5</td><td>5555 != 0 (V)</td></tr>
                 <tr><td></td><td>555</td><td>50000+5&#88;10<sup>3</sup>=55000</td><td>2</td><td>555</td><td>5</td><td>555 != 0 (V)</td></tr>
                 <tr><td></td><td>55</td><td>55000+5&#88;10<sup>2</sup>=55500</td><td>1</td><td>55</td><td>5</td><td>55 != 0 (V)</td></tr>
                 <tr><td></td><td>5</td><td>55500+5&#88;10<sup>1</sup>=55550</td><td>0</td><td>5</td><td>5</td><td>5 != 0 (V)</td></tr>
                 <tr><td></td><td>0</td><td>55550+5&#88;10<sup>0</sup>=55555</td><td>-1</td><td>0</td><td></td><td style="color:rgb(33, 15, 201)">0!= 0 (F)</td></tr>
               </table> <br>
               <p>En la Tabla 2.20.5, se muestra otro ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
              <p>En la salida de la Tabla 2.20.5 se puede ver que, al ingresar el número 1234, el programa indica que este número tiene 4 cifras decimales. Luego, se obtiene el número invertido que en este caso no resulta ser el mismo número, y por lo tanto el número ingresado no es palíndromo.</p>
            
            


              
              <h5><b>Tabla 2.20.5.</b> Salida del programa</h5>
              <img src="./assets/images/Capitulos/II/media/Tabla 2.20.5.png" style="display:block; margin:auto; "><br>
             <p>En la Tabla 2.20.6, se muestra la prueba de escritorio del primer bucle do-while() del programa que cuenta el número de cifras que tiene el número ingresado por el teclado que en este caso es el número 1234 cuyo número de cifras es 4.  </p>
             <h5><b>Tabla 2.20.6. </b>Prueba de escritorio del programa del primer bucle do-while() del programa.</h5>
              <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
              <tr style="color:red"><td>num</td><td>D</td><td>cont</td><td>C</td><td>c!=0</td></tr>
              <tr><td>1234</td><td>1234</td><td>0</td><td></td><td></td></tr>
              <tr><td></td><td>123</td><td>1</td><td>123</td><td>123 != 0 (V)</td></tr>
               <tr><td></td><td>12</td><td>2</td><td>12</td><td>12 != 0 (V)</td></tr>
               <tr><td></td><td>1</td><td>3</td><td>1</td><td>1 != 0 (V)</td></tr>
               <tr><td></td><td>0</td><td>4</td><td>0</td><td style="color:rgb(33, 15, 201)">0!= 0 (F)</td></tr>
             </table> <br>
             <p>En la Tabla 2.20.7, se muestra la prueba de escritorio del segundo bucle do-while() del programa que invierte el número original que es el número 1234 y se obtiene el número invertido 4321. En cada división sucesiva el cociente de una división pasa a ser el dividendo de la siguiente división. También, se puede comprobar que el resultado de la sumatoria es el número invertido calculado mediante la suma de cada residuo multiplicado por una potencia de diez comenzando con la potencia igual al número de cifras menos uno hasta llegar al valor de cero. Finalmente, la ejecución de la sentencia do-while() termina cuando la condición del bucle se hace falsa. En este caso el número 1234 resulta no ser palíndromo.</p>
             <h5><b>Tabla 2.20.7. </b>Prueba de escritorio del programa del segundo bucle do-while() del programa.</h5>
             <table frame="void" rules="all" align="center" cellspacing="0" cellpadding="5"> 
             <tr style="color:red"><td>num</td><td>D</td><td>Sum</td><td>i</td><td>C</td><td>R</td><td>c!=0</td></tr>
             <tr><td>1234</td><td>1234</td><td>0</td><td>3</td><td></td><td></td><td></td></tr>
             <tr><td></td><td>123</td><td>0+4&#88;10<sup>3</sup>=4000</td><td>2</td><td>123</td><td>4</td><td>5555 != 0 (V)</td></tr>
              <tr><td></td><td>12</td><td>4000+3&#88;10<sup>2</sup>=4300</td><td>1</td><td>12</td><td>3</td><td>555 != 0 (V)</td></tr>
              <tr><td></td><td>1</td><td>4300+2&#88;10<sup>1</sup>=4320</td><td>0</td><td>1</td><td>2</td><td>55 != 0 (V)</td></tr>
              <tr><td></td><td>0</td><td>4320+1&#88;10<sup>0</sup>=4321</td><td>-1</td><td>0</td><td>1</td><td style="color:rgb(33, 15, 201)">0!= 0 (F)</td></tr>
            </table> <br>
            
            </ng-template>
            </mat-tab>

            <mat-tab  label="2.4.3. La sentencia for">
              <ng-template matTabContent>
                <br><h1>La sentencia for()</h1>
                <p>El bucle for() es el bucle más potente que tiene el lenguaje C/C++, ya que agrupa en un solo lugar tres acciones: a) inicializar uno o varios contadores; b) manejar una expresión lógica y c) incrementar o decrementar el contador o contadores. Este bucle es ideal para implementar bucles controlados por contador que son bucles en los que un conjunto de sentencias se ejecuta una vez por cada valor de un rango especificado, de acuerdo al algoritmo que resuelve un problema. El formato de esta sentencia tiene la siguiente sintaxis:</p>

                <p><b>Sintaxis 1:</b></p>
<pre><code align="left">for(Inicialización; Condición_Bucle; Incremento/Decremento) 
      sentencia;</code></pre>
                    <table>
                      <tr VALIGN=top><td><code>Inicialización</code></td>
                        <td>Sección donde se inicializan las variables de control del bucle.</td></tr>
                        
                      <tr VALIGN=top><td><code>Condición_Bucle</code></td>
                        <td>Sección que contiene una expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva, mientras sea verdadera.</td></tr>
                        <tr VALIGN=top><td><code>Incremento/Decremento</code></td>
                          <td>Sección donde se incrementan o se decrementan las variables de control del bucle.</td></tr>
                      <tr VALIGN=top><td><code>sentencia</code></td>
                        <td>La sentencia o acción se ejecuta si la expresión lógica es verdadera dentro del bucle.</td></tr>
                    </table>
                    <br>
                    <table border="1" CELLPADDING=5 CELLSPACING=0>
                      <tr VALIGN=top><td width="50"><b> Nota:</b></td><td>  En esta sintaxis no es necesario utilizar llaves ya que se tiene una sola sentencia o instrucción.</td></tr>
                    </table>
                    <br>
                    <p><b>Sintaxis 2:</b></p>
                  <pre><code align="left">for(Inicialización; Condición_Bucle; Incremento/Decremento)
&#65371;
        sentencia<sub>1</sub>;
        sentencia<sub>2</sub>;
        ...
        sentencia<sub>n</sub>;
&#65373; 
  </code></pre>
  <table>
    <tr VALIGN=top><td><code>Inicialización</code></td>
      <td>Sección donde se inicializan las variables de control del bucle.</td></tr>
      
    <tr VALIGN=top><td><code>Condición_Bucle</code></td>
      <td>Sección que contiene una expresión lógica o booleana que determina si la sentencia o acción se ha de ejecutar de manera repetitiva, mientras sea verdadera.</td></tr>
      <tr VALIGN=top><td><code>Incremento/Decremento</code></td>
        <td>Sección donde se incrementan o se decrementan las variables de control del bucle.</td></tr>
    <tr VALIGN=top><td><code>sentencias</code></td>
      <td>Las sentencias o acciones se ejecutan si la expresión lógica es verdadera dentro del bucle.</td></tr>
  </table>
  <br>
              </ng-template>
            </mat-tab>

            <mat-tab  label="2.4.4. Bucles anidados">
              <ng-template matTabContent>
               

                    <br>
              </ng-template>
            </mat-tab>
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Resumen">
        <ng-template matTabContent>

        </ng-template>
      </mat-tab>

      <mat-tab label="Ejercicios Propuestos">
        <ng-template matTabContent>

        </ng-template>
      </mat-tab>

      <mat-tab label="Bibliografía">
        <ng-template matTabContent>

        </ng-template>
      </mat-tab>

    </mat-tab-group>
  <button mat-button (click)="selectTabNext()" *ngIf="positionCurrentNext">{{titleNext}} <mat-icon>navigate_next</mat-icon></button>
    <button mat-button (click)="selectTabBefore()" *ngIf="positionCurrentBefore"><mat-icon>navigate_before</mat-icon> Atras  &nbsp; &nbsp; &nbsp;&nbsp;</button>

</div>
<!-- EXAMPLES
<mat-tab label="Pracniques">
  <ng-template matTabContent>
    <mat-tab-group>
      &lt;!&ndash; <mat-tab *ngFor="let tab of asyncTabs | async"> &ndash;&gt;
      <mat-tab *ngFor="let tab of praqnique" label="{{tab.label}}">
        <br>
        <table>
          <tr>
            <td>
              <h2 style="color:green;"><strong>{{tab.tituloN}}</strong></h2>
            </td>
            <td>
              <h2>{{tab.titulo}}</h2>
            </td>
          </tr>
        </table>
        <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
          <TR>
            <TABLE>
              <TR><strong>SINOPSIS</strong></TR>
              <TR>{{tab.sinopsisDescrip}}</TR>
            </TABLE>
          </TR>
          <TR>
            <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
              <TR *ngFor="let item of tab.sinopsis">
                <TD><strong>{{item.titulo}}</strong>{{item.descrip}}</TD>
              </TR>
            </TABLE>
          </TR>
        </TABLE><br>
        <a href="{{tab.link}}" download="ProgramaPracnique">
          <mat-icon>save_alt</mat-icon><strong>Descargar {{tab.tituloN}} PracniqueCompGraf.zip</strong>
        </a>
        <br><br>
        <h3><strong>{{tab.A.subtitulo}}</strong></h3>
        <p>{{tab.A.problema}}</p>
        <img src="{{tab.A.fotoPath}}" style="display:block; margin:auto;"><br>
        <h5><strong>{{tab.A.fotoN}}</strong>{{tab.A.fotoDescrip}}</h5><br>
        <p>{{tab.A.problema1}}</p>
        <ul *ngFor="let x of tab.A.problemalist">
          <div>{{x}}</div>
        </ul>
        <h3><strong>{{tab.B.subtitulo}}</strong></h3>
        <div *ngFor="let itemPasos of tab.B.pasosB">
          <h3><strong>{{itemPasos.subtitulo2}}</strong></h3>
          <p><strong>{{itemPasos.tituloproblema}}</strong></p>
          <p>{{itemPasos.parrafo}}</p>
          <img src="{{itemPasos.fotoPath}}" style="display:block; margin:auto; ">
          <p>{{itemPasos.parrafo2}}</p>
          <p>{{itemPasos.parrafo3}}</p>
          <p><strong>{{itemPasos.titulosolucion}}</strong></p>
          <div *ngFor="let item of itemPasos.solucion">
            <mathjax [content]=item.parrafo class='box'></mathjax>
            <img src="{{item.fotoPath}}" style="display:block; margin:auto; ">
          </div>
        </div>
        <h3><strong>{{tab.C.subtitulo}}</strong></h3>
        <dl *ngFor="let itemAlgoritmos of tab.C.algoritmosC">
          <dt>{{itemAlgoritmos.titulo}}</dt>
          <dd>
            <ul *ngFor="let p of itemAlgoritmos.pasos; index as i">
              <div value="{{i+1}}">{{p}}</div>
            </ul>
            <ul *ngFor="let p of itemAlgoritmos.pasosFormulas; index as i">
              <div value="{{i+1}}">{{p}}</div>
            </ul>
          </dd>
        </dl>
        <h3><strong>{{tab.D.subtitulo}}</strong></h3>
        <div *ngFor="let itemCodigos of tab.D.listaCodigo">
          <p>{{itemCodigos.problema}}</p>
          <h5><strong>{{itemCodigos.tablaN}}</strong>{{itemCodigos.tablaDescrip}}</h5><br>
          <pre><code [highlight]="itemCodigos.tablaDatos" (highlighted)="onHighlight($event)" [lineNumbers]="true"></code></pre><br>
        </div>
        <h3><strong>{{tab.E.subtitulo}}</strong></h3>
        <div *ngFor="let item of tab.E.listaPrueba">
          <p>{{item.problema}}</p>
          <img src="{{item.fotoPath}}" style="display:block; margin:auto; width: 75%;"><br>
          <h5><strong>{{item.fotoN}}</strong>{{item.fotoDescrip}}</h5><br>
        </div>
      </mat-tab>
    </mat-tab-group>
  </ng-template>
</mat-tab>
<mat-tab label="Pracniques Propuestos">
  <ng-template matTabContent>
    <mat-tab-group>
      &lt;!&ndash; <mat-tab *ngFor="let tab of asyncTabs | async"> &ndash;&gt;
      <mat-tab *ngFor="let tab of praqniquePropuesto" label="{{tab.label}}">
        <br>
        <table>
          <tr>
            <td>
              <h2 style="color:green;"><strong>{{tab.tituloN}}</strong></h2>
            </td>
            <td>
              <h2>{{tab.titulo}}</h2>
            </td>
          </tr>
        </table>
        <h3><strong>{{tab.subtitulo}}</strong></h3>
        <div *ngFor="let item of tab.listaGeneral">
          <div *ngFor="let i of item.listaParrafoFotos">
            <mathjax [content]=i.problema class='box'></mathjax><br>
            <img src="{{i.fotoPath}}" style="display:block; margin:auto; width: 50%;"><br>
            <h5><strong>{{i.fotoN}}</strong>{{i.fotoDescrip}}</h5><br>
          </div>
          <div *ngFor="let i of item.listaParrafos">
            <mathjax [content]=i.problema class='box'></mathjax><br>
          </div>
          <div *ngFor="let i of item.listaFotos">
            <img src="{{i.fotoPath}}" style="display:block; margin:auto; width: 50%;"><br>
            <h5><strong>{{i.fotoN}}</strong>{{i.fotoDescrip}}</h5><br>
          </div>
        </div>
        <a href="{{tab.linkAnexo}}" download="Anexo">
          <mat-icon>{{tab.iconodescarga}}</mat-icon><strong>{{tab.tituloAnexo}}</strong>
        </a>
      </mat-tab>
    </mat-tab-group>
  </ng-template>
</mat-tab>
<mat-tab label="Evaluación">
  <ng-template matTabContent>
    <div class="Evaluacion">
      <app-quiz [propagarNumCapitulo]="num_capitulo"></app-quiz>
    </div>
  </ng-template>
</mat-tab>
<mat-tab label="Juegos">
  <ng-template matTabContent>
    <div class="Snake">
      <app-snake></app-snake>
    </div>
  </ng-template>

</mat-tab>
<mat-tab label="Resumen">
  <ng-template matTabContent>
    <br>
    <h1>Resumen</h1>
    <ul>
      <li>La forma más conveniente de especificar un segmento de línea en la pantalla de una computadora es proporcionan.</li>
      <li>El componente o subsistema GDI (Graphics Device Interface) trabaja junto con el núcleo y la API de Windows do las coordenadas de sus dos puntos finales.</li>
      <li>Un punto es el objeto geométrico más simple y elemental, que permite representar líneas, planos, vectores y todo tipo de figuras geométricas complejas en 2D y 3D como curvas, superficies y sólidos.</li>
      <li>La estructura Point (Point Struct), representa un par ordenado de coordenadas x e y enteras que define un punto en un plano bidimensional.</li>
      <li>La estructura PointF (PointF Struct), representa un par ordenado de coordenadas x e y de punto flotante que define un punto en un plano bidimensional.</li>
      <li>Cuando se necesita trabajar con varios puntos para graficar una Figura Geométrica como un polígono o una curva se puede utilizar un arreglo de puntos.</li>
      <li>Un punto se puede mover desde una localidad a otra de dos maneras: a) Primero, se puede trasladar un punto desde su posición actual a una nueva; b) Segundo, se puede rotar ese punto con respecto a otro en el plano o en los ejes dentro de un espacio a una nueva posición.</li>
      <li>El rectángulo (Rectangle) es una estructura (struct) que almacena un conjunto de cuatro enteros que representan la localización y el tamaño de un rectángulo en un lienzo o canvas.</li>
      <li>Un vector es un ente matemático que tiene módulo (magnitud), dirección y sentido.</li>
      <li>Se pueden graficar las líneas y puntos notables de un triángulo utilizando Geometría Aplicada y utilizando las ecuaciones de traslación de un punto a otro en el mundo de la Computación Gráfica.</li>
      <li>Un vector 2D tiene dos componentes en el plano (x,y) que se lo puede representar gráficamente utilizando líneas con puntos y con flechas, aplicando Geometría Aplicada y utilizando las ecuaciones de traslación de un punto a otro en el mundo de la Computación Gráfica.</li>
      <li>Un vector 3D tiene tres componentes en el plano (x,y,z) que se lo puede representar gráficamente utilizando líneas con puntos y con flechas, aplicando Geometría Aplicada y utilizando las ecuaciones de traslación de un punto a otro en el mundo de la Computación Gráfica.</li>
    </ul>
  </ng-template>
</mat-tab>
<mat-tab label="Bibliografía">
  <ng-template matTabContent>
    <br>
    <h1>Bibliografía</h1>
    <ul>
      <li>Ammeraal, L., Zhang, K., 2017. Computer Graphics for Java Programmers. Springer. Third Edition.</li>
      <li>Lengyel, E., 2011. Mathematics for 3D Game Programming and Computer Graphics. Charles River Media. Third Edition.</li>
      <li>Steeb, W.H., Hardy, A., 2008. Mathematical Tools in Computer Graphics with C# Implementations. World Scientific Pub. Co. Inc. First Edition.</li>
      <li>Spiegel, M., Lipschutz, S., Spellman, D., 2011. Análisis Vectorial. 2° edición. SCHAUM, McGraw-Hill, Interamericana Editores, S.A., México. ISBN: 978-607-15-0550-7.</li>
      <li>Kimberling, C., 1994. Encyclopedia of Triangle Centers. Evansville University. Disponible en: https://faculty.evansville.edu/ck6/encyclopedia/ETC.html</li>
      <li>Beer, F., Jhonston, E.R., Mazurek, D., Eisenberg, E., 2010. Mecánica Vectorial para Ingenieros. Estática. Novena Edición. McGraw-Hill/Interamericana Editores, S.A., México. ISBN: 978-607-15-0277-3.</li>
    </ul>
  </ng-template>
</mat-tab>-->
