<div style="margin: 50px;">
    <ng-container *ngIf="(asyncTabs | async) === null">
        Loading tabs...
    </ng-container>
    <table>
        <tr>
            <td>
                <h1><b> CAPÍTULO 3: FUNCIONES, REFERENCIAS Y PUNTEROS</b></h1>
            </td>
            <td></td>
            <td>
                <a href="https://drive.google.com/uc?id=1PnpCw4kNw5BSiBiLZegfyEU4fMXhjpjJ&export=download" download="Capitulo12021">
                    <mat-icon>cloud_download</mat-icon>Descargar Archivo Capítulo III
                </a>
            </td>
        </tr>
    </table>

    <mat-tab-group [selectedIndex]="selectedIndex.value" (selectedIndexChange)="selectedIndex.setValue($event)">
        <mat-tab label="Introducción">
            <ng-template matTabContent>
              <br><h1>Introducción</h1>
              <p>En este capítulo se aprenderá a diseñar funciones con algoritmos y a utilizar la computadora como una herramienta para resolver problemas creando programas con funciones, referencias y punteros en el lenguaje C/C++. Para la solución de problemas de programación se aplican aspectos de Ingeniería de Software y el método científico que permiten identificar a la programación con un enfoque sistemático. </p>
            <p>En un programa estructurado el flujo lógico se puede optimizar con el uso de funciones, referencias y punteros que es parte de la programación modular. El estudio de las funciones se realiza en base al paso de parámetros por valor, por referencia y por dirección. La aplicación de funciones para crear programas se lo hace con un lenguaje estructurado y modular como es el Lenguaje C/C++.</p>   
            </ng-template>
        </mat-tab>

        <mat-tab label="Objetivos">
            <ng-template matTabContent>
              <br><h1>Objetivos</h1>
              <ul>
                <li>Revisar los principales conceptos en torno a funciones con algoritmos y con estructuras de control.</li>
                <li>Entender cómo trabajan las funciones, las referencias, los punteros y cómo se aplican con el lenguaje C/C++ en la construcción de programas.</li>
                <li>Aprender a manejar el paso de parámetros por valor, por referencia y por dirección con algoritmos en Pseudocódigo y en Lenguaje C/C++.</li>
                <li>Diseñar y crear programas en lenguaje C/C++ utilizando funciones, referencias y punteros.</li>
                <li>Resolver casos de estudio con funciones, referencias y punteros aplicados al área matemática</li>
              </ul>
            </ng-template>
        </mat-tab>
      <mat-tab label="Función">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="Introducción">
              <ng-template matTabContent>
                <br><h1>Función</h1>
                <p>Una función es un mini programa dentro de un programa. Las funciones contienen varias sentencias bajo un solo nombre, que un programa puede utilizar una o más veces para ejecutar dichas sentencias (Granizo, E., 2016). Una función es una unidad de código diseñada para ejecutar una cierta tarea. Una función típica recibe algo de información y retorna algo de información. El concepto de una función es algo similar a una función matemática. Considere el caso de la función <i>sen(x)</i>, la cual toma un parámetro ‘x’ y evalúa o retorna algún valor, esto es el seno de ‘x’.</p>
                <p>La utilidad de las funciones puede ser fácilmente demostrada si consideramos un programa sin el uso de ellas, como el siguiente:</p>
                <h4><b>Ejercicio 3.1: </b>Escribir un programa sin utilizar funciones que calcule el área de un rectángulo para los siguientes valores de ancho y largo: a) ancho: 7; largo: 2; b) ancho: 9; largo: 5; c) ancho: 8; largo: 4; ingresados desde el teclado en forma seguida, es decir, uno a continuación de otro.</h4>
                <h5><b>Programa 3.1: </b>Programa sin funciones.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_1"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.1 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.1.png" style="display:block; margin:auto; "><br>
                    
               </ng-template>
            </mat-tab>
            <mat-tab  label="3.1.1.   Estructura de una Función">
              <ng-template matTabContent>
                <br><h1>Estructura de una Función</h1>
                <p>De acuerdo con (Joyanes Aguilar, L., Zahonero Martínez, I., 2005), para definir o crear una función en C/C++ se deben considerar los siguientes puntos:</p>
                <ol type="A">
                  <li><b><i>Tipo de retorno: </i></b>Es el tipo de valor devuelto por la función (el valor que la función evalúa) o la palabra reservada <b>“void”</b> si la función no devuelve ningún valor.</li>
                  <li><b><i>Nombre: </i></b>Es el identificador al cual hace referencia la función</li>
                  <li><b><i>Lista de parámetros: </i></b>Son los valores que se toman como entrada. Esta lista de declaraciones de los parámetros de la función van separadas por comas.</li>
                  <li><b><i>Cuerpo: </i></b>Es el código que se ejecuta cuando la función es invocada y puede consistir de variables locales, sentencias ejecutables y la palabra reservada “return” acompañada por una expresión lógica, relacional o matemática, siempre y cuando tenga un tipo de retorno la función.</li>
                </ol>
                <p>La Figura 3.1 muestra dos ejemplos referentes a la estructura de una función.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.1.jpg" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 3.1. </b>Estructura de una función; a) Función Potencia(); b) Función FarenheitACelcius().</h5>
              </ng-template>
            </mat-tab>

            <mat-tab  label="3.1.2.   Implementación de una Función">
              <ng-template matTabContent>
                <br><h1>Implementación de una Función</h1>
                <p>De acuerdo con (Granizo, E., 2016), la siguiente sintaxis despliega la forma de la definición o implementación de una función:</p>
             <p><b>sintaxis:</b></p><pre><code>
  Tipo_de_retorno Nombre_Función(Lista_de_Parámetros)
  &#65115;
        // Cuerpo de la función
        // Variables locales
        // Sentencias ejecutables
        // return(expresión)
  &#65116;  
</code></pre>
<p>La Figura 3.2 muestra un ejemplo de la sintaxis de cómo trabaja una función, cuando se la ha definido:</p>
<img src="./assets/images/Capitulos/III/media/Figura 3.2.png" style="display:block; margin:auto; "><br>
<h5 style="text-align:center"><b>Figura 3.2. </b>Definición de una función.</h5>
            
<h4><b>Ejercicio 3.2: </b>Escribir un programa utilizando la definición de una función, de tal manera que se calcule el área de un rectángulo para los siguientes valores de ancho y largo: a) ancho: 7; largo: 2; b) ancho: 9; largo: 5; c) ancho: 8; largo: 4; ingresados desde el teclado en forma seguida, es decir, uno a continuación de otro.</h4>
                <h5><b>Programa 3.2: </b>Programa sin funciones.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_2"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.2 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.2.png" style="display:block; margin:auto; "><br>
                   


</ng-template>
            </mat-tab>

            <mat-tab  label="3.1.3.   Problemas que Resuelven las Funciones">
              <ng-template matTabContent>
<br><h1>Problemas que Resuelven las Funciones</h1>
                <p>De acuerdo con (Deitel, H., Deitel, P., 2003), los problemas más importantes que resuelven las funciones son:</p>
                <ol type="A">
                  <li><b><i>Duplicación de código: </i></b>Al utilizar funciones ya no es necesario volver a escribir tanto código de nuevo, como en el ejercicio 3.2 a diferencia del ejercicio 3.1 que necesita mucho más código.</li>
                  <li><b><i>Reutilización del código: </i></b>Las funciones permiten utilizar una y otra vez y las veces que se requiera una función solo invocándola o llamándola desde cualquier parte de un programa.</li>
                  <li><b><i>Mantención del código: </i></b>El uso de funciones permite dar mantenimiento y actualizar el código de un programa más fácilmente.</li>
                </ol>
              </ng-template>
            </mat-tab>

            <mat-tab  label="3.1.4.   Uso de Funciones">
              <ng-template matTabContent>
                <br><h1>Uso de Funciones</h1>
                <p>De acuerdo con (Luna, F., 2004), para utilizar adecuadamente las funciones dentro de los programas se deben considerar las siguientes observaciones:</p>
              <ol type="A">
                <li>Una función debe ser declarada o definida antes de ser llamada o invocada, para que el compilador pueda reconocerla en la llamada a ésta.</li>
                <li>La declaración de una función (conocida también como el prototipo de la función) consiste del tipo de retorno, el nombre de la función y la lista de parámetros terminando la sentencia con un punto y coma.</li>
                <li>Una vez que una función ha sido declarada, puede ser definida o implementada en cualquier parte del programa. La definición de la función de la función contiene el cuerpo de la función y consiste del código que especifica lo que actualmente hace la función.</li>
                <li>Una función puede ser definida sin necesidad de ser declarada, antes del programa principal o antes de la llamada a la misma.</li>
                
              </ol>
              
              <br><h4><b>Ejercicio 3.3: </b>Escribir un programa utilizando la declaración y la definición de una función, de tal manera que se calcule el área de un rectángulo para los siguientes valores de ancho y largo: a) ancho: 7; largo: 2; b) ancho: 9; largo: 5; c) ancho: 8; largo: 4; ingresados desde el teclado en forma seguida, es decir, uno a continuación de otro.</h4>
              <h5><b>Programa 3.3: </b>Programa con funciones, utilizando la declaración y la definición de una función.</h5>
                  <pre><code [highlight]="prefTabs3[0].programa3_3"  [lineNumbers]="true"></code></pre>
                 <br> <h5><b>Ejecución 3.3 </b>Salida del programa.</h5>
                  <img src="./assets/images/Capitulos/III/media/Ejecucion 3.3.png" style="display:block; margin:auto; "><br>
            </ng-template>
            </mat-tab>

          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Paso de Parámetros por Valor">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="Introducción">
              <ng-template matTabContent>
                <br><h1>Paso de Parámetros por Valor</h1>
                <p>El paso de parámetros por valor o por copia, significa que cuando el compilador de C/C++ compila la función y el código que invoca o llama a la función, ésta recibe una copia de los valores de los parámetros. Si dentro de la función se cambia el valor de un parámetro que viene a ser una variable local de la misma, el cambio sólo afecta a la función y no tiene efecto fuera de ella (Granizo, E., 2016). </p>
                <p>Con el paso de parámetros por valor sólo se pueden operar con los parámetros de la función mas no modificar los contenidos de las variables que se envían a la función que son los argumentos que se copian o se asignan a los parámetros de la función.</p>
                <p>Un parámetro no es un valor por sí mismo, más bien es un valor propietario de un lugar para una variable. Esto significa que cuando la función es invocada o llamada en algún lugar del programa se envía una variable que toma el nombre del argumento que es el valor pasado dentro de la llamada de una función en particular y el parámetro de la función recibe una copia de la variable original que se envía como argumento a la misma.</p>
              </ng-template>
            </mat-tab>
            <mat-tab  label="3.2.1. Funciones sin Parámetros">
              <ng-template matTabContent>
                <br><h1>Funciones sin Parámetros</h1>
                <p>Las funciones pueden no tener parámetros, lo que significa que solamente pueden ejecutar ciertas tareas y dependiendo del tipo de retorno, devolver un valor o retornar un ‘void’ si la función no devuelve ningún valor (Luna, F., 2004).</p>
                <p>La función <font face="Consolas"><b>CalcularAreaRectangulo()</b></font> del programa 3.3, 
                  es un ejemplo del uso de funciones sin parámetros, donde esta función lee el valor del ancho y del largo del rectángulo, calcula el valor del área del rectángulo y retorna el valor del cálculo del área del rectángulo, como se puede ver en la Figura 3.3.</p>
                  <pre><code [highlight]="prefTabs3[0].Figura3_3"  [lineNumbers]="true"></code></pre>
                  <h5 style="text-align:center"><b>Figura 3.3. </b>Ejemplo de una función sin parámetros</h5>
 
                </ng-template>
            </mat-tab>
            <mat-tab  label="3.2.2. Funciones con un Parámetro">
              <ng-template matTabContent>
                <br><h1>Funciones con un Parámetro</h1>
                <p>Las funciones pueden tener un parámetro, donde el valor que se envía a la función se conoce como argumento, donde la función recibe una copia de la variable original, la cual solo puede ser utilizada, mas no modificada (Luna, F., 2004). En el programa 3.4, se muestra un ejemplo del manejo de funciones con un parámetro.</p>
                <h4><b>Ejercicio 3.4: </b>Escribir un programa utilizando funciones que calcule el cubo de tres números, ingresados desde el teclado en forma seguida, utilizando la declaración y la definición de una función.</h4>
                <h5><b>Programa 3.4: </b>Función con un parámetro, que calcula el cubo de tres números.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_2"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.4: </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.4.png" style="display:block; margin:auto; "><br>
  <p>La Figura 3.4 muestra un ejemplo de cómo trabaja la 
    función <font face="Consolas">QuintaPotenciaDeUnNumero()</font>, luego de ser declarada y definida.
     La llamada a la función <font face="Consolas">QuintaPotenciaDeUnNumero()</font> envía un argumento a un parámetro de la función, la misma que hace el cálculo de la quinta potencia de un número y retorna ese valor calculado a la llamada de la función. Se puede pensar que una función es una máquina separada donde se alimenta de datos de entrada (se copian los argumentos dentro de los parámetros), 
    luego hace algo con esos parámetros (cuerpo de la función) y a la salida se obtiene un resultado (retorna algo a la llamada de la función). Las funciones permiten a los programas organizar el código en partes más manejables, donde cada parte ejecuta una tarea específica.</p>
    <img src="./assets/images/Capitulos/III/media/Figura 3.4.png" style="display:block; margin:auto; "><br>       
    <h5 style="text-align:center"><b>Figura 3.4. </b>Llamadas a las funciones con parámetros y retorno de resultados.</h5>
 
              </ng-template>
            </mat-tab>

            <mat-tab  label="3.2.3. Funciones con Varios Parámetros">
              <ng-template matTabContent>
                <br><h1>Funciones con Varios Parámetros</h1>
                <p>Las funciones pueden tener varios parámetros, ya que no están limitadas a tener cero parámetros o un solo parámetro (Luna, F., 2004). En el programa 3.5, se muestra un ejemplo del manejo de funciones con varios parámetros. </p>
                <h4><b>Ejercicio 3.5: </b>Escribir un programa utilizando funciones que lea e imprima los valores de tres vectores en el espacio, donde cada vector se compone de tres componentes (x, y, z).</h4>
                <h5><b>Programa 3.2: </b>Función con varios parámetros.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_5"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.5 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.5.png" style="display:block; margin:auto; "><br>            
              </ng-template>
            </mat-tab>

            <mat-tab  label="3.2.4. Funciones de la Librería de Números Aleatorios">
              <ng-template matTabContent>
                <br><h1>Funciones de la Librería de Números Aleatorios</h1>
                <p>La Librería de Utilidades Generales Estándar (C Standard General Utilities Library) del lenguaje C/C++ (<font color="blue">#include </font> <font color="Red">&lt;cstdlib&gt;</font>), proporciona una función llamada <font face="Consolas"><b>rand()</b></font>, que puede ser utilizada para generar números pseudo-aleatorios (pseudorandom). Esta función retorna un número entero aleatorio dentro de un rango [0, MAX_RANGO], donde MAX_RANGO es algún valor predefinido por el programador, como por ejemplo un valor constante (Dawson, M., 2008). </p>
                <p>Para generar números aleatorios diferentes cada vez que se ejecuta un programa se utiliza de manera conjunta la función <font face="Consolas"><b>time()</b></font> con la función <font face="Consolas"><b>srand()</b></font>, donde el valor retornado por la función <font face="Consolas"><b>time()</b></font> se pasa como parámetro a la función <font face="Consolas"><b>srand()</b></font>, de la siguiente manera:</p>
<pre><code>
  srand(time(0));
</code></pre>
                <p>La función <font face="Consolas"><b>time()</b></font> pertenece a la Librería de Tiempo (C Time Library) del lenguaje C/C++ (<font color="blue">#include </font> <font color="Red">&lt;ctime&gt;</font>). Esta función retorna la cantidad de segundos transcurridos desde la medianoche, acorde al sistema del reloj (Stroustrup, B., 1997).</p>
                <p>La función <font face="Consolas"><b>srand()</b></font>pertenece a la Librería de Utilidades Generales Estándar (C Standard General Utilities Library) del lenguaje C/C++ (<font color="blue">#include </font> <font color="Red">&lt;cstdlib&gt;</font>). Esta función se utiliza como punto de entrada para generar números aleatorios conocida como la semilla generadora de números pseudo-aleatorios. A esta función se la debe llamar solamente una vez en el programa (Stroustrup, B., 1997).</p>
                <h4><b>Ejercicio 3.6: </b>Considerando que la resolución mínima de la pantalla del computador para el sistema operativo Windows 7, Windows 8, Windows 8.1 y Windows 10 es 1024 x 768 píxeles; escribir un programa que primeramente imprima los datos iniciales de la posición del ratón (mouse) en la coordenada (0, 0) y luego imprima la posición del ratón (mouse) de manera aleatoria en alguna parte de la pantalla del computador. Los prototipos de las funciones que se deben implementar son:</h4>
                <table><tr><td><p><font face="Consolas" color="blue">void </font><font face="Consolas" color="black">ImprimirDatosInicialesRaton</font>(<font face="Consolas" color="blue">int </font>x, <font face="Consolas" color="blue">int </font> y);</p>
                  <p><font face="Consolas" color="blue">int </font><font face="Consolas" color="black">ObtenerPosicionXRaton</font>();</p>
                  <p><font face="Consolas"color="blue">int </font><font face="Consolas" color="black">ObtenerPosicionYRaton</font>();</p>
                  <p><font face="Consolas" color="blue">void </font><font face="Consolas" color="black">ImprimirPosicionRaton</font>(<font face="Consolas" color="blue">int </font>x, <font face="Consolas" color="blue">int </font> y);</p>
                </td></tr></table>
                <h5><b>Programa 3.6: </b>Función con varios parámetros.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_6"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.6 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.6.png" style="display:block; margin:auto; "><br>            
             <br><h1>3.2.4.1. Especificación del Rango de un Número Aleatorio</h1>
                <p>Generalmente, se utilizan números aleatorios generados dentro del rango [0, MAX_RANGO], pero hay ocasiones en las que el programador necesita generar un rango diferente, como por ejemplo el rango [3, 18]. Para este tipo de casos, se puede generalizar la obtención de un número aleatorio dentro del rango [a, b], donde el valor de ‘a’ representa al límite inferior del rango y el valor de ‘b’ representa al límite superior del rango, utilizando la siguiente fórmula propuesta por (Luna, F., 2004):</p>
                <table align="right">
                  <td width="350"><font face="Consolas">valor = a + rand() % ((b + 1) - a);</font></td>
                <td align="right" width="200">Ec. 3.1.</td>
                </table><br>    
              <p>Así por ejemplo, si se quiere obtener números aleatorios dentro del rango [3, 18], se reemplazan dichos valores en la Ec. 3.1 y se obtiene la siguiente expresión:</p>
            <p style="text-align:center"><font face="Consolas">valor = 3+rand() % ((18+1)-3 );</font></p>  
            <p style="text-align:center"><font face="Consolas">valor = 3+rand() % 16;</font></p>  
            
            <h4><b>Ejercicio 3.7: </b>Escribir un programa que genere 10 números aleatorios dentro del rango [5, 20]. El prototipo de la función que se debe implementar es:</h4>
            <p><font face="Consolas" color="blue">void </font><font face="Consolas">ImprimirDatosAleatorios();</font></p>
            <p>Para resolver este ejercicio se aplica la Ec. 3.2.1, para calcular el valor del rango:</p>
            <p style="text-align:center"><font face="Consolas">valor = 5+rand() % ((20+1)-5 );</font></p>  
            <p style="text-align:center"><font face="Consolas">valor = 5+rand() % 17;</font></p>  
            <h5><b>Programa 3.7: </b>Función con varios parámetros.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_7"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.7 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.7.png" style="display:block; margin:auto; "><br>
  

          </ng-template>
            </mat-tab>
           
            <mat-tab  label="3.2.5. Sobrecarga de Funciones">
              <ng-template matTabContent>
                <br><h1>Sobrecarga de Funciones</h1>
                <p>Algunas veces se requiere dos o más versiones de una misma función (Ceballos, F.J., 2007). Por ejemplo, supongamos que se requieren dos funciones que calculen el área de un rectángulo: a) La primera función CalcularAreaRectangulo(), no tiene parámetros, lee los datos del rectángulo y calcula el valor del área; b) La segunda función CalcularAreaRectangulo(), tiene dos parámetros, calcula el valor del área y retorna ese valor calculado, como se indican en los siguientes prototipos de las funciones sobrecargadas:</p>
                <p><font face="Consolas" color="blue">float </font><font face="Consolas">CalcularAreaRectangulo();</font></p>
                <p><font face="Consolas" color="blue">float </font><font face="Consolas">CalcularAreaRectangulo(</font><font face="Consolas" color="blue">float </font><font face="Consolas">ancho, </font><font face="Consolas" color="blue">float </font><font face="Consolas">largo);</font></p>
                <p>Ambas versiones, para el compilador son correctas y solo difieren en la <b><i>firma de la función</i></b>. La firma de la función incluye el nombre de la función y la lista de parámetros, pero no incluye el tipo de retorno.</p>
             <p>La Tabla 3.1 muestra la implementación de la función de la primera versión y la Tabla 3.2 muestra la implementación de la función de la segunda versión.</p>
             <h5><b>Tabla 3.1: </b>Primera versión de la función Area().</h5>
                    <pre><code [highlight]="prefTabs3[0].tabla3_1"  [lineNumbers]="true"></code></pre>
            <h5><b>Tabla 3.2: </b>Segunda versión de la función Area(Lista_Parámetros).</h5>
                  <pre><code [highlight]="prefTabs3[0].tabla3_2"  [lineNumbers]="true"></code></pre>
            <br>
                  <h4><b>Ejercicio 3.8: </b>Re-escribir el programa del ejercicio 3.3 utilizando sobrecarga de funciones. En el primer y segundo cálculo del área del rectángulo utilizar la primera versión de la función sobrecargada y para el tercer cálculo utilizar la segunda versión de la función sobrecargada. Además, implementar la función ImprimirDatos (Lista_Parámetros), que imprime el valor del área calculada, cuyo prototipo de la función es:</h4>
            <p><font face="Consolas" color="blue">void </font><font face="Consolas">ImprimirDatos(</font><font face="Consolas" color="blue">float </font><font face="Consolas">area); </font></p>
                
            <h5><b>Programa 3.8: </b>Programa con funciones, utilizando la declaración y la definición de una función.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_8"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.8 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.8.png" style="display:block; margin:auto; "><br>
  
 
              </ng-template>
            </mat-tab>

          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Referencias">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="Introducción">
              <ng-template matTabContent>
                <br><h1>Referencias</h1>
                <p>Una referencia es un alias de una variable (Luna, F., 2004). Por ejemplo, dada una referencia R a una variable A, se puede directamente acceder a la variable A con la referencia R, por lo que se dice que la referencia R se refiere a la variable A. Para crear una referencia se debe considerar los siguientes puntos:</p>
                <ol type="a"><li>Especificar el tipo de la variable a la cual se referirá la referencia.</li>
                  <li>Utilizar el operador unario de dirección (&).</li>
                  <li>Utilizar un nombre para la referencia.</li>
                  <li>Seguida con una inicialización, la cual especifica la variable a la cual la referencia se referirá.</li>
              </ol>
                
                <p>Una referencia permite manipular la variable original a la cual se refiere, por lo tanto, puede ser utilizada para modificar el valor de la variable original para realizar operaciones de lectura y diferentes cálculos.</p>
             <p>A continuación, se presentan algunos ejemplos que muestran la creación de referencias referenciadas a variables:</p>
             <p><font color="green">// Variables</font></p>
             <p><font face="Consolas" color="blue">int </font><font face="Consolas">c + 7;</font></p>
             <p><font face="Consolas" color="blue">char </font><font face="Consolas">letra = </font><font face="Consolas" color="red">'M' </font><font face="Consolas">; </font></p>
             <p><font face="Consolas" color="blue">bool </font><font face="Consolas">veracidad = </font><font face="Consolas" color="blue">true </font><font face="Consolas">; </font></p>
             <p><font face="Consolas" color="blue">float </font><font face="Consolas">ex = exp(2.0);</font></p>
            <br>
            <p><font color="green">// Referencias ref a variables</font></p>
             <p><font face="Consolas" color="blue">int </font><font face="Consolas">&ref = c;</font></p>
             <p><font face="Consolas" color="blue">char </font><font face="Consolas">&ref = letra; </font>/p>
             <p><font face="Consolas" color="blue">bool </font><font face="Consolas">&ref = veracidad; </font></p>
             <p><font face="Consolas" color="blue">float </font><font face="Consolas">&ref = ex;</font></p>
            <br><h4><b>Ejercicio 3.9: </b>Escribir un programa donde se crea una variable con el valor de 7 y a continuación se crea una referencia a esa variable. Luego, imprimir el valor de la variable y el contenido de la referencia. Después, modificar el contenido de la referencia con el número 70. Finalmente, imprimir nuevamente el contenido de la variable y el contenido de la referencia:</h4>
            <h5><b>Programa 3.9: </b>Programa con referencias, utilizando la declaración y la definición de una referencia.</h5>
                <pre><code [highlight]="prefTabs3[0].programa3_9"  [lineNumbers]="true"></code></pre>
               <br> <h5><b>Ejecución 3.9: </b>Salida del programa.</h5>
                <img src="./assets/images/Capitulos/III/media/Ejecucion 3.9.png" style="display:block; margin:auto; "><br>
              <p>Como se puede ver en el programa 3.9, al ser la referencia un alias de una variable, el momento en que se modifica el contenido de la referencia, automáticamente se modifica el valor de la variable referenciada por esa referencia.</p>

              </ng-template>
            </mat-tab>
            <mat-tab  label="3.3.1.   Paso de Parámetros por Referencias">
              <ng-template matTabContent>
                <br><h1>Paso de Parámetros por Referencias</h1>
                <p>Se pueden retornar múltiples valores con referencias, por lo que las referencias permiten manipular las variables originales a las cuales se refieren, lo que se conoce como paso de parámetros por referencias (Luna, F., 2004). En esta sección se realizarán algunos ejercicios para realizar operaciones de lectura y cálculos matemáticos para modificar los valores de las variables originales utilizando referencias.</p>
                <h4><b>Ejercicio 3.10: </b>Escribir un programa con funciones y referencias que permita invertir dos números utilizando una variable auxiliar. Los prototipos de las funciones son:</h4>

                <p><font face="Consolas" color="blue">void </font><font face="Consolas">LeerDatos(</font><font face="Consolas" color="blue">int </font><font face="Consolas">&x, </font><font face="Consolas" color="blue">int </font><font face="Consolas">&y); </font></p>
                <p><font face="Consolas" color="blue">void </font><font face="Consolas">Invertir(</font><font face="Consolas" color="blue">int </font><font face="Consolas">&x, </font><font face="Consolas" color="blue">int </font><font face="Consolas">&y); </font></p>
                <p><font face="Consolas" color="blue">void </font><font face="Consolas">ImprimirDatos( </font><font face="Consolas" color="blue">int </font><font face="Consolas">x, </font><font face="Consolas" color="blue">int </font><font face="Consolas">y); </font></p>
               <br>
               <ol type="a">
                <li>El programa utilizará la función LeerDatos(), que permitirá leer dos valores enteros utilizando 2 referencias para manipular las variables. </li>
                <li>El programa utilizará la función Invertir(), que permitirá invertir dos valores numéricos utilizando 2 referencias y una variable auxiliar.</li>
                <li>El programa utilizará la función ImprimirDatos(), que permitirá imprimir dos valores numéricos, utilizando paso de parámetros por valor o por copia.</li>
                
               </ol>
          
          <h5><b>Programa 3.10: </b>Programa con referencias, utilizando la declaración y la definición de una referencia.</h5>
          <pre><code [highlight]="prefTabs3[0].programa3_10"  [lineNumbers]="true"></code></pre>
         <br> <h5><b>Ejecución 3.10: </b>Salida del programa.</h5>
          <img src="./assets/images/Capitulos/III/media/Ejecucion 3.10.png" style="display:block; margin:auto; "><br>

                <p>Como se puede ver en el programa 3.10, se implementaron dos funciones que utilizan el paso de parámetros por referencia: a) 
                  <font face="Consolas" color="blue">void</font> LeerDatos(
                    <font face="Consolas" color="blue">int </font>&x, 
                    <font face="Consolas" color="blue">int</font>&y); b) 
                    <font face="Consolas" color="blue">void </font> Invertir(
                      <font face="Consolas" color="blue">int </font>&x, 
                      <font face="Consolas" color="blue">int </font>&y); y se implementó una función que utiliza el paso de parámetros por valor: a) 
                      <font face="Consolas" color="blue">void </font> ImprimirDatos(
                  <font face="Consolas" color="blue">int </font>x, 
                  <font face="Consolas" color="blue">int </font>y).</p>
                  
                  <h4><b>Ejercicio 3.11: </b>Escribir un programa con funciones y referencias que permita ordenar tres números flotantes tomados de dos en dos. Los prototipos de las funciones son:</h4>

                  <p><font face="Consolas" color="blue">void </font><font face="Consolas">LeerDatos(</font><font face="Consolas" color="blue">float </font><font face="Consolas">&n1, </font><font face="Consolas" color="blue">float </font><font face="Consolas">&n2, </font><font face="Consolas" color="blue">float </font><font face="Consolas">&n3); </font></p>
                  <p><font face="Consolas" color="blue">void </font><font face="Consolas">ordenar(</font><font face="Consolas" color="blue">float </font><font face="Consolas">&menor, </font><font face="Consolas" color="blue">float </font><font face="Consolas">&mayor); </font></p>
                  <p><font face="Consolas" color="blue">void </font><font face="Consolas">ImprimirDatos( </font><font face="Consolas" color="blue">float </font><font face="Consolas">n1, </font><font face="Consolas" color="blue">float </font><font face="Consolas">n2, </font><font face="Consolas" color="blue">float </font><font face="Consolas">n3); </font></p>
                 <br>
                 <ol type="a"
                 >
                 <li>El programa utilizará la función LeerDatos(), que permitirá leer tres valores enteros utilizando 3 referencias para manipular las variables. </li>
                 <li>El programa utilizará la función Ordenar(), que permitirá ordena números de dos en dos utilizando 2 referencias y una variable auxiliar.</li>
                 <li>El programa utilizará la función ImprimirDatos(), que permitirá imprimir 3 valores numéricos, utilizando paso de parámetros por valor o por copia.</li>
                 </ol>
            
            <h5><b>Programa 3.11: </b>Programa con referencias, utilizando la declaración y la definición de una referencia.
              </h5>
            <pre><code [highlight]="prefTabs3[0].programa3_11"  [lineNumbers]="true"></code></pre>
           <br> <h5><b>Ejecución 3.11: </b>Salida del programa.</h5>
            <img src="./assets/images/Capitulos/III/media/Ejecucion 3.11.png" style="display:block; margin:auto; "><br>
  
                  <p>Como se puede ver en el programa 3.11, se implementaron dos funciones que utilizan el paso de parámetros por referencia: a) 
                    <font face="Consolas" color="blue">void</font> LeerDatos(
                      <font face="Consolas" color="blue">float </font>&n1, 
                      <font face="Consolas" color="blue">float </font>&n2,
                      <font face="Consolas" color="blue">float </font>&n3); b) 
                      <font face="Consolas" color="blue">void </font> Irdenar(
                        <font face="Consolas" color="blue">float </font>&menor, 
                        <font face="Consolas" color="blue">float </font>&mayor); y se implementó una función que utiliza el paso de parámetros por valor: a) 
                        <font face="Consolas" color="blue">void </font> ImprimirDatos(
                    <font face="Consolas" color="blue">float </font>n1, 
                    <font face="Consolas" color="blue">float </font>n2,  
                    <font face="Consolas" color="blue">int </font>n3).</p>
             
                  </ng-template>
            </mat-tab>

          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Punteros">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="Introducción">
              <ng-template matTabContent>
                <br><h1>Punteros</h1>
                <p>Un puntero es una variable especial que almacena la dirección de memoria de una variable, para poder manipular el contenido de la variable a la que apunta (Granizo, E., 2016). Como cualquier tipo de variable, un puntero debe haber sido declarado antes de que pueda ser utilizado y ocupa 4 bytes de memoria. Un puntero se declara de acuerdo con la siguiente sintaxis:</p>
                <table border="1" CELLPADDING=5 CELLSPACING=0>
                  <tr VALIGN=top><td><b> Sintaxis:</b><p>
                    <font face="Consolas">Tipo_de_Dato *Nombre_del_Puntero;</font>
                  </p></tr>
                </table><br>
                <table>
                  <tr><td><font face="Consolas">Tipo_de_Dato</font></td><td>Tipo de dato definido por el lenguaje C/C++.</td></tr>
                  <tr><td>*</td><td>Operador de indirección, que indica que se creó un puntero.</td></tr>
                  <tr><td><font face="Consolas">Nombre_del_Puntero</font></td><td>Identificador que indica el nombre del puntero</td></tr>
                </table><br>

                <table border="1" CELLPADDING=5 CELLSPACING=0>
                  <tr VALIGN=top><td width="50"><b> Nota:</b></td><td>  
                    Un puntero permite manipular la variable a la cual apunta, por lo tanto, puede ser utilizado para modificar el valor de la variable apuntada, para realizar operaciones de lectura y diferentes cálculos.
                  </td></tr>
                </table><br>
                <p>A continuación, se presentan algunos ejemplos que muestran la creación de punteros que apuntan a variables:</p>

                <p><font color="green">// Variables</font></p>
                <p><font face="Consolas" color="blue">int </font><font face="Consolas">c = 7;</font></p>
                <p><font face="Consolas" color="blue">char </font><font face="Consolas">letra = </font><font face="Consolas" color="red">'M' </font><font face="Consolas">; </font></p>
                <p><font face="Consolas" color="blue">bool </font><font face="Consolas">veracidad = </font><font face="Consolas" color="blue">true </font><font face="Consolas">; </font></p>
                <p><font face="Consolas" color="blue">float </font><font face="Consolas">ex = exp(2.0);</font></p>
               <br>
               <p><font color="green">// Punteros que apuntan a variables</font></p>
                <p><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr; ptr = &amp;c;</font></p>
                <p><font face="Consolas" color="blue">char </font><font face="Consolas">*ptr; = ptr = &amp;letra; </font>/p>
                <p><font face="Consolas" color="blue">bool </font><font face="Consolas">*ptr; = ptr = &amp;veracidad; </font></p>
                <p><font face="Consolas" color="blue">float </font><font face="Consolas">*ptr; = ptr = &amp;ex;</font></p>
                <br>
                <p>También, se puede hacer que en una sola instrucción se realice la declaración e inicialización de un puntero, como se indica a continuación:</p>
                <p><font color="green">// Punteros que apuntan a variables</font></p>
                 <p><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr = &amp;c;</font></p>
                 <p><font face="Consolas" color="blue">char </font><font face="Consolas">*ptr = &amp;letra; </font>/p>
                 <p><font face="Consolas" color="blue">bool </font><font face="Consolas">*ptr = &amp;veracidad; </font></p>
                 <p><font face="Consolas" color="blue">float </font><font face="Consolas">*ptr = &amp;ex;</font></p>
               
              </ng-template>
            </mat-tab>
            <mat-tab  label="3.4.1. El Operador de Dirección (&)">
              <ng-template matTabContent>
                <br><h1>El Operador de Dirección (&)</h1>
                <p>El operador de dirección (&) es un operador unario que se utiliza tanto para almacenar la dirección de memoria de una variable, así como también para devolver la dirección de memoria de su operando (Davies, P., 1995). Por ejemplo, considerando las siguientes instrucciones: </p>
              <ol type="a">
                <li><font face="Consolas" color="blue">int </font><font face="Consolas">c = 7;</font></li>
                <li><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr;</font></li>
                <li>ptr = &amp;c;</li>
                <ol type="a">
                  <li>Declaración e inicialización de la variable 'c' con el número ‘7’.</li>
                  <li>El identificador ‘ptr’ es el nombre del puntero. El operador ‘*’ significa que ‘ptr’ es un puntero. El puntero ‘ptr’ puede ser utilizado para apuntar variables de tipo ‘int’ (entero).</li>
                  <li>El puntero ‘ptr’ es un puntero a entero inicializado con la dirección de la variable ‘c’.</li>
                </ol>
              </ol>
              <p>Es muy común declarar y luego inicializar directamente al puntero, con lo que se obtienen las siguientes dos instrucciones en lugar de tres:</p>
              <ol type="a">
                <li><font face="Consolas" color="blue">int </font><font face="Consolas">c = 7;</font></li>
                <li><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr = &amp;c;</font></li>
                <ol type="a">
                  <li>Declaración e inicialización de la variable 'c' con el número ‘7’.</li>
                <li>b.	Se crea un puntero a entero llamado ‘ptr’, utilizando el operador de indirección (*) y luego se lo inicializa con la dirección de la variable ‘c’.</li>  
                </ol>
              </ol>
              </ng-template>
            </mat-tab>

            <mat-tab  label="3.4.2. El Operador de Indirección (*)">
              <ng-template matTabContent>
                <br><h1>El Operador de Indirección (*)</h1>
                <p>De acuerdo con (Davies, P., 1995), el operador de indirección (*) es un operador unario que, a más de ser utilizado como el operador de multiplicación, cumple con otras dos funciones muy importantes:</p>
              <ol type="a">
                <li>Se utiliza para declarar o crear un puntero. Por ejemplo:
                  <p><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr;</font></p>
                </li>
                <li>b.	Se utiliza para devolver una expresión equivalente al valor contenido en la dirección apuntada por un puntero. Esta operación recibe el nombre de “desreferencia” ya que permite que un puntero pueda acceder y modificar el valor contenido actual de la variable apuntada por dicho puntero, por lo que se dice que el puntero está desreferenciado. Por ejemplo:
                  <p><font face="Consolas">*ptr = 70;</font></p>
                  <p>En esta instrucción se asigna al contenido de lo que apunta el puntero 'ptr' el valor de 70, utilizando el operador de indirección (*). Debido a que el puntero 'ptr' apunta a una variable, puede modificar el contenido de esa variable, utilizando el operador de indirección (*).</p>
                </li>
              </ol>
              
              
              </ng-template>
            </mat-tab>

            <mat-tab  label="3.4.3. El 'rvalue' y el 'lvalue' de una Variable y de un Puntero">
              <ng-template matTabContent>
                <br><h1>El 'rvalue' y el 'lvalue' de una Variable y de un Puntero</h1>
              <p>De acuerdo con (Davies, P., 1995), cuando en el lenguaje C/C++ se trabajan con variables y punteros se puede hablar del <font face="Consolas">'rvalue'</font> y del <font face="Consolas">'lvalue'</font> de una variable.</p>
                <ol type="a">
                  <li>El <font face="Consolas">'lvalue'</font> de una variable es la dirección de memoria (localidad) donde la variable está almacenada.</li>
                  <li>El <font face="Consolas">'rvalue'</font> de una variable es el dato (contenido real) que la variable tiene. En otras palabras, es el valor de la variable.</li>
                </ol>
            <p>Como se habló en la sección 1.4. la dirección de memoria donde se ubica una variable se representa en formato hexadecimal (hex). Por cuestiones didácticas vamos a utilizar valores en formato decimal (dec) para representar las direcciones de memoria de las variables.</p>
            <p>Considerando las siguientes dos instrucciones explicadas anteriormente, vamos a analizar el <font face="Consolas">'rvalue'</font> y el <font face="Consolas">'lvalue'</font> de cada una de las variables:</p>
            <p><font face="Consolas" color="blue">int </font><font face="Consolas">c = 7;</font></p>
            <p><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr = &amp;c;</font></p>
            <li>La variable ‘c’ tiene un rvalue igual a 7 y reside en la dirección de memoria o lvalue igual a hex 1000.</li>
                <li>El puntero ‘ptr’ reside en la dirección de memoria o lvalue igual a hex 3000 y en su rvalue tiene asignado la dirección de memoria de la variable ‘c’ que es igual a hex 1000.</li>
                <p>A continuación, se presenta en la Figura 3.5. el diagrama de bloques de los valores reales (rvalues) y de las localidades de la memoria (lvalues) de la variable ‘c’ y del puntero ‘ptr’.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.5.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 3.5. </b>Diagrama de Bloques de los <font face="Consolas">'rvalue'</font> y <font face="Consolas">'lvalue'</font> de las variables.</h5>
      <p>En la Figura 3.6. se presenta el mapa de la memoria RAM de la variable ‘c’ y del puntero ‘ptr’.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.6.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 3.6. </b>Mapa de la memoria RAM.</h5>
              <p>Como se puede ver en el mapa de la memoria RAM la variable ‘c’ de tipo entero ocupa 2 bytes de memoria desde la dirección 1000 a la dirección 1002. El puntero ‘ptr’ en cambio ocupa 4 bytes de memoria desde la dirección 3000 a la dirección 3004 y apunta a la variable ‘c’.</p>
                <p>El número de bytes que necesita una variable de tipo puntero (apuntador) no depende del tipo de dato al que apunta, por lo que un puntero siempre necesitará 4 bytes de memoria en plataformas de 32 bits, en cambio en plataformas de 64 bits ocupará 8 bytes de memoria y en plataformas de 16 bits ocupará 2 bytes de memoria.</p>
                <h4><b>Ejercicio 3.12: </b>Escribir un programa donde se crea una variable con el valor de 7 y a continuación se crea un puntero que apunta a esa variable. Luego, imprimir el valor de la variable y el contenido de lo que apunta el puntero. Después, modificar el contenido de lo que apunta el puntero con el número 70. Finalmente, imprimir nuevamente el contenido de la variable y el contenido de lo que apunta el puntero:</h4>
                <h5><b>Programa 3.12: </b>Programa con referencias, utilizando la declaración y la definición de una referencia.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_12"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.12 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.12.png" style="display:block; margin:auto; "><br>
                <p>Como se puede ver en el programa 3.11, al apuntar el puntero ‘ptr’ a la variable ‘c’, este puntero puede acceder a la variable ‘c’ y modificar el contenido de la misma. El momento en que el puntero ‘ptr’ modifica el contenido de la variable ‘c’, la variable ‘c’ tiene un nuevo valor. En la Figura 3.12.1, se muestra el mapa de la memoria RAM de este programa. </p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.12.1.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.12.1. </b>Mapa de la memoria RAM.</h5>
                <p>En la Figura 3.12.2, se muestra el diagrama de bloques de los valores ‘rvalues’ y ‘lvalues’ de este programa, donde se pude ver claramente que el puntero ‘ptr’ modifica el contenido de la variable ‘c’.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.12.2.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.12.2. </b>Mapa de la memoria RAM.</h5>              
              </ng-template>
            </mat-tab>

            <mat-tab  label="3.4.4.   Paso de Parámetros por Dirección o Punteros">
              <ng-template matTabContent>
                <br><h1>Paso de Parámetros por Dirección o Punteros</h1>
                <p>Se pueden retornar múltiples valores con punteros, por lo que los punteros permiten manipular las variables a las cuales apuntan, lo que se conoce como paso de parámetros por dirección o por punteros (Davies, P., 1995). En esta sección se realizarán algunos ejercicios para realizar operaciones de lectura y cálculos matemáticos para modificar los valores de las variables originales utilizando punteros.</p>
                <h4><b>Ejercicio 3.13: </b>Escribir un programa con funciones y punteros que permita invertir dos números utilizando una variable auxiliar. Los prototipos de las funciones son:</h4>
                <p><font face="Consolas" color="blue">void </font><font face="Consolas">LeerDatos(</font><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr_x, </font><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr_y); </font></p>
                <p><font face="Consolas" color="blue">void </font><font face="Consolas">Invertir(</font><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr_x, </font><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr_y); </font></p>
                <p><font face="Consolas" color="blue">void </font><font face="Consolas">ImprimirDatos(</font><font face="Consolas" color="blue">int </font><font face="Consolas">x, </font><font face="Consolas" color="blue">int </font><font face="Consolas">y); </font></p>
               <br> 
               <ol type="a">
                <li>El programa utilizará la función LeerDatos(), que permitirá leer dos valores enteros utilizando 2 punteros para manipular las variables. </li>
                <li>El programa utilizará la función Invertir(), que permitirá invertir dos valores numéricos utilizando 2 punteros y una variable auxiliar.</li>
                <li>El programa utilizará la función ImprimirDatos(), que permitirá imprimir dos valores numéricos, utilizando paso de parámetros por valor o por copia.</li>
               </ol>
               
                <h5><b>Programa 3.13: </b>Programa con referencias, utilizando la declaración y la definición de una referencia.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_13"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.13 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.13.png" style="display:block; margin:auto; "><br>
                    <p>Como se puede ver en el programa 3.13, se implementaron dos funciones que utilizan el paso de parámetros por dirección (punteros): a) 
                    <font face="Consolas" color="blue">void</font> LeerDatos(
                      <font face="Consolas" color="blue">int </font>&x, 
                      <font face="Consolas" color="blue">int </font>&y); b) 
                      <font face="Consolas" color="blue">void </font> Invertir(
                        <font face="Consolas" color="blue">int </font>&x, 
                        <font face="Consolas" color="blue">int </font>&y); y se implementó una función que utiliza el paso de parámetros por valor: a) 
                        <font face="Consolas" color="blue">void </font> ImprimirDatos(
                    <font face="Consolas" color="blue">int </font>x,   
                    <font face="Consolas" color="blue">int </font>y).</p>
              
            <br>
                <br><h2>3.13.1.  Función <font face="Consolas">LeerDatos()</font></h2>
                <p>La Figura 3.13.1 muestra cómo trabaja la función ‘LeerDatos()’, luego de ser declarada y definida. La llamada a la función ‘LeerDatos()’ envía dos argumentos por dirección a los parámetros (punteros) de la función, la misma que cumple con las tareas de lectura de datos y no retorna ningún valor.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.13.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.13. </b>Llamada a la función con parámetros y retorno de un void.</h5>
              <p>En la Figura 3.13.1 se presenta el mapa de la memoria RAM de la función ‘LeerDatos()’, antes de que los punteros modifiquen los valores contenidos en las variables ‘a’ y ‘b’.</p>
              <img src="./assets/images/Capitulos/III/media/Figura 3.13.1.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.13.1. </b>Mapa de la memoria RAM antes de modificar los valores de las variables.</h5>
              <p>En la Figura 3.13.2 se presenta el mapa de la memoria RAM de la función ‘LeerDatos()’, después de que los punteros modifican los valores contenidos en las variables ‘a’ y ‘b’, donde cada puntero accede al contenido de cada variable utilizando el operador de indirección (*).</p>
              <img src="./assets/images/Capitulos/III/media/Figura 3.13.2.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.13.2. </b>Mapa de la memoria RAM antes de modificar los valores de las variables.</h5>
              <img src="./assets/images/Capitulos/III/media/Figura 3.13.3.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.13.3. </b>Llamada a la función con parámetros y retorno de un void.</h5>
                <br><h2>3.13.2.  Función <font face="Consolas">ImprimirDatos()</font></h2>
                <p>La Figura 3.13.3 muestra cómo trabaja la función ‘ImprimirDatos()’, luego de ser declarada y definida. La llamada a la función ‘ImprimirDatos()’ envía dos argumentos por valor a los parámetros de la función, la misma que cumple con las tareas de impresión de datos y no retorna ningún valor. En este caso la función ‘ImprimirDatos()’, imprime los valores de los números originales antes de ser invertidos.</p>
                <p>En la Figura 3.13.4 se presenta el mapa de la memoria RAM de la función ‘ImprimirDatos()’, donde las variables ‘x’ e ‘y’ reciben los valores por copia de las variables ‘a’ y ‘b’.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.13.4.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.13.4. </b>Mapa de la memoria RAM de la función ‘ImprimirDatos()’.</h5>
              <p>La Figura 3.13.5 muestra el proceso de impresión de los valores de los números invertidos, para lo cual se llama a la función ‘ImprimirDatos()’ la misma que envía dos argumentos por valor a los parámetros de la función.</p>
              <img src="./assets/images/Capitulos/III/media/Figura 3.13.5.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.13.5. </b>Llamada a la función con parámetros y retorno de un void.</h5>
                <p>En la Figura 3.13.6 se presenta el mapa de la memoria RAM de la función ‘ImprimirDatos()’, donde las variables ‘x’ e ‘y’ reciben los valores por copia de las variables ‘a’ y ‘b’.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.13.6.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 3.13.6. </b>Mapa de la memoria RAM de la función ‘ImprimirDatos()’.</h5>
                
                <br><h2>3.13.3.  Función <font face="Consolas">InvertirDatos()</font></h2>
              <p>La Figura 3.13.7 muestra cómo trabaja la función ‘InvertirDatos()’, luego de ser declarada y definida. La llamada a la función ‘InvertirDatos()’ envía dos argumentos por dirección a los parámetros (punteros) de la función, la misma que cumple con la tarea de invertir los datos y no retorna ningún valor.</p>
              <img src="./assets/images/Capitulos/III/media/Figura 3.13.7.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 3.13.7. </b>Llamada a la función con parámetros y retorno de un void.</h5>
                <p>En la Figura 3.13.8 se presenta el mapa de la memoria RAM de la función ‘InvertirDatos()’, antes de que los punteros modifiquen los valores contenidos en las variables ‘a’ y ‘b’, con la ayuda de la variable ‘temp’.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.13.8.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 3.13.8. </b>Mapa de la memoria RAM antes de modificar los valores de las variables.</h5>
                <p>En la Figura 3.13.9 se presenta el mapa de la memoria RAM de la función ‘InvertirDatos()’, después de que los punteros modifican los valores contenidos en las variables ‘a’ y ‘b’, con la ayuda de la variable ‘temp’, donde cada puntero accede al contenido de cada variable utilizando el operador de indirección (*).</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.13.9.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 3.13.9. </b>Mapa de la memoria RAM antes de modificar los valores de las variables.</h5>
                <h4><b>Ejercicio 3.14: </b>Escribir un programa con funciones y punteros que permita ordenar tres números flotantes tomados de dos en dos. Los prototipos de las funciones son</h4>
                <p><font face="Consolas" color="blue">void </font><font face="Consolas">LeerDatos(</font><font face="Consolas" color="blue">float</font><font face="Consolas">* ptr_n1, </font><font face="Consolas" color="blue">float</font><font face="Consolas">* ptr_n2, </font><font face="Consolas" color="blue">float</font><font face="Consolas">* ptr_n3); </font></p>
                <p><font face="Consolas" color="blue">void </font><font face="Consolas">Ordenar(</font><font face="Consolas" color="blue">float</font><font face="Consolas">* pmenor, </font><font face="Consolas" color="blue">float </font><font face="Consolas">* pmayor); </font></p>
                <p><font face="Consolas" color="blue">void </font><font face="Consolas">ImprimirDatos( </font><font face="Consolas" color="blue">float </font><font face="Consolas">n1, </font><font face="Consolas" color="blue">float </font><font face="Consolas">n2, </font><font face="Consolas" color="blue">float</font><font face="Consolas">n3); </font></p>
               <ol type="a">
                 <li>El programa utilizará la función LeerDatos(), que permitirá leer 3 valores enteros utilizando 3 punteros para manipular las variables. </li>
                  <li>El programa utilizará la función Ordenar(), que permitirá ordenar números de dos en dos utilizando 2 punteros y una variable auxiliar.</li>
                <li>El programa utilizará la función ImprimirDatos(), que permitirá imprimir 3 valores numéricos, utilizando paso de parámetros por valor o por copia.</li>
                </ol>
                <h5><b>Programa 3.14: </b>Programa con referencias, utilizando la declaración y la definición de una referencia.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_14"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.14: </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.14.png" style="display:block; margin:auto; "><br>
                    <p>Como se puede ver en el programa 3.14, se implementaron dos funciones que utilizan el paso de parámetros por dirección: a) 
                      <font face="Consolas" color="blue">void</font> LeerDatos(
                        <font face="Consolas" color="blue">float </font>* ptr_n1, 
                        <font face="Consolas" color="blue">float </font>* ptr_n2,
                        <font face="Consolas" color="blue">float </font>* ptr_n3); b) 
                        <font face="Consolas" color="blue">void </font> Ordenar(
                          <font face="Consolas" color="blue">float </font>* pmenor, 
                          <font face="Consolas" color="blue">float </font>* pmayor); y se implementó una función que utiliza el paso de parámetros por valor: a) 
                          <font face="Consolas" color="blue">void </font> ImprimirDatos(
                      <font face="Consolas" color="blue">float </font>n1, 
                      <font face="Consolas" color="blue">float </font>n2,  
                      <font face="Consolas" color="blue">int </font>n3).</p>

              </ng-template>
            </mat-tab>
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Aplicaciones de Funciones Matemáticas">
        <ng-template matTabContent>
           <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="Introducción">
              <ng-template matTabContent>
                <br><h1>Aplicaciones de Funciones Matemáticas</h1>
          <p>Así, como existe una gran variedad de funciones matemáticas en la librería de Encabezado de Funciones Matemáticas (Math Library Header), como se mencionó en la sección 1.2.1 y luego se aplicó varias de estas funciones en la resolución de problemas como se puede ver en la sección 1.8.1, este número de funciones son limitadas, por lo que se pueden crear librerías propias de funciones matemáticas aplicadas a la vida real y a otras áreas de las ciencias del saber. </p>
          <p>Uno de los conceptos más importantes en las Matemáticas es la función, ya que se puede aplicar en numerosas situaciones de la vida cotidiana y determinar las relaciones que existen entre magnitudes tanto en Matemáticas, Física, Química, Biología, Economía, etc., y poder calcular el valor de una de ellas en función de otras de las que depende (Ballester, S., 2009).</p>
          <p>El famoso matemático Euler fue el primero en emplear la expresión y = f(x) para representar una función ‘f’ asociada a un valor ‘x’. Con esta representación que es empleada hoy en el Cálculo Diferencial e Integral, se comenzó a utilizar el concepto de función en las Matemáticas.</p>
          <p>En esta sección se presentarán algunas funciones aplicadas a varias áreas del saber tales como: Cinemática, Dinámica, Energía, Química, Acústica, Economía, Termodinámica y Física Clásica. </p>
         
              </ng-template>
            </mat-tab>
            <mat-tab  label="Caso de Estudio 3.1">
              <ng-template matTabContent>
                <br><h1><b>Caso de Estudio 3.1: Encontrar la distancia, tiempo de vuelo y la altura alcanzada por un proyectil.</b></h1>
               <h2><b>A) Problema</b></h2>
              <p>Escribir un programa para calcular e imprimir la distancia ‘d’, el tiempo de vuelo ‘t’ y la altura ‘h’ alcanzada por un proyectil que es disparado con un ángulo θ (‘theta’) en grados con respecto a la horizontal y a una velocidad inicial ‘v’ en m/seg. La trayectoria parabólica del proyectil se muestra en la Figura 3.1.1 y cuyas fórmulas son las siguientes:</p>
              <img src="./assets/images/Capitulos/III/media/Figura 3.1.1.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.1.1. </b>Tiro Parabólico de un Proyectil.</h5>
 
              <h2><b>B) Análisis</b></h2>
              <p>Claramente, se puede ver que las entradas del problema son la velocidad inicial de lanzamiento del proyectil y el ángulo de lanzamiento theta en grados. Hay tres salidas requeridas: el tiempo de vuelo, la distancia y la altura alcanzada por un proyectil. Partiendo de un conocimiento básico de Física, se sabe que hay una relación entre la velocidad y el ángulo de lanzamiento con la distancia, el tiempo de vuelo y la altura. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
              
	          <h3><b>B.1) Requerimiento de los Datos</b></h3>
            <p><b>Constante del Problema</b></p>
           <p>PI + 3.141596</p>
            <p>g = 9.8</p>          
           <br> 
            <p><b>Entradas del Programa</b></p>		
	          	<table>
                  <tr><td width="200"> v </td><td width="200">/* velocidad de lanzamiento */</td></tr>
                  <tr><td>theta</td><td>/* ángulo de lanzamiento */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200"> d </td><td width="400">/* distancia alcanzada por el proyectil */</td></tr>
                  <tr><td width="200"> t </td><td width="400">/* tiempo de vuelo */</td></tr>
                  <tr><td width="200"> h </td><td width="400">/* altura alcanzada por el proyectil */</td></tr>
                </table><br>
		
                <p><b>Fórmulas Relevantes</b></p>
                <table>
		<tr><td ><i>d = (<sup>v<sup>2</sup>∙sen(2θ)</sup>) / <sub>g</sub></i></td><td> (1) </td><td>/* Fórmula de la distancia alcanzada por el proyectil */</td></tr>
                <tr><td width="120"><i>d = (<sup>v∙sen(2θ)</sup>) / <sub>g</sub></i></td><td width="30"> (2) </td><td width="400">/* Fórmula del tiempo de vuelo del proyectil */</td></tr>
                  <tr><td ><i>d = (<sup>v<sup>2</sup>∙sen<sup>2</sup> (2θ)</sup>) / <sub>2g</sub></i></td><td> (3) </td><td>/* Fórmula de la altura alcanzada por el proyectil */</td></tr>
                </table> <br>

                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 3.1.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘v’ (velocidad) y la variable ‘theta’ (ángulo); b) Salidas: las variables ‘d’ (distancia), ‘t’ (tiempo) y ‘h’ (altura); c) Auxiliares: la constante ‘PI’ y la constante ‘g’ (gravedad).</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.1.2.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 3.1.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                <h3><b>C.1) Algoritmos</b></h3>
                <p><b>Algoritmo de la Función <font face="Consolas">ImprimirMensajeInformacion()</font></b></p>
                <ol type="1">
                  <li>Imprimir el mensaje de información: <font face="Consolas" color="red">“Tiro Parabólico de un Proyectil.”</font>.</li>
                  <li>Imprimir dos saltos de línea (INTRO).</li>
                </ol>
                <p><b>Algoritmo de la Función <font face="Consolas">LeerDatos()</font></b></p>
                <ol type="1">
                  <li>Leer el valor de la velocidad en m/seg, utilizando la referencia ‘v’.</li>
                  <li>Leer el valor del ángulo theta en grados, utilizando la referencia ‘theta’.</li>
                </ol>
                <p><b>Algoritmo de la Función <font face="Consolas">ConvertirGradosARadianes()</font></b></p>
                <ol type="1">
                  <li>Convertir el ángulo theta de grados a radianes.</li>
                  <ol type="1">
                    <li>1.	Asignar a la variable ‘theta’ el valor que retorna la función ConvertirGradosARadianes(), que es el producto del ángulo ‘theta’ por la constante PI y dividido para el valor de 180 grados.</li>
                  </ol>
                </ol>
                <p><b>Algoritmo de la Función <font face="Consolas">Distancia()</font></b></p>
                <ol type="1">
                  <li>Calcular la distancia alcanzada por el proyectil.</li>
                  <ol type="1">
                    <li>1.	Asignar a la variable ‘d’ (distancia) el valor que retorna la función Distancia(), que es el valor que contempla la fórmula de la distancia (1), según la Física Clásica.</li>
                  </ol>
                </ol>
                <p><b>Algoritmo de la Función <font face="Consolas">Tiempo()</font></b></p>
                <ol type="1">
                  <li>Calcular el tiempo de vuelo del proyectil.</li>
                  <ol type="1">
                    <li>1.	Asignar a la variable ‘t’ (tiempo) el valor que retorna la función Tiempo(), que es el valor que contempla la fórmula del tiempo de vuelo (2), según la Física Clásica.</li>
                  </ol>
                </ol>
                <p><b>Algoritmo de la Función <font face="Consolas">Altura()</font></b></p>
                <ol type="1">
                  <li>Calcular la altura alcanzada por el proyectil.</li>
                  <ol type="1">
                    <li>1.	Asignar a la variable ‘h’ (altura) el valor que retorna la función Altura(), que es el valor que contempla la fórmula de la altura (3), según la Física Clásica.</li>
                  </ol>
                </ol>
                <p><b>Algoritmo de la Función <font face="Consolas">ImprimirDatos()</font></b></p>
                <ol type="1">
                  <li>Imprimir los valores de la variable ‘d’ (distancia), de la variable ‘t’ (tiempo) y de la variable ‘h’ (altura).</li>
                </ol>
                <p><b>Algoritmo de la Función <font face="Consolas">main()</font></b></p>
                <ol type="1">
                  <li>Llamada a la función ImprimirMensajeInformacion().</li>
                  <li>Llamada a la función LeerDatos().</li>
                  <li>Asignar a la variable ‘theta’ el valor que retorna la función <font face="Consolas">ConvertirGradosARadianes()</font>.</li>
                  <li>Asignar a la variable ‘d’ el valor que retorna la función <font face="Consolas">Distancia()</font>.</li>
                  <li>Asignar a la variable ‘t’ el valor que retorna la función <font face="Consolas">Tiempo()</font>.</li>
                  <li>Asignar a la variable ‘h’ el valor que retorna la función <font face="Consolas">Altura()</font>.</li>
                  <li>Imprimir un salto de línea (INTRO).</li>
                  <li>Llamada a la función <font face="Consolas">ImprimirDatos()</font>.</li>
                </ol>
                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 3.1.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 3.1.1. </b>Programa que calcula la distancia, tiempo de vuelo y la altura alcanzada por un proyectil.</h5>
                <pre><code [highlight]="prefTabs3[0].Tabla3_1_1"  [lineNumbers]="true"></code></pre> <br>
                <h3><b>D.1.) Explicación de las Funciones</b></h3>
                <p><b>3.1.9. Función <font face="Consolas">ImprimirMensajeInformacion()</font></b></p>
                <p>La Figura 3.1.3 muestra cómo trabaja la función ‘ImprimirMensajeInformacion()’, luego de ser declarada y definida. La llamada a la función ‘ImprimirMensajeInformacion()’ no envía argumentos a la función, pero cumple con la tarea de imprimir el mensaje de información:
                  <font face="Consolas" color="red">"Tiro Parabólico de un Proyectil."</font>, e imprime dos saltos de línea y no retorna ningún valor.</p>
                  <img src="./assets/images/Capitulos/III/media/Figura 3.1.3.png" style="display:block; margin:auto; "><br>
                  <h5 style="text-align:center"><b>Figura 3.1.3. </b>Llamada a la función sin parámetros y retorno de un void.</h5>
                  <p><b>3.1.10. Función <font face="Consolas">LeerDatos()</font></b></p>
                <p>La Figura 3.1.4 muestra cómo trabaja la función ‘LeerDatos()’, luego de ser declarada y definida. La llamada a la función ‘LeerDatos()’ envía dos argumentos a los parámetros de la función que son dos referencias, la misma que cumple con las tareas de lectura de datos y no retorna ningún valor.</p>
                   <img src="./assets/images/Capitulos/III/media/Figura 3.1.4.png" style="display:block; margin:auto; "><br>
                  <h5 style="text-align:center"><b>Figura 3.1.4. </b>Llamada a la función con dos parámetros y retorno de un void.</h5>
                  
                  <p><b>3.1.11. Función <font face="Consolas">ConvertirGradosARadianes()</font></b></p>
                <p>La Figura 3.1.5 muestra cómo trabaja la función ‘ConvertirGradosARadianes()’, luego de ser declarada y definida. La llamada a la función ‘ConvertirGradosARadianes()’ envía un argumento por valor al parámetro de la función, la misma que cumple con la tarea de convertir un valor dado en grados a radianes y retorna ese valor calculado.</p>  
                <img src="./assets/images/Capitulos/III/media/Figura 3.1.5.png" style="display:block; margin:auto; "><br>
                  <h5 style="text-align:center"><b>Figura 3.1.5. </b>Llamada a la función con un parámetro y retorno de un valor.</h5>
                  
                  <p><b>3.1.12. Función <font face="Consolas">Distancia()</font></b></p>
                <p>La Figura 3.1.6 muestra cómo trabaja la función ‘Distancia()’, luego de ser declarada y definida. La llamada a la función ‘Distancia()’ envía dos argumentos por valor a los parámetros de la función, la misma que cumple con la tarea de calcular la distancia recorrida por un proyectil y retorna ese valor calculado.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.1.6.png" style="display:block; margin:auto; "><br>
                  <h5 style="text-align:center"><b>Figura 3.1.6. </b>Llamada a la función con dos parámetros y retorno de un valor.</h5>
                  
                  <p><b>3.1.13. Función <font face="Consolas">Tiempo()</font></b></p>
                  <p>La Figura 3.1.7 muestra cómo trabaja la función ‘Tiempo()’, luego de ser declarada y definida. La llamada a la función ‘Tiempo()’ envía dos argumentos por valor a los parámetros de la función, la misma que cumple con la tarea de calcular el tiempo de vuelo de un proyectil y retorna ese valor calculado.</p>
                  <img src="./assets/images/Capitulos/III/media/Figura 3.1.7.png" style="display:block; margin:auto; "><br>
                    <h5 style="text-align:center"><b>Figura 3.1.7. </b>Llamada a la función con dos parámetros y retorno de un valor.</h5>
                    
                    <p><b>3.1.14. Función <font face="Consolas">Altura()</font></b></p>
                    <p>La Figura 3.1.8 muestra cómo trabaja la función ‘Altura()’, luego de ser declarada y definida. La llamada a la función ‘Altura()’ envía dos argumentos por valor a los parámetros de la función, la misma que cumple con la tarea de calcular la altura alcanzada por un proyectil y retorna ese valor calculado.</p>
                    <img src="./assets/images/Capitulos/III/media/Figura 3.1.8.png" style="display:block; margin:auto; "><br>
                      <h5 style="text-align:center"><b>Figura 3.1.8. </b>Llamada a la función con dos parámetros y retorno de un valor.</h5>
                    
                  <p><b>3.1.15. Función <font face="Consolas">ImprimirDatos()</font></b></p>
                  <p>La Figura 3.1.9 muestra cómo trabaja la función ‘ImprimirDatos()’, luego de ser declarada y definida. La llamada a la función ‘ImprimirDatos()’ envía tres argumentos por valor a los parámetros de la función, la misma que cumple con las tareas de impresión de datos y no retorna ningún valor. En este caso la función ‘ImprimirDatos()’, imprime los valores de la distancia ‘d’, del tiempo de vuelo ‘t’ y de la altura ‘h’.</p>
                  <img src="./assets/images/Capitulos/III/media/Figura 3.1.9.png" style="display:block; margin:auto; "><br>
                      <h5 style="text-align:center"><b>Figura 3.1.9. </b>Llamada a la función con dos parámetros y retorno de un valor.</h5>
                    
                  <h2>E) Pruebas</h2>
                 <p>En la Tabla 3.1.2 se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
	            	<h5><b>Tabla 3.1.2.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/III/media/Tabla 3.1.2.png" style="display:block; margin:auto; "><br>
            		                
               
              </ng-template>
            </mat-tab>
            <mat-tab  label="Caso de Estudio 3.2">
              <h3><strong>Caso de Estudio 2.8: Encontrar la aceleración de dos objetos conectados mediante una cuerda. </strong></h3>
              <h4><strong>A)   Problema </strong></h4>
              <p>Dadas las siguientes tarifas por gasto eléctrico en función del consumo en KWH, como se puede ver en la Tabla 3.2.1:</p>
              <h4><strong>Tabla 3.2.1. </strong>Tarifas de consumo eléctrico.</h4>
              <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
                <TR>
                  <TH>Consumo (KWH)</TH>
                  <TH>Tarifa (USD por KWH)</TH>
                </TR>
                <tbody *ngFor="let item of prefTab[0].tablaDatos1">
                <TR style="text-align: left">
                  
                  <TD>
                    <ul *ngFor="let i of item.nota" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                  <TD>
                    <ul *ngFor="let i of item.puntos" style="list-style-type: none;">
                      <li>{{i}}</li>
                    </ul>
                  </TD>
                </TR>
                </tbody>
              </TABLE><br>
              <p>Escribir un programa que permita calcular el costo de la planilla de luz o el recibo de la luz. Los cuatro intervalos del consumo de la luz ‘c’ se muestran en la Figura 3.2.1 que son:</p>
              <p>TARIFA1: I_1:0≤ c ≤ 200, es decir, (0 ≤ c)∧(c ≤ 200)</p>
              <p>TARIFA2: I_2:200< c ≤ 500, es decir, (200 < c)∧(c ≤ 500) </p>
              <p>TARIFA3: I_3:500< c ≤ 700, es decir, (500 < c)∧(c ≤ 700)</p>
              <p>TARIFA4: I_4:c > 700</p>
              <img src="./assets/images/Capitulos/III/media/b1.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 3.2.1.  </strong>Intervalos del consumo de la luz.</h5>
              
              <h4><strong>B)   Análisis </strong></h4>
              <p>Claramente, se puede ver que la entrada del problema es el valor del consumo de la luz ‘c’. Hay una salida requerida que es el valor del recibo. Partiendo de un conocimiento básico de Álgebra, se sabe que hay cuatro intervalos y cuatro diferentes valores para los recibos que dependen de los valores de las tarifas. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
              <h4><strong>B.1)   Requerimiento de los Datos </strong></h4>
              <h4><strong>Constantes del Problema </strong></h4>
              <p>TARIFA1 = 0.35 <br>
                TARIFA2 = 0.55 <br>
                TARIFA3 = 0.75 <br>
                TARIFA4 = 1.05
                </p>
              
              <h4><strong>Entradas del Problema </strong></h4>
              <p>c	&nbsp; &nbsp;/* valor del consumo de la luz */ </p>
                            
              <h4><strong>Salidas del Problema </strong></h4>
              <p>recibo	&nbsp; &nbsp;/* valor del recibo */ </p>
              
              <h4><strong>Formulas Relevantes </strong></h4>
              <img src="./assets/images/Capitulos/III/media/b2.png" style="display:block; margin:auto; "><br>
              <h4><strong>B.2)   Diagrama de Entrada-Salida </strong></h4>
              <p>En la Figura 3.2.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘c’ (consumo); b) Salidas: la variable ‘recibo’; c) Auxiliares: la constante ‘TARIFA1’, la constante ‘TARIFA2’, la constante ‘TARIFA3’ y la constante ‘TARIFA4’. </p>
              <img src="./assets/images/Capitulos/III/media/b3.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 3.2.2.  </strong>Diagrama de Entrada-Salida del Programa.</h5>
              <h4><strong>C)   Diseño </strong></h4>
              <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
              <h4><strong>C.1) Algoritmos </strong></h4>
              <p><strong>3.2.1. Algoritmo de la Función ImprimirMensajeInformacion()</strong></p>
              <ol>
                <li>Imprimir el mensaje de información: “Consumo Eléctrico.”.</li>
                <li>Imprimir dos saltos de línea (INTRO).</li>
                
              </ol>
              <p><strong>3.2.2. Algoritmo de la Función LeerDatos()</strong></p>
              <p>1.	Leer el valor del consumo ‘c’.</p>
              <p><strong>3.2.3. Algoritmo de la Función GenerarRecibo()</strong>></p>
              <p>1.	Si el valor del consuno 'c' está dentro del intervalo I1: (0 ≤ c)∧(c ≤ 200).</p>
              <p> &nbsp; &nbsp; 1.1.	Calcular el valor del recibo con la TARIFA1.</p>
              <p>2.	Si el valor del consuno 'c' está dentro del intervalo I2: (200 < c)∧(c ≤ 500).</p>
              <p> &nbsp; &nbsp; 2.1.	Calcular el valor del recibo con la TARIFA2.</p>
              <p>3.	Si el valor del consuno 'c' está dentro del intervalo I3: (500 < c)∧(c ≤ 700).</p>
              <p> &nbsp; &nbsp; 3.1.	Calcular el valor del recibo con la TARIFA3.</p>
              <p>4.	Si el valor del consuno 'c' está dentro del intervalo I4: c > 700.</p>
              <p> &nbsp; &nbsp; 4.1.	Calcular el valor del recibo con la TARIFA4.</p>
                          
              <p><strong>3.2.4. Algoritmo de la Función ImprimirDatos()</strong></p>
              <p>1.	Imprimir el valor de la variable ‘recibo’.</p>
              <p><strong>3.2.5. Algoritmo de la Función main()</strong></p>
              <p>1.	Llamada a la función ImprimirMensajeInformacion().</p>
              <p>2.	Llamada a la función LeerDatos().</p>
              <p>3.	Asignar a la variable ‘recibo’ el valor que retorna la función GenerarRecibo().</p>
              <p>4.	Llamada a la función ImprimirDatos().</p>
                      
              <h4><strong>D)   Implementación </strong></h4>
              <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 3.2.1 se muestra el código del programa en C/C++.</p>
              <h5><strong>Tabla 3.2.1:  </strong>Programa que calcula el consumo eléctrico.</h5>
              <pre><code [highlight]="prefTab[0].programa1"  [lineNumbers]="true"></code></pre><br>
              <h4><strong>D.1.)   Explicación de las Funciones</strong></h4>
              <p><strong>3.2.6. Función ImprimirMensajeInformacion()</strong></p>
              <p>La Figura 3.2.3 muestra cómo trabaja la función ‘ImprimirMensajeInformacion()’, luego de ser declarada y definida. La llamada a la función ‘ImprimirMensajeInformacion()’ no envía argumentos a la función, pero cumple con la tarea de imprimir el mensaje de información: "Consumo Eléctrico.", e imprime dos saltos de línea y no retorna ningún valor.</p>
              <img src="./assets/images/Capitulos/III/media/b4.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 3.2.3. </strong>Llamada a la función sin parámetros y retorno de un void.</h5>
              <p><strong>3.2.7. Función LeerDatos()</strong></p>
              <p>La Figura 3.2.4 muestra cómo trabaja la función ‘LeerDatos()’, luego de ser declarada y definida. La llamada a la función ‘LeerDatos()’ envía un argumento al parámetro de la función que es una referencia, la misma que cumple con la tarea de lectura de datos y no retorna ningún valor.</p>
              <img src="./assets/images/Capitulos/III/media/b5.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 3.2.4. </strong>Llamada a la función con dos parámetros y retorno de un void.</h5>
              <p><strong>3.2.8. Función GenerarRecibo()</strong></p>
              <p>La Figura 3.2.5 muestra cómo trabaja la función ‘GenerarRecibo()’, luego de ser declarada y definida. La llamada a la función ‘GenerarRecibo()’ envía dos argumentos por valor a los parámetros de la función, la misma que cumple con la tarea de calcular calcula el valor del recibo de acuerdo al valor del consumo y a una tarifa específica y finalmente retorna ese valor calculado.</p>
              <img src="./assets/images/Capitulos/III/media/b6.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 3.2.5. </strong>Llamada a la función con dos parámetros y retorno de un valor.</h5>
              <p><strong>3.2.9. Función ImprimirDatos()</strong></p>
              <p>La Figura 3.2.6 muestra cómo trabaja la función ‘ImprimirDatos()’, luego de ser declarada y definida. La llamada a la función ‘ImprimirDatos()’ envía un argumento por valor al parámetro de la función, la misma que cumple con la tarea de impresión de datos y no retorna ningún valor. En este caso la función ‘ImprimirDatos()’, imprime el valor de la variable ‘recibo’.</p>
              <img src="./assets/images/Capitulos/III/media/b7.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 3.2.9. </strong>Llamada a la función con dos parámetros y retorno de un valor.</h5>

              <h4><strong>E) Pruebas </strong></h4>
              <p>La Tabla 3.2.2, la Tabla 3.2.3, la Tabla 3.2.4 y la Tabla 3.2.5 muestran cuatro ejemplos de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
              <p>En la salida de la Tabla 3.2.2 se puede ver que, al ingresar el valor del consumo igual a 100 se obtiene una cuenta total de $35 USD. De manera similar, en la salida Tabla 3.2.3 se puede ver que, al ingresar el valor del consumo igual a 400 se obtiene una cuenta total de $220 USD. De manera similar, en la salida Tabla 3.2.4 se puede ver que, al ingresar el valor del consumo igual a 600 se obtiene una cuenta total de $450 USD. Finalmente, en la salida Tabla 3.2.5 se puede ver que, al ingresar el valor del consumo igual a 800 se obtiene una cuenta total de $840 USD.</p>
              
              <h5><strong>Tabla 3.2.2:  </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/III/media/b8.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 3.2.3:  </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/III/media/b9.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 3.2.4:  </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/III/media/b10.png" style="display:block; margin:auto; "><br>
              <h5><strong>Tabla 3.2.5:  </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/III/media/b11.png" style="display:block; margin:auto; "><br>
              
            </mat-tab>

            <mat-tab  label="Caso de Estudio 3.3">
              <ng-template matTabContent>
                <h3><strong>Caso de Estudio 2.8: Encontrar la aceleración de dos objetos conectados mediante una cuerda. </strong></h3>
              <h4><strong>A)   Problema </strong></h4>
              <p>El valor de la función y=sen(x) se puede aproximar mediante la siguiente serie de Taylor:</p>
              <img src="./assets/images/Capitulos/III/media/b12.png" style="display:block; margin:auto; "><br>
              <p>La fórmula de la sumatoria de la función es:</p>
              <img src="./assets/images/Capitulos/III/media/b13.png" style="display:block; margin:auto; "><br>
              <p>Escribir un programa que permita aproximar el valor de la función seno utilizando la serie de Taylor y bucles anidados.</p>
              <h4><strong>B)   Análisis </strong></h4>
              <p>Claramente se puede ver que las entradas del problema son el número de términos de la serie y el valor del ángulo en grados de la función seno. Se requiere una sola salida que es el valor de la serie aproximada. El proceso de cálculo requiere que la serie numérica infinita de la ecuación (2), se convierta a una serie numérica finita, donde el valor de ‘n’ se convierte en el valor de ‘i’ y el valor de infinito pasa a ser el valor de n-1, ya que si se quiere calcular la sumatoria de los cinco primeros términos de la serie, la sumatoria iría desde el valor de i = 0 hasta el valor de i = 5 - 1, es decir, i = 4, como se puede ver en la ecuación (3):</p>
              <img src="./assets/images/Capitulos/III/media/b14.png" style="display:block; margin:auto; "><br>
              <p>Para calcular el valor del factorial de la función seno se requiere utilizar la sucesión del factorial de un número cuya ecuación es:</p>
              <img src="./assets/images/Capitulos/III/media/b15.png" style="display:block; margin:auto; "><br>
              <p>De acuerdo a la ecuación (4) se requiere utilizar una función llamada Factorial() que va a tener un bucle for() para calcular una sucesión en base a un producto. El proceso de cálculo del factorial de un número requiere que la sucesión numérica infinita de la ecuación (4), se convierta a una sucesión numérica finita, donde el valor de ‘n’ se convierte en el valor de ‘j’ y el valor de infinito pasa a ser el valor de n, ya que si se quiere calcular el producto de los cinco primeros términos de la sucesión, el producto iría desde el valor de j = 1 hasta el valor de j = 5 , como se puede ver en la ecuación (5): </p>
              <img src="./assets/images/Capitulos/III/media/b16.png" style="display:block; margin:auto; "><br>
              <p>De acuerdo con la ecuación (3) se requiere utilizar entonces una función llamada SerieSeno() que va a tener un bucle for() para calcular la sumatoria de los n-términos de la serie llamando en cada ciclo a la función Factorial() llevándose como argumento el valor de (2i+1), al parámetro de la función. Además, se tiene que convertir el valor del ángulo de grados a radianes para realizar los cálculos respectivos.</p>

              <h4><strong>B.1)   Requerimiento de los Datos </strong></h4>
                            
              <h4><strong>Entradas del Problema </strong></h4>
              <p>n	&nbsp; &nbsp;/* número de términos de la serie */ </p>
              <p>x	&nbsp; &nbsp;/* Ángulo de la función en grados */ </p>
                            
              <h4><strong>Salidas del Problema </strong></h4>
              <p>serie	&nbsp; &nbsp;/* Resultado de la serie aproximada */ </p>
              
              <h4><strong>Formulas Relevantes </strong></h4>
              <img src="./assets/images/Capitulos/III/media/b17.png" style="display:block; margin:auto; "><br>
              <h4><strong>B.2)   Diagrama de Entrada-Salida </strong></h4>
              <p>En la Figura 3.3.1 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘n’; la variable ‘x’; b) Salidas: la variable ‘serie’; Auxiliares: la constante PI.</p>
              <img src="./assets/images/Capitulos/III/media/b18.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 3.3.`.  </strong>Diagrama de Entrada-Salida del Programa.</h5>
              <h4><strong>C)   Diseño </strong></h4>
              <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
              <h4><strong>C.1) Algoritmos </strong></h4>
              <p><strong>3.3.1. Algoritmo de la Función ImprimirMensajeInformacion()</strong></p>
              <ol>
                <li>Imprimir el mensaje de información: “Serie del Seno.”.</li>
                <li>Imprimir dos saltos de línea (INTRO).</li>
                
              </ol>
              <p><strong>3.3.2. Algoritmo de la Función LeerDatos()</strong></p>
              <p>1.	Leer el número de términos de la serie, utilizando la referencia ‘n’.</p>
              <p>2.	Leer el valor del ángulo en grados de la función seno, utilizando la referencia ‘x’.</p>
              <p><strong>3.3.3. Algoritmo de la Función ConvertirGradosARadianes()</strong>></p>
              <p>1.	Asignar a la variable ‘x’ el valor que retorna la función ConvertirGradosARadianes(), que es el producto del ángulo ‘x’ por la constante PI y dividido para el valor de 180 grados, que permite convertir el ángulo ‘theta’ de grados a radianes.</p>
                                        
              <p><strong>3.3.4. Algoritmo de la Función Factorial()</strong></p>
              <p>1.	Inicializar el acumulador de productos ‘prod’ con el valor de uno.</p>
              <p>2.	Para el bucle, hacer: </p>
              <p> &nbsp; &nbsp; 2.1.	Inicializar el valor del contador ‘j’ en uno.</p>
              <p> &nbsp; &nbsp; 2.2.	Mientras el valor de la condición sea verdadera (j<=n) ejecutar las sentencias del bucle.</p>
              <p> &nbsp; &nbsp; 2.3.	Luego de cada iteración incrementar en uno el valor del contador ‘j’.</p>
              <p> &nbsp; &nbsp; &nbsp; 2.3.1.	Asignar al acumulador ‘prod’ lo que tiene multiplicado por el valor del contador ‘j’.</p>
              <p>3.	Retornar el valor del acumulador ‘prod’, que es el factorial de un número.</p>

              <p><strong>3.3.5. Algoritmo de la Función SerieSeno()</strong></p>
              <p>1.	Inicializar con el valor de cero el acumulador de sumas cuya variable utilizada es ‘sum’.</p>
              <p>2.	Para el bucle, hacer: </p>
              <p> &nbsp; &nbsp; 2.1.	Inicializar el valor del contador ‘i’ en cero. </p>
              <p> &nbsp; &nbsp; 2.2.	Mientras el valor de la condición sea verdadera (i<=n-1) ejecutar las sentencias del bucle. </p>
              <p> &nbsp; &nbsp; 2.3.	Luego de cada iteración incrementar en uno el valor del contador ‘i’. </p>
              <p> &nbsp; &nbsp; &nbsp; 2.3.1.	Asignar al acumulador ‘sum’ lo que tiene sumado el valor del término e-nésimo de la serie, incluyendo el valor que retorna la función Factorial(), la cual se lleva como argumento el valor de     (2 * i + 1), al parámetro de la función Factorial().</p>
              <p>3.	Retornar el valor del acumulador ‘sum’, que es el valor de la serie de la función seno(x).</p>
              
              <p><strong>3.3.6. Algoritmo de la Función ImprimirDatos()</strong></p>
              <p>1.	Imprimir el valor de la variable ‘serie’ (valor de la serie aproximada).</p>
              
              <p><strong>3.3.7. Algoritmo de la Función main()</strong></p>
              <p>1.	Llamada a la función ImprimirMensajeInformacion().</p>
              <p>2.	Llamada a la función LeerDatos().</p>
              <p>3.	Asignar a la variable ‘x’ el valor que retorna la función ConvertirGradosARadianes().</p>
              <p>4.	Asignar a la variable ‘serie’ el valor que retorna la función SerieSeno().</p>
              <p>5.	Llamada a la función ImprimirDatos().</p>

              <h4><strong>D)   Implementación </strong></h4>
              <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 3.3.1 se muestra el código del programa en C/C++.</p>
              <h5><strong>Tabla 3.3.1:  </strong>Programa que calcula la serie de la función seno.</h5>
              <pre><code [highlight]="prefTab[0].programa2"  [lineNumbers]="true"></code></pre><br>
              <h4><strong>D.1.)   Explicación de las Funciones</strong></h4>
              <p><strong>3.3.8. Función ImprimirMensajeInformacion()</strong></p>
              <p>La Figura 3.3.2 muestra cómo trabaja la función ‘ImprimirMensajeInformacion()’, luego de ser declarada y definida. La llamada a la función ‘ImprimirMensajeInformacion()’ no envía argumentos a la función, pero cumple con la tarea de imprimir el mensaje de información: "Serie del Seno.", e imprime dos saltos de línea y no retorna ningún valor.</p>
              <img src="./assets/images/Capitulos/III/media/b19.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 3.3.2.  </strong>Llamada a la función sin parámetros y retorno de un void.</h5>
              <img src="./assets/images/Capitulos/III/media/b19.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 3.3.3.  </strong>Llamada a la función con dos parámetros y retorno de un void.</h5>
              <p><strong>3.3.9. Función LeerDatos()</strong></p>
              <p>La Figura 3.3.3 muestra cómo trabaja la función ‘LeerDatos()’, luego de ser declarada y definida. La llamada a la función ‘LeerDatos()’ envía dos argumentos a los parámetros de la función que son dos referencias, la misma que cumple con las tareas de lectura de datos y no retorna ningún valor.</p>
              
              <p><strong>3.3.10. Función ConvertirGradosARadianes()</strong></p>
              <p>La Figura 3.3.4 muestra cómo trabaja la función ‘ConvertirGradosARadianes()’, luego de ser declarada y definida. La llamada a la función ‘ConvertirGradosARadianes()’ envía un argumento por valor al parámetro de la función, la misma que cumple con la tarea de convertir un valor dado en grados a radianes y retorna ese valor calculado.</p>
              <img src="./assets/images/Capitulos/III/media/b20.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 3.3.4. </strong>Llamada a la función con un parámetro y retorno de un valor.</h5>
              <p><strong>3.3.11. Función Factorial()</strong></p>
              <p>La Figura 3.3.5 muestra cómo trabaja la función ‘Factorial()’, luego de ser declarada y definida. La llamada a la función ‘Factorial()’ envía un argumento por valor al parámetro de la función, la misma que cumple con la tarea de obtener el factorial de un número y retorna ese valor calculado.</p>
              <img src="./assets/images/Capitulos/III/media/b21.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 3.3.5. </strong>Llamada a la función con un parámetro y retorno de un valor.</h5>
              <p><strong>3.3.12. Función SerieSeno()</strong></p>
              <p>La Figura 3.3.6 muestra cómo trabaja la función ‘SerieSeno()’, luego de ser declarada y definida. La llamada a la función ‘SerieSeno()’ envía dos argumentos por valor a los parámetros de la función, la misma que cumple con la tarea de obtener el valor de la serie de la función seno(x) aproximada y retorna ese valor calculado.</p>
              <img src="./assets/images/Capitulos/III/media/b22.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 3.3.6. </strong>Llamada a la función con dos parámetros y retorno de un valor.</h5>
              <p><strong>3.3.14. Función ImprimirDatos()</strong></p>
              <p>La Figura 3.3.7 muestra cómo trabaja la función ‘ImprimirDatos()’, luego de ser declarada y definida. La llamada a la función ‘ImprimirDatos()’ envía un argumento por valor al parámetro de la función, la misma que cumple con las tareas de impresión de datos y no retorna ningún valor. En este caso la función ‘ImprimirDatos()’, imprime el valor de la serie numérica utilizando la variable ‘serie’.</p>
              <img src="./assets/images/Capitulos/III/media/b23.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 3.3.7. </strong>Llamada a la función con dos parámetros y retorno de un valor.</h5>
              
              <h4><strong>E) Pruebas </strong></h4>
              <p>En la Tabla 3.3.2, se muestra un ejemplo de la salida del programa, donde se puede ver que el resultado del programa tiene sentido, comparando este resultado con los datos devueltos por una calculadora científica.</p>
              <p>En la salida de la Tabla 3.3.2 se puede ver que, al ingresar el número de términos igual a 10 y el valor del ángulo en grados igual a 30, se obtiene el valor de la serie aproximada igual a 0.5.</p>
              
              <h5><strong>Tabla 3.3.2:  </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/III/media/b24.png" style="display:block; margin:auto; "><br>
              <p>En la Tabla 3.3.3, se muestra la prueba de escritorio del programa, donde se puede comprobar que en cada iteración del bucle for() de la función ‘SerieSeno()’ se acumula en la sumatoria ‘sum’ los valores parciales de la serie llamando a la función ‘Factorial()’, enviando el valor de (2i+1) utilizando un bucle for() que retorna el producto calculado que es el factorial de un número a la sumatoria ‘sum’ y la ejecución del bucle termina cuando la condición de esta sentencia se hace falsa y la función ‘SerieSeno()’, retorna el valor de la variable ‘sum’ a la llamada de la función que lo hace la variable ‘serie’. </p>
              <h5><strong>Tabla 3.3.3:  </strong>Salida del programa.</h5>
              <p><strong>a.	Primera iteración</strong></p>
              <img src="./assets/images/Capitulos/III/media/b25.png" style="display:block; margin:auto; "><br>
              <p><strong>b.	Segunda iteración</strong></p>
              <img src="./assets/images/Capitulos/III/media/b26.png" style="display:block; margin:auto; "><br>
              <p><strong>c.	Tercera iteración</strong></p>
              <img src="./assets/images/Capitulos/III/media/b27.png" style="display:block; margin:auto; "><br>
              <p><strong>d.	Cuarta iteración</strong></p>
              <img src="./assets/images/Capitulos/III/media/b28.png" style="display:block; margin:auto; "><br>
              <p><strong>e.	Quinta iteración</strong></p>
              <img src="./assets/images/Capitulos/III/media/b29.png" style="display:block; margin:auto; "><br>
              </ng-template>
            </mat-tab>
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Creación de Menús">
        <ng-template matTabContent>
          <h2><strong>Creación de Menús</strong></h2>
            <p>El menú de selección en un programa presenta al usuario un menú que lista un grupo de opciones que se pueden seleccionar. Si el usuario ingresa un número o una letra que corresponde a la lista de selección, luego se ejecuta una o más instrucciones en cada selección o caso del switch(). En un menú también se utiliza un bucle while() o do-while(), que permite repetir la selección del código mientras la expresión lógica del bucle sea verdadera (Dawson, M., 2008). El ejercicio 3.15 y el ejercicio 3.16, muestran dos plantillas muy prácticas que se pueden utilizar para crear un menú de opciones con números o con letras.</p>
            <h4><strong>Ejercicio 3.15: </strong>Escribir un programa que muestre la utilización de un menú con cuatro opciones utilizando números para su selección.</h4>
            <h5><strong>Programa 3.15: </strong>Programa que muestra el uso de un menú con números.</h5>
            <pre><code [highlight]="prefTab[0].programa3"  [lineNumbers]="true"></code></pre><br>
            <p>La sentencia switch() crea cinco posibles puntos de ramificación. Si el usuario ingresa el valor de 1, luego el código asociado con el caso 1 (case 1) se ejecuta y se imprime un mensaje. Si el usuario ingresa el valor de 2, luego el código asociado con el caso 2 (case 2) se ejecuta y se imprime un mensaje. Si el usuario ingresa el valor de 3, luego el código asociado con el caso 3 (case 3) se ejecuta y se imprime un mensaje. Si el usuario ingresa el valor de 4, luego el código asociado con el caso 4 (case 4) se ejecuta y se imprime un mensaje. Si el usuario ingresa el valor de 5, entonces se sale de la aplicación. En este menú se utiliza un bucle do-while(), que permite repetir la selección del código mientras la expresión lógica del bucle sea verdadera.</p>
            <h5><strong>Ejecución 3.15: </strong>Salida del programa.</h5>
            <img src="./assets/images/Capitulos/III/media/b30.png" style="display:block; margin:auto; "><br>
            <h4><strong>Ejercicio 3.16: </strong>Escribir un programa que muestre la utilización de un menú con cuatro opciones utilizando letras para su selección.</h4>
            <h5><strong>Programa 3.16: </strong>Programa que muestra el uso de un menú con letras.</h5>
            <pre><code [highlight]="prefTab[0].programa4"  [lineNumbers]="true"></code></pre><br>
            <p>La sentencia switch() crea cinco posibles puntos de ramificación. Si el usuario ingresa la letra ‘a’, luego el código asociado con el caso ‘a’ (case 'a') se ejecuta y se imprime un mensaje. Si el usuario ingresa la letra ‘b’, luego el código asociado con el caso ‘b’ (case 'b') se ejecuta y se imprime un mensaje. Si el usuario ingresa la letra ‘c’, luego el código asociado con el caso ‘c’ (case 'c') se ejecuta y se imprime un mensaje. Si el usuario ingresa la letra ‘d’, luego el código asociado con el caso ‘d’ (case 'd') se ejecuta y se imprime un mensaje. Si el usuario ingresa la letra ‘s’, entonces se sale de la aplicación. En este menú se utiliza un bucle do-while(), que permite repetir la selección del código mientras la expresión lógica del bucle sea verdadera.</p>
            <h5><strong>Ejecución 3.16.1: </strong>Salida del programa.</h5>
            <img src="./assets/images/Capitulos/III/media/b31.png" style="display:block; margin:auto; "><br>
            <h4><strong>Ejercicio 3.17: </strong>Reescribir el programa del Caso de Estudio 3.1, referente a encontrar la distancia, tiempo de vuelo y la altura alcanzada por un proyectil, utilizando menús y un solo archivo de código fuente.</h4>
            <h5><strong>Programa 3.17: </strong>Programa que muestra el uso de un menú con letras.</h5>
            <pre><code [highlight]="prefTab[0].programa5"  [lineNumbers]="true"></code></pre><br>
            <p>Desde la Tabla 3.17.1, hasta la Tabla 3.17.3, se muestran tres ejemplos de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
            <p>En la salida de la Tabla 3.17.1 se puede ver que, al seleccionar la opción 1 se puede calcular el valor de la distancia ‘d’, para lo cual se leen los valores de la velocidad ‘v’ y del ángulo de lanzamiento ‘theta’. En la salida de la Tabla 3.17.2 se puede ver que, al seleccionar la opción 2 se puede calcular el valor del tiempo ‘t’, para lo cual se leen los valores de la velocidad ‘v’ y del ángulo de lanzamiento ‘theta’. En la salida de la Tabla 3.17.3 se puede ver que, al seleccionar la opción 3 se puede calcular el valor de la altura ‘h’, para lo cual se leen los valores de la velocidad ‘v’ y del ángulo de lanzamiento ‘theta’.</p>
            <h5><strong>Ejecución 3.17.1: </strong>Salida del programa.</h5>
            <img src="./assets/images/Capitulos/III/media/b32.png" style="display:block; margin:auto; "><br>
            <h5><strong>Ejecución 3.17.2: </strong>Salida del programa.</h5>
            <img src="./assets/images/Capitulos/III/media/b33.png" style="display:block; margin:auto; "><br>
            <h5><strong>Ejecución 3.17.3: </strong>Salida del programa.</h5>
            <img src="./assets/images/Capitulos/III/media/b34.png" style="display:block; margin:auto; "><br>

          <mat-tab-group>
                   
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Archivos de Cabecera">
        <ng-template matTabContent>
          <mat-tab-group>
            <mat-tab  label="Introducción">
              <ng-template matTabContent>
                <h2>Introducción</h2>
                <p>De acuerdo con (Dawson, M., 2008), una de las metas del lenguaje C/C++ es separar los prototipos de las funciones (la declaración de las funciones) de la implementación de las funciones (definición de las funciones). La motivación de esta práctica de programación se basa en que el desarrollador debería ser capaz de utilizar los prototipos de las funciones sin conocer exactamente como estas funciones trabajan. Esto ocurre cuando el programador utiliza funciones que no han sido hechas por el mismo, como por ejemplo las funciones de la librería math.h o cmath.</p>
                <p>De acuerdo con (Luna, F., 2004), para separar los prototipos de las funciones de la implementación de las funciones, se utilizan dos archivos por separado: a) archivo de encabezado o header file (.h), para los prototipos de las funciones; b) archivo de código fuente o implementation file (.cpp), para la implementación de las funciones. Eventualmente, el código fuente es compilado en un archivo objeto (.obj) o en un archivo de librería (.lib). Una vez que se hace esto, uno puede distribuir el archivo de encabezado junto con el archivo objeto o el archivo de librería a otros programadores. Con el archivo de encabezado que contiene los prototipos de las funciones y con el archivo objeto o el archivo de librería que contiene la implementación de las funciones, las cuales son enlazadas dentro del proyecto por el enlazador o linker, el programador tiene todos los componentes necesarios para utilizar las funciones sin haber visto el archivo de implementación o código fuente (.cpp). Por ejemplo, usted puede utilizar las funciones de la librería math.h o cmath sin haber visto los archivos de implementación o código fuente (.cpp) que están protegidos.</p>
              </ng-template>
            </mat-tab>
            <mat-tab  label="3.7.1. Sentencias de Inclusión (Inclusion Guards)">
              <ng-template matTabContent>
                <p>Las sentencias de inclusión (inclusion guards) son sentencias o directivas de preprocesador que ejecuta directamente el compilador al compilar el código del programa (Luna, F., 2004).</p>
                <p>Cuando se trabaja con funciones, un archivo de cabecera (.h) contiene los prototipos de las funciones que se van a implementar en el archivo de código fuente (.cpp). El archivo de cabecera utiliza sentencias de inclusión como las siguientes:</p>
                <p>#ifndef ARCHIVO_H <br>
                  #define ARCHIVO_H <br>
                  … <br>
                  #endif // !ARCHIVO_H
                  </p>
                <p>La primera línea, #ifndef ARCHIVO_H, hace que el compilador pregunte si un símbolo llamado ARCHIVO_H no ha sido definido. Si no se ha definido, se compilará el código entre el código #ifndef y el código #endif, correspondiente a las sentencias de inclusión.</p>

                <h4><strong>Ejercicio 3.18: </strong>Reescribir el programa del Caso de Estudio 3.1, referente a encontrar la distancia, tiempo de vuelo y la altura alcanzada por un proyectil, utilizando menús, archivos de cabecera y archivos de código fuente.</h4>
                <p>El Programa 3.18.1, referente al archivo de cabecera “Operaciones.h” contiene los prototipos de las funciones que se van a implementar en el archivo de código fuente “Operaciones.cpp”. Este archivo de cabecera utiliza sentencias de inclusión como son las siguientes:</p>
                <p>#ifndef OPERACIONES_H <br>
                  #define OPERACIONES_H <br>
                  … <br>
                  #endif // !OPERACIONES_H
                  </p>
                <p>La primera línea, #ifndef OPERACIONES_H, hace que el compilador pregunte si un símbolo llamado OPERACIONES_H no ha sido definido. Si no se ha definido, se compilará el código entre el código #ifndef y el código #endif, correspondiente a las sentencias de inclusión.</p>
                <h5><strong>Programa 3.18.1: </strong>Archivo de cabecera “Operaciones.h”.</h5>
                <pre><code [highlight]="prefTab[0].programa6"  [lineNumbers]="true"></code></pre><br>
                <p>El Programa 3.18.2, referente al archivo de código fuente “Operaciones.cpp”, implementa las funciones declaradas en el archivo de cabecera “Operaciones.h”. En este archivo de código fuente se debe incluir el archivo de cabecera utilizando la sentencia #include "Operaciones.h". Luego, se incluyen las librerías (iostream), (cstdlib) y (cmath) para los diferentes cálculos matemáticos que se van a realizar en las diferentes funciones que se implementan en este archivo de código fuente. Además, se incluyen sentencias de preprocesador o macros para el valor de PI y de la gravedad ‘g’. Finalmente, se incluye el espacio de nombre std para utilizar las funciones cout y cin sin incluir el operador de ámbito de resolución (::).</p>
                <h5><strong>Programa 3.18.2:  </strong>Archivo de código fuente “Operaciones.cpp”.</h5>
                <pre><code [highlight]="prefTab[0].programa7"  [lineNumbers]="true"></code></pre><br>
                <p>El Programa 3.18.3, referente al archivo de código fuente “programa.cpp”, llama a las funciones del archivo de encabezado “Operaciones.h” que han sido implementadas dentro del archivo de código fuente “Operaciones.cpp”. El programa principal contiene un menú con seis opciones utilizando números para su selección.</p>
                <p>La sentencia switch() crea tres posibles puntos de ramificación. Si el usuario ingresa el valor de 1, luego el código asociado con el caso 1 (case 1) se ejecuta, que corresponde a la llamada a la función LeerDatos(), la llamada a la función de ConvertirGradosARadianes(), también se ejecuta la llamada a la función Distancia() y a la llamada a la función de ImprimirDistancia(). Si el usuario ingresa el valor de 2, luego el código asociado con el caso 2 (case 2) se ejecuta, que corresponde a la llamada a la función LeerDatos(), la llamada a la función de ConvertirGradosARadianes(), también se ejecuta la llamada a la función Tiempo() y a la llamada a la función de ImprimirTiempo(). Si el usuario ingresa el valor de 3, luego el código asociado con el caso 3 (case 3) se ejecuta, que corresponde a la llamada a la función LeerDatos(), la llamada a la función de ConvertirGradosARadianes(), también se ejecuta la llamada a la función Altura() y a la llamada a la función de ImprimirAltura(). Si el usuario ingresa el valor de 4, entonces se sale de la aplicación. En este menú se utiliza un bucle do-while(), que permite repetir la selección del código mientras la expresión lógica del bucle sea verdadera.</p>
                <h5><strong>Programa 3.18.3:  </strong>Archivo de código fuente “programa.cpp”.</h5>
                <pre><code [highlight]="prefTab[0].programa8"  [lineNumbers]="true"></code></pre><br>
                <p>Desde la Tabla 3.18.4, hasta la Tabla 3.18.6, se muestran tres ejemplos de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <p>En la salida de la Tabla 3.18.4 se puede ver que, al seleccionar la opción 1 se puede calcular el valor de la distancia ‘d’, para lo cual se leen los valores de la velocidad ‘v’ y del ángulo de lanzamiento ‘theta’. En la salida de la Tabla 3.18.5 se puede ver que, al seleccionar la opción 2 se puede calcular el valor del tiempo ‘t’, para lo cual se leen los valores de la velocidad ‘v’ y del ángulo de lanzamiento ‘theta’. En la salida de la Tabla 3.18.6 se puede ver que, al seleccionar la opción 3 se puede calcular el valor de la altura ‘h’, para lo cual se leen los valores de la velocidad ‘v’ y del ángulo de lanzamiento ‘theta’.</p>
                <h5><strong>Ejecución 3.18.4: </strong>Salida del programa.</h5>
                <img src="./assets/images/Capitulos/III/media/b35.png" style="display:block; margin:auto; "><br>
                <h5><strong>Ejecución 3.18.5: </strong>Salida del programa.</h5>
                <img src="./assets/images/Capitulos/III/media/b36.png" style="display:block; margin:auto; "><br>
                <h5><strong>Ejecución 3.18.6: </strong>Salida del programa.</h5>
                <img src="./assets/images/Capitulos/III/media/b37.png" style="display:block; margin:auto; "><br>

              </ng-template>
            </mat-tab>
            <mat-tab  label="Caso de Estudio 3.4">
              <ng-template matTabContent>
                <h2><strong>Caso de Estudio 3.4: Movimiento básico de una partícula a lo largo del eje ‘x’ con aceleración constante.</strong></h2>
                <h4><strong>A)   Problema</strong></h4>
                <p>Escribir un programa con funciones que automatice 5 ecuaciones básicas del movimiento de una partícula a lo largo del eje ‘x’ con aceleración constante, utilizadas en Cinemática Rectilínea. En la Tabla 3.4.1. se muestran estas 6 ecuaciones.</p>
                <h5><strong>Tabla 3.4.1. </strong>Ecuaciones del desplazamiento, de la velocidad media, de la aceleración media y del tiempo para el movimiento básico de una partícula bajo aceleración constante a lo largo del eje ‘x’.</h5>
                <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
                  <TR>
                    <TH>Número de ecuación</TH>
                    <TH>Ecuación</TH>
                    <TH>Información que se conoce por la ecuación</TH>
                  </TR>
                  <tbody *ngFor="let item of prefTab[0].tablaDatos2">
                  <TR style="text-align: left">
                    <TD>
                      <ul *ngFor="let i of item.item" style="list-style-type: none;">
                        <li>{{i}}</li>
                      </ul>
                    </TD>
                    <TD>
                      <ul *ngFor="let i of item.nota" style="list-style-type: none;">
                        <li>{{i}}</li>
                      </ul>
                    </TD>
                    <TD>
                      <ul *ngFor="let i of item.puntos" style="list-style-type: none;">
                        <li>{{i}}</li>
                      </ul>
                    </TD>
                  </TR>
                  </tbody>
                </TABLE><br>
                <p>En la Figura 3.4.1 se muestra el movimiento de una partícula a lo largo del eje ‘x’ con aceleración constante, tanto hacia adelante como en reversa.</p>
                <img src="./assets/images/Capitulos/III/media/b38.png" style="display:block; margin:auto; "><br>
                <h5><strong>Figura 3.4.1. </strong>Un auto va hacia adelante y en reversa a lo largo de una línea recta; a) Representación pictórica del movimiento del auto hacia adelante; b) Representación pictórica del movimiento del auto en reversa (Serway, R., Jewett, J., 2005).</h5>

                <h4><strong>B)   Análisis</strong></h4>
                <p>Claramente, se puede ver que las entradas del problema son la posición inicial de una partícula (X0), la posición final de una partícula (Xf), la velocidad media (Vm), el tiempo de movimiento de una partícula (t), la velocidad inicial de una partícula (V0), la velocidad final de una partícula (Vf). Hay cinco salidas requeridas: el desplazamiento (s), la posición final de una partícula (Xf), la velocidad media (Vm), el tiempo de movimiento de una partícula (t), la aceleración de una partícula (a). Partiendo de un conocimiento básico de Física, se sabe que hay cinco ecuaciones del desplazamiento, de la velocidad media, de la aceleración media y del tiempo para el movimiento básico de una partícula bajo aceleración constante a lo largo del eje ‘x’. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
                <h4><strong>B.1)   Requerimiento de los Datos</strong></h4>
                <p><strong>Entradas del Problema</strong></p>
                <p>X0 &nbsp; &nbsp; /* posición inicial */</p>
                <p>Xf &nbsp; &nbsp; /* posición final */</p>
                <p>Vm &nbsp; &nbsp; /* velocidad media */</p>
                <p>t &nbsp; &nbsp; /* tiempo */</p>
                <p>V0 &nbsp; &nbsp; /* velocidad inicial */</p>
                <p>Vf &nbsp; &nbsp; /* velocidad final */</p>
                <p>opcion &nbsp; &nbsp; /* opción a ser seleccionada del menú */</p>

                <p><strong>Salidas del Problema</strong></p>
                <p>s &nbsp; &nbsp; /* desplazamiento */</p>
                <p>Xf &nbsp; &nbsp; /* posición final */</p>
                <p>Vm &nbsp; &nbsp; /* velocidad media */</p>
                <p>t &nbsp; &nbsp; /* tiempo */</p>
                <p>a &nbsp; &nbsp; /* aceleración */</p>

                <p><strong>Fórmulas Relevantes</strong></p>
                <img src="./assets/images/Capitulos/III/media/b39.png" style="display:block; margin:auto; "><br>

                <p><strong>B.2) Diagrama de Entrada-Salida</strong></p>
                <p>En la Figura 3.4.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘X0’ (posición inicial), la variable ‘Xf’ (posición final), la variable ‘Vm’ (velocidad media), la variable ‘t’ (tiempo), la variable ‘V0’ (velocidad inicial), la variable ‘Vf’ (velocidad final), la variable ‘opcion’ (opción a ser seleccionada del menú); b) Salidas: la variable ‘s’ (desplazamiento), la variable ‘Xf’ (posición final), la variable ‘Vm’ (velocidad media), la variable ‘t’ (tiempo), la variable ‘a’ (aceleración).</p>
                <img src="./assets/images/Capitulos/III/media/b40.png" style="display:block; margin:auto; "><br>

                <p><strong>C)   Diseño</strong></p>
                <p>Una vez que se conocen las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                <p><strong>C.1)   Algoritmos</strong></p>
                <p><strong>3.4.1. Algoritmo de la Función LeerDatosDesplazamiento()</strong></p>
                <p>1.	Leer el valor de la posición inicial en [m], utilizando la referencia ‘X0’.</p>
                <p>2.	Leer el valor de la posición final en [m], utilizando la referencia ‘Xf’.</p>
                <p><strong>3.4.2. Algoritmo de la Función LeerDatosDesplazamiento()</strong></p>
                <p>1.	Leer el valor de la posición inicial en [m], utilizando la referencia ‘X0’.</p>
                <p>2.	Leer el valor de la velocidad media en [m/s], utilizando la referencia ‘Vm’.</p>
                <p>3.	Leer el valor del tiempo en [seg], utilizando la referencia ‘t’.</p>
                <p><strong>3.4.3. Algoritmo de la Función LeerDatosVelocidadMedia()</strong></p>
                <p>1.	Leer el valor de la posición inicial en [m], utilizando la referencia ‘X0’.</p>
                <p>2.	Leer el valor de la posición final en [m], utilizando la referencia ‘Xf’.</p>
                <p>3.	Leer el valor del tiempo en [seg], utilizando la referencia ‘t’.</p>
                <p><strong>3.4.4. Algoritmo de la Función LeerDatosVelocidadMedia()</strong></p>
                <p>1.	Leer el valor de la velocidad inicial en [m/s], utilizando la referencia ‘V0’.</p>
                <p>2.	Leer el valor de la velocidad final en [m/s], utilizando la referencia ‘Vf’.</p>

                <p><strong>3.4.5. Algoritmo de la Función LeerDatosTiempo()</strong></p>
                <p>1.	Leer el valor de la posición inicial en [m], utilizando la referencia ‘X0’.</p>
                <p>2.	Leer el valor de la posición final en [m], utilizando la referencia ‘Xf’.</p>
                <p>3.	Leer el valor de la velocidad media en [m/s], utilizando la referencia ‘Vm’.</p>
                <p><strong>3.4.6. Algoritmo de la Función LeerDatosAceleracion()</strong></p>
                <p>1.	Leer el valor de la velocidad inicial en [m/s], utilizando la referencia ‘V0’.</p>
                <p>2.	Leer el valor de la velocidad final en [m/s], utilizando la referencia ‘Vf’.</p>
                <p>3.	Leer el valor del tiempo en [seg], utilizando la referencia ‘t’.</p>
                <p><strong>3.4.7. Algoritmo de la Función Desplazamiento()</strong></p>
                <p>1.	Calcular el valor del desplazmiento como función de la posición.</p>
                <p>&nbsp; &nbsp; 1.1.	Retornar el valor de una expresión matemática que cumple con la fórmula del desplazamiento (1), según la Física Clásica.</p>
                
                <p><strong>3.4.8. Algoritmo de la Función Desplazamiento()</strong></p>
                <p>1.	Calcular el valor del desplazmiento como función de la velocidad media y el tiempo.</p>
                <p>&nbsp; &nbsp; 1.1.	Retornar el valor de una expresión matemática que cumple con la fórmula del desplazamiento (2), según la Física Clásica.</p>
                
                <p><strong>3.4.9. Algoritmo de la Función VelocidadMedia()</strong></p>
                <p>1.	Calcular el valor de la velocidad media como función de la posición y el tiempo.</p>
                <p>&nbsp; &nbsp; 1.1.	Retornar el valor de una expresión matemática que cumple con la fórmula de la velocidad media (3), según la Física Clásica.</p>
                <p><strong>3.4.10. Algoritmo de la Función VelocidadMedia()</strong></p>
                <p>1.	Calcular el valor de la velocidad media como función de la velocidad final y de la velocidad inicial.</p>
                <p>&nbsp; &nbsp; 1.1.	Retornar el valor de una expresión matemática que cumple con la fórmula de la velocidad media (4), según la Física Clásica.</p>
                <p><strong>3.4.11. Algoritmo de la Función Tiempo()</strong></p>
                <p>1.	Calcular el valor del tiempo como función de la posición y de la velocidad media.</p>
                <p>&nbsp; &nbsp; 1.1.	Retornar el valor de una expresión matemática que cumple con la fórmula del tiempo (5), según la Física Clásica.</p>
                <p><strong>3.4.12. Algoritmo de la Función Aceleracion()</strong></p>
                <p>1.	Calcular el valor de la aceleración como función de la velocidad final, de la velocidad inicial y del tiempo.</p>
                <p>&nbsp; &nbsp; 1.1.	Retornar el valor de una expresión matemática que cumple con la fórmula de la aceleración (6), según la Física Clásica.</p>
                <p><strong>3.4.13. Algoritmo de la Función ImprimirDatosDesplazamiento()</strong></p>
                <p>1.	Imprimir el valor de la variable ‘s’ (desplazamiento) en [m].</p>
                
                <p><strong>3.4.14. Algoritmo de la Función ImprimirDatosVelocidadMedia()</strong></p>
                <p>1.	Imprimir el valor de la variable ‘Vm’ (velocidad media) en [m/s].</p>
                
                <p><strong>3.4.15. Algoritmo de la Función ImprimirDatosTiempo()</strong></p>
                <p>1.	Imprimir el valor de la variable ‘t’ (tiempo) en [seg].</p>
                <p><strong>3.4.16. Algoritmo de la Función ImprimirDatosAceleracion()</strong></p>
                <p>1.	Imprimir el valor de la variable ‘a’ (aceleración) en [m/seg2].</p>
                <p><strong>3.4.8. Algoritmo de la Función main()</strong></p>
                <p>1.	Hacer:</p>
                <p>&nbsp; &nbsp; 1.1.	Limpiar la pantalla.</p>
                <p>&nbsp; &nbsp; 1.2.	Presentar el texto del menú que se verá cada vez.</p>
                <p>&nbsp; &nbsp; 1.3.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.1.	Imprimir el mensaje: “Movimiento básico de una partícula a lo largo del eje 'x'.”.</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.2.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.3.	Imprimir el mensaje: “1. Calcular el desplazamiento (s) conociendo: 'X0' y 'Xf'.”.</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.4.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.5.	Imprimir el mensaje: “2. Calcular el desplazamiento (Xf) conociendo: 'X0', 'Vm' y 't'.”.</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.6.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.7.	Imprimir el mensaje: “3. Calcular la velocidad media (Vm) conociendo: 'X0', 'Xf' y 't'.”.</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.8.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.9.	Imprimir el mensaje: “4. Calcular la velocidad media (Vm) conociendo: 'V0' y 'Vf'.”.</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.10.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.11.	Imprimir el mensaje: “5. Calcular el tiempo (t) conociendo: 'X0', 'Xf' y 'Vm'.”.</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.12.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.13.	Imprimir el mensaje: “6. Calcular la aceleración (a) conociendo: 'V0', 'Vf' y 't'.”.</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.14.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.15.	Imprimir el mensaje: “7. SALIR”.</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.16.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.17.	Leer una opción del menú, utilizando la variable ‘opcion’.</p>
                <p>&nbsp; &nbsp; &nbsp; 1.3.18.	Según sea el valor de la variable ‘opcion’, hacer:</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.1.	Caso 1:</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.1.1.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.1.2.	Llamada a la función LeerDatosDesplazamiento(), donde se envían tres argumentos que son la variable 'X0', la variable 'Vm' y la variable 't' y no se retorna ningún valor.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.1.3.	Llamada a la función Desplazamiento(), donde se envían tres argumentos que son la variable 'X0', la variable 'Vm' y la variable 't' y luego retorna a la variable 'Xf' el valor calculado.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.1.4.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.1.5.	Llamada a la función ImprimirDatosDesplazamiento(), que se envía como argumento el valor de la variable 'Xf' e imprime ese valor.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.1.6.	Generar una pausa.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.2.	Caso 2:</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.2.1.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.2.2.	Llamada a la función LeerDatosDesplazamiento(), donde se  envían dos argumentos que son la variable 'X0' y la variable 'Xf' y no se retorna ningún valor.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.2.3.	Llamada a la función Desplazamiento(), donde se envían dos argumentos que son la variable 'X0' y la variable 'Xf' y luego retorna a la variable 's' el valor calculado.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.2.4.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.2.5.	Llamada a la función ImprimirDatosDesplazamiento(), que se envía como argumento el valor de la variable 's' e imprime ese valor.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.2.6.	Generar una pausa.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.3.	Caso 3:</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.3.1.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.3.2.	Llamada a la función LeerDatosVelocidadMedia(), donde se  envían tres argumentos que son la variable 'X0', la variable 'Xf' y la variable 't' y no se retorna ningún valor.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.3.3.	Llamada a la función VelocidadMedia(), donde se envían tres argumentos que son la variable 'X0', la variable 'Xf' y la variable 't' y luego retorna a la variable 'Vm' el valor calculado.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.3.4.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.3.5.	Llamada a la función ImprimirDatosVelocidadMedia(), que se envía como argumento el valor de la variable 'Vm' e imprime ese valor.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.3.6.	Generar una pausa.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.4.	Caso 4:</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.4.1.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.4.2.	Llamada a la función LeerDatosVelocidadMedia(), donde se  envían dos argumentos que son la variable 'V0' y la variable 'Vf' y no se retorna ningún valor.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.4.3.	Llamada a la función VelocidadMedia(), donde se envían dos argumentos que son la variable 'V0' y la variable 'Vf' y luego retorna a la variable 'Vm' el valor calculado.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.4.4.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.4.5.	Llamada a la función ImprimirDatosVelocidadMedia(), que se envía como argumento el valor de la variable 'Vm' e imprime ese valor.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.4.6.	Generar una pausa.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.5.	Caso 5:</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.5.1.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.5.2.	Llamada a la función LeerDatosTiempo(), donde se envían tres argumentos que son la variable 'X0', la variable 'Xf' y la variable 'Vm' y no se retorna ningún valor.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.5.3.	Llamada a la función Tiempo(), donde se envían tres argumentos que son la variable 'X0', la variable 'Xf' y la variable 'Vm' y luego retorna a la variable 't' el valor calculado.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.5.4.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.5.5.	Llamada a la función ImprimirDatosTiempo(), que se envía como argumento el valor de la variable 't' e imprime ese valor.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.5.6.	Generar una pausa.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.6.	Caso 6:</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.6.1.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.6.2.	Llamada a la función LeerDatosAceleracion(), donde se envían tres argumentos que son la variable 'V0', la variable 'Vf' y la variable 't' y no se retorna ningún valor.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.6.3.	Llamada a la función AceleracionMedia(), donde se envían tres argumentos que son la variable 'V0', la variable 'Vf' y la variable 't' yluego retorna a la variable 'a' el valor calculado.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.6.4.	Imprimir un salto de línea (INTRO).</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.6.5.	Llamada a la función ImprimirDatosAceleracion(), que se envía como argumento el valor de la variable 'a' e imprime ese valor.</p>
                <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.3.18.6.6.	Generar una pausa.</p>
                <p>Mientras el valor de la variable ‘opcion’ sea diferente al valor de siete (opcion != 7).</p>

                <p><strong>D)   Implementación</strong></p>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. Desde la Tabla 3.4.2 hasta la Tabla 3.4.4, se muestra el código del programa en C/C++ con sus archivos de código fuente y su archivo de encabezado.</p>
                <p>La Tabla 3.4.2, referente al archivo de cabecera “Operaciones.h” contiene los prototipos de las funciones que se van a implementar en el archivo de código fuente “Operaciones.cpp”. Este archivo de cabecera utiliza sentencias de inclusión como son las siguientes:</p>
                <p>#ifndef OPERACIONES_H <br>
                  #define OPERACIONES_H <br>
                  … <br>
                  #endif // !OPERACIONES_H
                  </p>
                <p>La primera línea, #ifndef OPERACIONES_H, hace que el compilador pregunte si un símbolo llamado OPERACIONES_H no ha sido definido. Si no se ha definido, se compilará el código entre el código #ifndef y el código #endif, correspondiente a las sentencias de inclusión.</p>
                <h5><strong>Tabla 3.4.2. </strong>Archivo de cabecera “Operaciones.h”.</h5>
                <pre><code [highlight]="prefTab[0].programa9"  [lineNumbers]="true"></code></pre><br>
                <p>La Tabla 3.4.3, referente al archivo de código fuente “Operaciones.cpp”, implementa las funciones declaradas en el archivo de cabecera “Operaciones.h”. En este archivo de código fuente se debe incluir el archivo de cabecera utilizando la sentencia #include "Operaciones.h". Luego, se incluyen las librerías (iostream), (cstdlib) y (cmath) para los diferentes cálculos matemáticos que se van a realizar en las diferentes funciones que se implementan en este archivo de código fuente. Finalmente, se incluye el espacio de nombre std para utilizar las funciones cout y cin sin incluir el operador de ámbito de resolución (::).</p>
                <h5><strong>Tabla 3.4.3. </strong>Archivo de código fuente “Operaciones.cpp”.</h5>
                <pre><code [highlight]="prefTab[0].programa10"  [lineNumbers]="true"></code></pre><br>
                <p>La Tabla 3.4.3, referente al archivo de código fuente “programa.cpp”, llama a las funciones del archivo de encabezado “Operaciones.h” que han sido implementadas dentro del archivo de código fuente “Operaciones.cpp”. El programa principal contiene un menú con seis opciones utilizando números para su selección.</p>
                <p>La sentencia switch() crea seis posibles puntos de ramificación. Si el usuario ingresa el valor de 1, luego el código asociado con el caso 1 (case 1) se ejecuta, que corresponde a la llamada a la función LeerDatosDesplazamiento() con dos argumentos, la llamada a la función de Desplazamiento() con dos argumentos y también se ejecuta la llamada a la función ImprimirDatosDesplazamiento() con un argumento. Si el usuario ingresa el valor de 2, luego el código asociado con el caso 2 (case 2) se ejecuta, que corresponde a la llamada a la función LeerDatosDesplazamiento() con tres argumentos, la llamada a la función de Desplazamiento() con tres argumentos y también se ejecuta la llamada a la función ImprimirDatosDesplazamiento() con un argumento. Si el usuario ingresa el valor de 3, luego el código asociado con el caso 3 (case 3) se ejecuta, que corresponde a la llamada a la función LeerDatosVelocidadMedia() con tres argumentos, la llamada a la función de VelocidadMedia() con tres argumentos y también se ejecuta la llamada a la función ImprimirDatosVelocidadMedia() con un argumento. Si el usuario ingresa el valor de 4, luego el código asociado con el caso 4 (case 4) se ejecuta, que corresponde a la llamada a la función LeerDatosVelocidadMedia() con dos argumentos, la llamada a la función de VelocidadMedia() con dos argumentos y también se ejecuta la llamada a la función ImprimirDatosVelocidadMedia() con un argumento. Si el usuario ingresa el valor de 5, luego el código asociado con el caso 5 (case 5) se ejecuta, que corresponde a la llamada a la función LeerDatosTiempo() con tres argumentos, la llamada a la función de Tiempo() con tres argumentos y también se ejecuta la llamada a la función ImprimirDatosTiempo() con un argumento. Si el usuario ingresa el valor de 6, luego el código asociado con el caso 6 (case 6) se ejecuta, que corresponde a la llamada a la función LeerDatosAceleracion() con tres argumentos, la llamada a la función de AceleracionMedia() con tres argumentos y también se ejecuta la llamada a la función ImprimirDatosAceleracion() con un argumento. Si el usuario ingresa el valor de 7, entonces se sale de la aplicación. En este menú se utiliza un bucle do-while(), que permite repetir la selección del código mientras la expresión lógica del bucle sea verdadera.</p>
                <h5><strong>Tabla 3.4.3. </strong>Archivo de código fuente “programa.cpp”.</h5>
                <pre><code [highlight]="prefTab[0].programa11"  [lineNumbers]="true"></code></pre><br>

                <p><strong>E) Pruebas</strong></p>
                <p>Desde la Tabla 3.4.4, hasta la Tabla 3.4.9, se muestran seis ejemplos de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
                <p>En la salida de la Tabla 3.4.4 se puede ver que, al seleccionar la opción 1 se puede calcular el valor del desplazamiento ‘s’, para lo cual se leen los valores de la posición inicial ‘X0’ y de la posición final ‘Xf’. En la salida de la Tabla 3.4.5 se puede ver que, al seleccionar la opción 2 se puede calcular el valor del desplazamiento ‘Xf’, para lo cual se leen los valores de la posición inicial ‘X0’, de la velocidad media ‘Vm’ y del tiempo ‘t’. En la salida de la Tabla 3.4.6 se puede ver que, al seleccionar la opción 3 se puede calcular el valor de la velocidad media ‘Vm’, para lo cual se leen los valores de la posición inicial ‘X0’, de la posición final ‘Xf’ y del tiempo ‘t’. En la salida de la Tabla 3.4.7 se puede ver que, al seleccionar la opción 4 se puede calcular el valor de la velocidad media ‘Vm’, para lo cual se leen los valores de la velocidad inicial ‘V0’ y de la velocidad final ‘Vf’. Tabla 3.4.8 se puede ver que, al seleccionar la opción 5 se puede calcular el valor del tiempo ‘t’, para lo cual se leen los valores de la posición inicial ‘X0’, de la posición final ‘Xf’ y de la velocidad media ‘Vm’. Tabla 3.4.9 se puede ver que, al seleccionar la opción 6 se puede calcular el valor de la aceleración ‘a’, para lo cual se leen los valores de la velocidad inicial ‘V0’, de la velocidad final ‘Vf’ y del tiempo ‘t’.</p>
                <h5><strong>Tabla 3.4.4. </strong>Salida del programa.</h5>
                <img src="./assets/images/Capitulos/III/media/b41.png" style="display:block; margin:auto; "><br>
                <h5><strong>Tabla 3.4.5. </strong>Salida del programa.</h5>
                <img src="./assets/images/Capitulos/III/media/b42.png" style="display:block; margin:auto; "><br>
                <h5><strong>Tabla 3.4.6. </strong>Salida del programa.</h5>
                <img src="./assets/images/Capitulos/III/media/b43.png" style="display:block; margin:auto; "><br>
                <h5><strong>Tabla 3.4.7. </strong>Salida del programa.</h5>
                <img src="./assets/images/Capitulos/III/media/b44.png" style="display:block; margin:auto; "><br>
                <h5><strong>Tabla 3.4.8. </strong>Salida del programa.</h5>
                <img src="./assets/images/Capitulos/III/media/b45.png" style="display:block; margin:auto; "><br>
                <h5><strong>Tabla 3.4.9. </strong>Salida del programa.</h5>
                <img src="./assets/images/Capitulos/III/media/b45.png" style="display:block; margin:auto; "><br>
              </ng-template>
            </mat-tab>
            
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Resumen">
        <ng-template matTabContent>
          <ol>
            <li>Una función es un mini programa dentro de un programa, que contiene varias sentencias bajo un solo nombre, que un programa puede utilizar una o más veces para ejecutar dichas sentencias, llamando a la función.</li>
            <li>La estructura de una función contempla los siguientes puntos: a) tipo de retorno; b) nombre de la función; c) lista de parámetros; d) cuerpo de la función.</li>
            <li>Los problemas más importantes que resuelven las funciones son: a) duplicación de código; b) reutilización del código; c) mantención del código.</li>
            <li>Para utilizar adecuadamente las funciones dentro de los programas se deben considerar las siguientes observaciones: a) una función debe ser declarada o definidis antes de ser llamada; b) El prototipo de la función debe mantener la estrucutra de una función; c) Una función debe ser implementada después de habers ido definida; d) Una función puede ser definida sin necesidad de ser declarada, antes del programa principal.</li>
            <li>El paso de parámetros por valor o por copia, significa que una función recibe en sus parámetros una copia de los argumentos enviados, que solo pueden ser utilizados para diferentes cálculos, pero no pueden ser modificados sus valores.</li>
            <li>Las funciones pueden tener uno o varios parámetros, e incluso no tener parámetros. Una función puede ejecutar una o varias acciones utilizando sus parámetros y retornar al menos un valor, o no retornar ningún valor, en cuyo caso se dice que la función es un procedimiento o void.</li>
            <li>La Librería de Utilidades Generales Estándar (cstdlib), proporciona una función llamada rand(), que puede ser utilizada para generar números pseudo-aleatorios (pseudorandom). Para generar números aleatorios diferentes cada vez que se ejecuta un programa se utiliza de manera conjunta la función time() con la función srand(), donde el valor retornado por la función time() se pasa como parámetro a la función srand().</li>
            <li>Para utilizar números aleatorios dentro de un rango específico como por ejemplo [a, b], se debe utilizar la siguiente fórmula: <br> valor = a + rand() % ((b + 1) - a);	Ec. 3.1.</li>  
            <li>La sobrecarga de funciones se basa en que puede haber varias funciones con el mismo nombre, pero con diferente firma. La firma de la función incluye el nombre de la función y la lista de parámetros, pero no incluye el tipo de retorno.</li>
            <li>Una referencia es un alias de una variable, donde por ejemplo, dada una referencia R a una variable A, se puede directamente acceder a la variable A con la referencia R, por lo que se dice que la referencia R se refiere a la variable A.</li>
            <li>Se pueden retornar múltiples valores con referencias, por lo que las referencias permiten manipular las variables originales a las cuales se refieren, lo que se conoce como paso de parámetros por referencias.</li>
            <li>Un puntero es una variable especial que almacena la dirección de memoria de una variable, para poder manipular el contenido de la variable a la que apunta.</li>
            <li>El operador de dirección (&) es un operador unario que se utiliza tanto para almacenar la dirección de memoria de una variable, así como también para devolver la dirección de memoria de su operando.</li>
            <li>El operador de indirección (*) es un operador unario que, a más de ser utilizado como el operador de multiplicación, cumple con otras dos funciones muy importantes: a) Para declarar o crear un puntero; b) Para devolver una expresión equivalente al valor contenido en la dirección apuntada por un puntero.</li>
            <li>En el lenguaje C/C++, cuando se trabajan con variables y punteros se puede hablar del 'rvalue' y del 'lvalue' de una variable, donde: a) El 'lvalue' de una variable es la dirección de memoria (localidad) donde la variable está almacenada; b) El 'rvalue' de una variable es el dato (contenido real) que la variable tiene. En otras palabras, es el valor de la variable.</li>
            <li>Se pueden retornar múltiples valores con punteros, por lo que los punteros permiten manipular las variables a las cuales apuntan, lo que se conoce como paso de parámetros por dirección o por punteros.</li>
            <li>Existe una gran variedad de funciones matemáticas en la librería de Encabezado de Funciones Matemáticas (cmath), sin embargo, este número de funciones son limitadas, por lo que se pueden crear librerías propias de funciones matemáticas aplicadas a la vida real y a otras áreas de las ciencias del saber.</li>
            <li>El menú de selección en un programa presenta al usuario un menú que lista un grupo de opciones que se pueden seleccionar. Si el usuario ingresa un número o una letra que corresponde a la lista de selección, luego se ejecuta una o más instrucciones en cada selección o caso del switch(). En un menú también se utiliza un bucle while() o do-while(), que permite repetir la selección del código mientras la expresión lógica del bucle sea verdadera.</li>
            <li>Una de las metas del lenguaje C/C++ es separar los prototipos de las funciones (la declaración de las funciones) de la implementación de las funciones (definición de las funciones). La motivación de esta práctica de programación se basa en que el desarrollador debería ser capaz de utilizar los prototipos de las funciones sin conocer exactamente como estas funciones trabajan.</li>
            <li>Dado el archivo de cabecera conocido como archivo objeto (.obj) o el archivo de librería (.lib), otros programadores son capaces de utilizar sus funciones sin haber visto como fueron implementadas en el archivo de código fuente (.cpp). Esto cumple con dos tareas: 1) Otros programadores no serán capaces de modificar la implementación de las funciones; 2) Su implementación es protegida como una propiedad intelectual.</li>
            <li>Las sentencias de inclusión (inclusion guards) son sentencias o directivas de preprocesador que ejecuta directamente el compilador al compilar el código del programa.</li>
          </ol>
        </ng-template>
      </mat-tab>
    </mat-tab-group>

    <button mat-button (click)="selectTabNext()" *ngIf="positionCurrentNext">{{titleNext}} <mat-icon>navigate_next</mat-icon></button>
    <button mat-button (click)="selectTabBefore()" *ngIf="positionCurrentBefore"><mat-icon>navigate_before</mat-icon> Atras  &nbsp; &nbsp; &nbsp;&nbsp;</button>

</div>
<!-- Examples
<mat-tab label="Teoría">
  <ng-template matTabContent>
    <br>
    <h1>5.1.   OpenTK</h1>
    <p>OpenTK (Open Toolkit), es un conjunto de APIs gráficas desarrolladas para C#. Estas APIs son portátiles en varios sistemas operativos (OS) y rápidas en el momento de ejecutarse. OpenTK, tiene un conjunto de clases y librerías de bajo nivel para OpenGL, OpenGL ES, OpenAL y OpenCL, ya que parte del core (núcleo) de OpenTK está construido en C/C++. OpenTK, se ejecuta en todas las plataformas principales como Windows, Linux y MAC. Además, potencia el desarrollo de cientos de aplicaciones gráficas, juegos en 2D y 3D y programas de investigación matemática y científica (De Vries, J., Perks, D., 2021).</p>
    <p>OpenTK proporciona varias bibliotecas de utilidades, incluido un paquete de matemáticas y álgebra lineal, un sistema de ventanas y manejo de entrada de datos. OpenTK no es un motor de juegos, ni intenta serlo: ofrece un conjunto útil de herramientas y permite decidir cómo usarlas en diferentes tipos de aplicaciones. Además, es el punto de partida ideal si se desea escribir un juego o un motor de juegos y también una aplicación científica desde cero (De Vries, J., Perks, D., 2021).</p>
    <p>De acuerdo con (De Vries, J., Perks, D., 2021), las principales APIs de OpenTK son:</p>
    <ul>
      <li>OpenTK.Audio.OpenAL</li>
      <li>OpenTK.Compute.Native</li>
      <li>OpenTK.Compute.OpenCL</li>
      <li>OpenTK.Core</li>
      <li>OpenTK.Graphics</li>
      <li>OpenTK.Input.Hid</li>
      <li>OpenTK.Mathematics</li>
      <li>OpenTK.Platform.Windows</li>
    </ul>
    <h1>5.1.1. OpenGL, OpenCL y OpenAL</h1>
    <p>OpenGL es una biblioteca de representación de gráficos por computadora multiplataforma, desarrollada originalmente por Silicon Graphics (SGI) y ahora mantenida por el grupo Khronos. OpenGL se usa para todo, desde videojuegos hasta herramientas CAD, navegadores web y teléfonos móviles.</p>
    <p>OpenCL es una especificación de computación paralela multiplataforma, desarrollada originalmente por Apple y ahora mantenida por el grupo Khronos. Se utiliza principalmente para realizar cálculos en GPU que, de otro modo, se calcularían de forma menos eficiente en CPU, pero también se puede utilizar para controlar procesadores de señales digitales (DSP), matrices de puertas programables en campo (FPGA) y otros tipos de aceleradores de cálculo de hardware.</p>
    <p>OpenAL es una biblioteca de audio 3D multiplataforma, desarrollada originalmente por Loki Software y lanzada como una especificación abierta por Creative Labs, con múltiples implementaciones tanto en hardware como en software. OpenAL se usa en muchos juegos para proporcionar efectos de sonido y música y es el sucesor de EAX y A3D.</p>
    <h1>5.1.2. Clases y Métodos Principales de OpenTK para la Graficación de Figuras Geométricas en 2D y 3D</h1>
    <h1>5.1.2.1.	Class GameWindow</h1>
    <p>La clase GameWindow contiene métodos multiplataforma para crear y renderizar en una ventana OpenGL, manejar la entrada y cargar recursos (Ramos, F., 2014). En la Tabla 5.1, se muestra un ejemplo de código fuente para esta clase, donde se define una ventana de resolución de 500×500, dentro del programa principal (void Main).</p>
    <h5><strong>Tabla 5.1. </strong>Ejemplo de código fuente para la clase GameWindow.</h5><br>
    <pre *ngFor="let formula of introduccion"><code [highlight]="formula.f1" (highlighted)="onHighlight($event)" [lineNumbers]="true"></code></pre><br>
    <h1>5.1.2.2.	Class Game</h1>
    <p>La clase Game contiene métodos para: a) Constructor/es de la clase Game; b) Arrancar una aplicación gráfica; c) Redimensionar una ventana; d) Renderizar los frames de la aplicación gráfica; e) Inicializar la carga de la aplicación gráfica. La estructura básica de la clase Game se muestra en la Tabla 5.2.</p>
    <h5><strong>Tabla 5.2. </strong>Estructura básica de la clase game.</h5><br>
    <pre *ngFor="let formula of introduccion"><code [highlight]="formula.f2" (highlighted)="onHighlight($event)" [lineNumbers]="true"></code></pre><br>
    <p>En los Pracniques resueltos 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8 , 5.9 y 5.10, se muestran algunos ejemplos prácticos de cómo graficar figuras geométricas en 2D y 3D, como se indica a continuación:</p>
    <ul>
      <li>Pracnique 5.1: Triángulo de 3 colores.</li>
      <li>Pracnique 5.2: Cuadrado de 4 colores rotando.</li>
      <li>Pracnique 5.3: Cubo de 6 colores con doble rotación.</li>
      <li>Pracnique 5.4: Dos cubos de diferente tamaño rotando.</li>
      <li>Pracnique 5.5: Un cubo y una pirámide rotando.</li>
      <li>Pracnique 5.6: Cubo manejado por teclado.</li>
      <li>Pracnique 5.7: Cubo con luces.</li>
      <li>Pracnique 5.8: Cubo con textura.</li>
      <li>Pracnique 5.9: Cubo con textura y cuadrado transparente.</li>
      <li>Pracnique 5.10: Cono rotando.</li>
    </ul>
    <p>La estructura de los Pracniques se basa en una adaptación del trabajo de Wirth, M., (2013), para lo cual los autores de este trabajo plantean las siguientes fases para el diseño, desarrollo e implementación de programas enfocados a la Computación Gráfica:              a) Sinopsis; b) Descripción del Problema; c) Geometría de la Figura; d) Algoritmos; e) Código de la Aplicación; f) Pruebas de la Aplicación. </p>
    <p>Los Pracniques resueltos son una adaptación del trabajo de The Pentamollis Project, (2017), que es un canal de YouTube que presenta un Curso Básico de OpenTK con C#, compuesto por 10 video tutoriales. </p>
    <p>El análisis matemático y geométrico tanto 2D como 3D de las diferentes figuras geométricas, fue adaptado de los trabajos de Ammeraal, L., Zhang, K., (2017), Lengyel, E., (2011), Mortenson, M.E., (1999). Este análisis forma parte de la fase de Geometría de la Figura que se implementa en los diferentes pracniques.</p>
  </ng-template>
</mat-tab>
<mat-tab label="Video Tutorial">
  <ng-template matTabContent>
    <br>
    <div class="social-item">
      <h2><b><u>Pracnique 5.3 - Cubo de 6 Colores con Doble Rotación <a href="https://youtu.be/ne2OyOv5Z_4" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></b></h2>
    </div>
    <div class="video-responsive">
      <div class="video-responsive">
        <iframe width="560" height="315" src="https://www.youtube.com/embed/ne2OyOv5Z_4?rel=0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
      </div>
    </div>

    <br>
    <div class="social-item">
      <h2><b><u>Pracnique 5.8 - Cubo con Textura con Rotación Constante <a href="https://youtu.be/RHaH62cmnmc" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></b></h2>
    </div>
    <div class="video-responsive">
      <div class="video-responsive">
        <iframe width="560" height="315" src="https://www.youtube.com/embed/RHaH62cmnmc?rel=0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
      </div>
    </div>

    <br>
    &lt;!&ndash;            <div class="social-item">
                        <h2><b><u>Pracnique 5.10 - Cono con Rotación controlada por Teclado <a href="#" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></b></h2>
                    </div>
                    <div class="video-responsive">
                        <div class="video-responsive">
                            <video controls preload="auto">
                                <source src="https://drive.google.com/uc?export=download&id=1Tq3Vu004_iBChLVLFPoKo2gXWZQAfVXn#t=1" type="video/mp4" />
                                    Tu navegador no soporta HTML5 Video
                                </video>
                        </div>
                    </div>
    &ndash;&gt;                <br>
    <div>
      <h1><b>Curso Completo OpenGL and C# tutorial | The OpenTK Library</b></h1>
      <ul>
        <li><h2><u>Pracnique 5.1 - Triángulo de 3 colores <a href="https://www.youtube.com/watch?v=xBR6ZIJAuXc" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></h2></li>
        <li><h2><u>Pracnique 5.2 - Cuadrado de 4 colores rotando <a href="https://www.youtube.com/watch?v=xBR6ZIJAuXc" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></h2></li>
        <li><h2><u>Pracnique 5.4 - Dos cubos de diferente tamaño rotando <a href="https://www.youtube.com/watch?v=xBR6ZIJAuXc" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></h2></li>
        <li><h2><u>Pracnique 5.5 - Un cubo y una pirámide rotando <a href="https://www.youtube.com/watch?v=xBR6ZIJAuXc" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></h2></li>
        <li><h2><u>Pracnique 5.6 - Cubo manejado por teclado <a href="https://www.youtube.com/watch?v=xBR6ZIJAuXc" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></h2></li>
        <li><h2><u>Pracnique 5.7 - Cubo con luces <a href="https://www.youtube.com/watch?v=xBR6ZIJAuXc" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></h2></li>
        <li><h2><u>Pracnique 5.9 - Cubo con textura y cuadrado transparente <a href="https://www.youtube.com/watch?v=xBR6ZIJAuXc" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></h2></li>
      </ul>
    </div>
  </ng-template>
</mat-tab>
<mat-tab label="Pracniques">
  <ng-template matTabContent>
    <mat-tab-group>
      &lt;!&ndash; <mat-tab *ngFor="let tab of asyncTabs | async"> &ndash;&gt;
      <mat-tab *ngFor="let tab of praqnique" label="{{tab.label}}">
        <br>
        <table>
          <tr>
            <td>
              <h2 style="color:green;"><strong>{{tab.tituloN}}</strong></h2>
            </td>
            <td>
              <h2>{{tab.titulo}}</h2>
            </td>
          </tr>
        </table>
        <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
          <TR>
            <TABLE>
              <TR><strong>SINOPSIS</strong></TR>
              <TR>{{tab.sinopsisDescrip}}</TR>
            </TABLE>
          </TR>
          <TR>
            <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
              <TR *ngFor="let item of tab.sinopsis">
                <TD><strong>{{item.titulo}}</strong>{{item.descrip}}</TD>
              </TR>
            </TABLE>
          </TR>
        </TABLE><br>
        <a href="{{tab.link}}" download="ProgramaPracnique">
          <mat-icon>save_alt</mat-icon><strong>Descargar {{tab.tituloN}} PracniqueCompGraf.zip</strong>
        </a>
        <br><br>
        <h3><strong>{{tab.A.subtitulo}}</strong></h3>
        <p>{{tab.A.problema}}</p>
        <img src="{{tab.A.fotoPath}}" style="display:block; margin:auto;"><br>
        <h5><strong>{{tab.A.fotoN}}</strong>{{tab.A.fotoDescrip}}</h5><br>

        <h3><strong>{{tab.B.subtitulo}}</strong></h3>
        <div *ngFor="let itemPasos of tab.B.pasosB">
          <mathjax [content]=itemPasos.parrafo class='box'></mathjax>
          <img src="{{itemPasos.fotoPath}}" style="display:block; margin:auto; ">
          <h5><strong>{{itemPasos.fotoN}}</strong>{{itemPasos.fotoDescrip}}</h5><br>
        </div>

        <h3><strong>{{tab.C.subtitulo}}</strong></h3>
        <dl *ngFor="let itemAlgoritmos of tab.C.algoritmosC">
          <dt>{{itemAlgoritmos.titulo}}</dt>
          <dd>
            <ul *ngFor="let p of itemAlgoritmos.pasos; index as i">
              <div value="{{i+1}}">{{p}}</div>
            </ul>
            <ul *ngFor="let p of itemAlgoritmos.pasosFormulas; index as i">
              <div value="{{i+1}}">{{p}}</div>
            </ul>
          </dd>
        </dl>
        <h3><strong>{{tab.D.subtitulo}}</strong></h3>
        <div *ngFor="let itemCodigos of tab.D.listaCodigo">
          <p>{{itemCodigos.problema}}</p>
          <h5><strong>{{itemCodigos.tablaN}}</strong>{{itemCodigos.tablaDescrip}}</h5><br>
          <pre><code [highlight]="itemCodigos.tablaDatos" (highlighted)="onHighlight($event)" [lineNumbers]="true"></code></pre><br>
        </div>
        <h3><strong>{{tab.E.subtitulo}}</strong></h3>
        <div *ngFor="let item of tab.E.listaPrueba">
          <p>{{item.problema}}</p>
          <img src="{{item.fotoPath}}" style="display:block; margin:auto; width: 30%;"><br>
          <h5><strong>{{item.fotoN}}</strong>{{item.fotoDescrip}}</h5><br>
        </div>
      </mat-tab>
    </mat-tab-group>
  </ng-template>
</mat-tab>
<mat-tab label="Pracniques Propuestos">
  <ng-template matTabContent>
    <mat-tab-group>
      &lt;!&ndash; <mat-tab *ngFor="let tab of asyncTabs | async"> &ndash;&gt;
      <mat-tab *ngFor="let tab of praqniquePropuesto" label="{{tab.label}}">
        <br>
        <table>
          <tr>
            <td>
              <h2 style="color:green;"><strong>{{tab.tituloN}}</strong></h2>
            </td>
            <td>
              <h2>{{tab.titulo}}</h2>
            </td>
          </tr>
        </table>
        <h3><strong>{{tab.subtitulo}}</strong></h3>
        <div *ngFor="let item of tab.listaGeneral">
          <div *ngFor="let i of item.listaParrafoFotos">
            <mathjax [content]=i.problema class='box'></mathjax><br>
            <img src="{{i.fotoPathp1}}" style="display:block; margin:auto; width: 50%;"><br>
            <img src="{{i.fotoPath}}" style="display:block; margin:auto; width: 50%;"><br>
            <h5><strong>{{i.fotoN}}</strong>{{i.fotoDescrip}}</h5><br>
          </div>
        </div>
      </mat-tab>
    </mat-tab-group>
  </ng-template>
</mat-tab>
<mat-tab label="Evaluación">
  <ng-template matTabContent>
    <div class="Evaluacion">
      <app-quiz [propagarNumCapitulo]="num_capitulo"></app-quiz>
    </div>
  </ng-template>
</mat-tab>
<mat-tab label="Juegos">
  <ng-template matTabContent>
    <div class="Snake">
      <app-snake></app-snake>
    </div>
  </ng-template>

</mat-tab>
<mat-tab label="Resumen">
  <ng-template matTabContent>
    <br>
    <h1>Resumen</h1>
    <ul>
      <li>OpenTK (Open Toolkit), es un conjunto de APIs gráficas desarrolladas para C#. Estas APIs son portátiles en varios sistemas operativos (OS) y rápidas en el momento de ejecutarse.</li>
      <li>OpenTK, brinda acceso a herramientas gráficas contenidas en OpenGL, OpenCL y OpenAL, con una variedad de lenguajes basados en CLR como C# y F# entre otros.</li>
      <li>OpenTK proporciona varias bibliotecas de utilidades, incluido un paquete de matemáticas y álgebra lineal, un sistema de ventanas y manejo de entrada de datos. </li>
      <li>Las principales APIs de OpenTK son: a) OpenTK.Audio.OpenAL;                              b) OpenTK.Compute.Native; c) OpenTK.Compute.OpenCL; d) OpenTK.Core;   e) OpenTK.Graphics; f) OpenTK.Input.Hid; g) OpenTK.Mathematics;                      h) OpenTK.Platform.Windows.</li>
      <li>OpenGL es una biblioteca de representación de gráficos por computadora multiplataforma, desarrollada originalmente por Silicon Graphics (SGI) y ahora mantenida por el grupo Khronos.</li>
      <li>OpenCL es una especificación de computación paralela multiplataforma, desarrollada originalmente por Apple y ahora mantenida por el grupo Khronos.</li>
      <li>OpenAL es una biblioteca de audio 3D multiplataforma, desarrollada originalmente por Loki Software y lanzada como una especificación abierta por Creative Labs, con múltiples implementaciones tanto en hardware como en software.</li>
      <li>La clase GameWindow contiene métodos multiplataforma para crear y renderizar en una ventana OpenGL, manejar la entrada y cargar recursos.</li>
      <li>La clase Game contiene métodos para: a) Constructor/es de la clase Game; b) Arrancar una aplicación gráfica; c) Redimensionar una ventana; d) Renderizar los frames de la aplicación gráfica; e) Inicializar la carga de la aplicación gráfica.</li>
    </ul>
  </ng-template>
</mat-tab>
<mat-tab label="Bibliografía">
  <ng-template matTabContent>
    <br>
    <h1>Bibliografía</h1>
    <ul>
      <li>Woo, M., Neider, J., Davis, T., Shreiner, D., 2005. OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 2 (The Red Book). Addison-Wesley, 5th Edition. ISBN-13: 978-0321335739. </li>
      <li>Shreiner, D., 2005. OpenGL: Reference Manual (The Blue Book). Addison-Wesley, 4th Edition. ISBN-13: 978-0321173836.</li>
      <li>Vidani, P., 2021. Silicon Graphics / SGI Vintage Stuff. Blog sgihardware-tumblr. Disponible en: https://sgihardware.tumblr.com/</li>
      <li>Kahle, B., Gilliat, B., 2001. SGI-Newsroom. Wayback Machine. Disponible en: https://web.archive.org/web/*/sgi</li>
      <li>Silicon Graphics-Wikipedia, 2021. Wikipedia. La enciclopedia libre. Fundación Wikimedia. Contenido multimedia bajo Licencia Creative Commons CC-BY-SA, 2001. Disponible en: https://es.wikipedia.org/wiki/Silicon_Graphics </li>
      <li>Tao Framework-Wikipedia, 2021. Wikipedia. La enciclopedia libre. Fundación Wikimedia. Contenido multimedia bajo Licencia Creative Commons CC-BY-SA, 2001. Disponible en: https://en.wikipedia.org/wiki/Tao_Framework </li>
      <li>OpenTK-Wikipedia, 2021. Wikipedia. La enciclopedia libre. Fundación Wikimedia. Contenido multimedia bajo Licencia Creative Commons CC-BY-SA, 2001. Disponible en: https://en.wikipedia.org/wiki/OpenTK </li>
      <li>De Vries, J., Perks, D., 2021. OpenTK. Tutoriales, Recursos, API, GitHub. Disponible en: https://opentk.net/</li>
      <li>The Pentamollis Project, 2017. OpenGL and C# Tutorial. The OpenTK Library. Canal de Youtube. Curso compuesto por 10 videotutoriales. Disponible en: https://www.youtube.com/watch?v=jb_gHLl1dgU&list=PLWzp0Bbyy_3ggUK3XZjBmwnSjhbhJH3kp</li>
      <li>Ramos, F., 2014. Pro OpenGL for C# Developers: High-Performance 2D and 3D Graphics for Deskto´p, Web, iOS and Android. Apress, United States. ISBN: 978-1-4842-0051-3.</li>
      <li>Ammeraal, L., Zhang, K., 2017. Computer Graphics for Java Programmers. Springer. Third Edition.</li>
      <li>Lengyel, E., 2011. Mathematics for 3D Game Programming and Computer Graphics. Charles River Media. Third Edition.</li>
      <li>Mortenson, M.E., 1999. Mathematics for Computer Graphics Applications. Industrial Press, Inc.; Second Edition. ISBN: 978-0831131111.</li>
      <li>Wirth, M., 2013. The Craft of Coding. Musing on Programming. Pracniques (Programming Case Studies). Available in: https://craftofcoding.wordpress.com/pracniques/, last accessed 2021/10/11.</li>
      <li>Kronos Group, 2006. OpenGL Documentation. Copyright © 1991-2006 Silicon Graphics, Inc. Disponible en: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml</li>
      <li>Hock-Chuan, C., 2012. 3D Graphics with OpenGL by Examples. Available in: https://www3.ntu.edu.sg/home/ehchua/programming/opengl/CG_Examples.html </li>
      <li>Korthals Altes, G., 1998. Paper Models of Polyhedra. Available in: https://www.polyhedra.net/es/model.php?name-en=pyramids-of-the-same-height</li>
    </ul>
  </ng-template>
</mat-tab>-->
