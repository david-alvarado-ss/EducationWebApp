<div style="margin: 50px;">
    <ng-container *ngIf="(asyncTabs | async) === null">
        Loading tabs...
    </ng-container>
    <table>
        <tr>
            <td>
                <h1><b> CAPÍTULO 3: FUNCIONES, REFERENCIAS Y PUNTEROS</b></h1>
            </td>
            <td></td>
            <td>
                <a href="https://drive.google.com/uc?id=1PnpCw4kNw5BSiBiLZegfyEU4fMXhjpjJ&export=download" download="Capitulo12021">
                    <mat-icon>cloud_download</mat-icon>Descargar Archivo Capítulo III
                </a>
            </td>
        </tr>
    </table>

    <mat-tab-group [selectedIndex]="selectedIndex.value" (selectedIndexChange)="selectedIndex.setValue($event)">
        <mat-tab label="Introducción">
            <ng-template matTabContent>
              <br><h1>Introducción</h1>
              <p>En este capítulo se aprenderá a diseñar funciones con algoritmos y a utilizar la computadora como una herramienta para resolver problemas creando programas con funciones, referencias y punteros en el lenguaje C/C++. Para la solución de problemas de programación se aplican aspectos de Ingeniería de Software y el método científico que permiten identificar a la programación con un enfoque sistemático. </p>
            <p>En un programa estructurado el flujo lógico se puede optimizar con el uso de funciones, referencias y punteros que es parte de la programación modular. El estudio de las funciones se realiza en base al paso de parámetros por valor, por referencia y por dirección. La aplicación de funciones para crear programas se lo hace con un lenguaje estructurado y modular como es el Lenguaje C/C++.</p>   
            </ng-template>
        </mat-tab>

        <mat-tab label="Objetivos">
            <ng-template matTabContent>
              <br><h1>Objetivos</h1>
              <ul>
                <li>Revisar los principales conceptos en torno a funciones con algoritmos y con estructuras de control.</li>
                <li>Entender cómo trabajan las funciones, las referencias, los punteros y cómo se aplican con el lenguaje C/C++ en la construcción de programas.</li>
                <li>Aprender a manejar el paso de parámetros por valor, por referencia y por dirección con algoritmos en Pseudocódigo y en Lenguaje C/C++.</li>
                <li>Diseñar y crear programas en lenguaje C/C++ utilizando funciones, referencias y punteros.</li>
                <li>Resolver casos de estudio con funciones, referencias y punteros aplicados al área matemática</li>
              </ul>
            </ng-template>
        </mat-tab>
      <mat-tab label="Función">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="Introducción">
              <ng-template matTabContent>
                <br><h1>Función</h1>
                <p>Una función es un mini programa dentro de un programa. Las funciones contienen varias sentencias bajo un solo nombre, que un programa puede utilizar una o más veces para ejecutar dichas sentencias (Granizo, E., 2016). Una función es una unidad de código diseñada para ejecutar una cierta tarea. Una función típica recibe algo de información y retorna algo de información. El concepto de una función es algo similar a una función matemática. Considere el caso de la función <i>sen(x)</i>, la cual toma un parámetro ‘x’ y evalúa o retorna algún valor, esto es el seno de ‘x’.</p>
                <p>La utilidad de las funciones puede ser fácilmente demostrada si consideramos un programa sin el uso de ellas, como el siguiente:</p>
                <h4><b>Ejercicio 3.1: </b>Escribir un programa sin utilizar funciones que calcule el área de un rectángulo para los siguientes valores de ancho y largo: a) ancho: 7; largo: 2; b) ancho: 9; largo: 5; c) ancho: 8; largo: 4; ingresados desde el teclado en forma seguida, es decir, uno a continuación de otro.</h4>
                <h5><b>Programa 3.1: </b>Programa sin funciones.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_1"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.1 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.1.png" style="display:block; margin:auto; "><br>
                    
               </ng-template>
            </mat-tab>
            <mat-tab  label="3.1.1.   Estructura de una Función">
              <ng-template matTabContent>
                <br><h1>Estructura de una Función</h1>
                <p>De acuerdo con (Joyanes Aguilar, L., Zahonero Martínez, I., 2005), para definir o crear una función en C/C++ se deben considerar los siguientes puntos:</p>
                <ol type="A">
                  <li><b><i>Tipo de retorno: </i></b>Es el tipo de valor devuelto por la función (el valor que la función evalúa) o la palabra reservada <b>“void”</b> si la función no devuelve ningún valor.</li>
                  <li><b><i>Nombre: </i></b>Es el identificador al cual hace referencia la función</li>
                  <li><b><i>Lista de parámetros: </i></b>Son los valores que se toman como entrada. Esta lista de declaraciones de los parámetros de la función van separadas por comas.</li>
                  <li><b><i>Cuerpo: </i></b>Es el código que se ejecuta cuando la función es invocada y puede consistir de variables locales, sentencias ejecutables y la palabra reservada “return” acompañada por una expresión lógica, relacional o matemática, siempre y cuando tenga un tipo de retorno la función.</li>
                </ol>
                <p>La Figura 3.1 muestra dos ejemplos referentes a la estructura de una función.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.1.jpg" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 3.1. </b>Estructura de una función; a) Función Potencia(); b) Función FarenheitACelcius().</h5>
              </ng-template>
            </mat-tab>

            <mat-tab  label="3.1.2.   Implementación de una Función">
              <ng-template matTabContent>
                <br><h1>Implementación de una Función</h1>
                <p>De acuerdo con (Granizo, E., 2016), la siguiente sintaxis despliega la forma de la definición o implementación de una función:</p>
             <p><b>sintaxis:</b></p><pre><code>
  Tipo_de_retorno Nombre_Función(Lista_de_Parámetros)
  &#65115;
        // Cuerpo de la función
        // Variables locales
        // Sentencias ejecutables
        // return(expresión)
  &#65116;  
</code></pre>
<p>La Figura 3.2 muestra un ejemplo de la sintaxis de cómo trabaja una función, cuando se la ha definido:</p>
<img src="./assets/images/Capitulos/III/media/Figura 3.2.png" style="display:block; margin:auto; "><br>
<h5 style="text-align:center"><b>Figura 3.2. </b>Definición de una función.</h5>
            
<h4><b>Ejercicio 3.2: </b>Escribir un programa utilizando la definición de una función, de tal manera que se calcule el área de un rectángulo para los siguientes valores de ancho y largo: a) ancho: 7; largo: 2; b) ancho: 9; largo: 5; c) ancho: 8; largo: 4; ingresados desde el teclado en forma seguida, es decir, uno a continuación de otro.</h4>
                <h5><b>Programa 3.2: </b>Programa sin funciones.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_2"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.2 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.2.png" style="display:block; margin:auto; "><br>
                   


</ng-template>
            </mat-tab>

            <mat-tab  label="3.1.3.   Problemas que Resuelven las Funciones">
              <ng-template matTabContent>
<br><h1>Problemas que Resuelven las Funciones</h1>
                <p>De acuerdo con (Deitel, H., Deitel, P., 2003), los problemas más importantes que resuelven las funciones son:</p>
                <ol type="A">
                  <li><b><i>Duplicación de código: </i></b>Al utilizar funciones ya no es necesario volver a escribir tanto código de nuevo, como en el ejercicio 3.2 a diferencia del ejercicio 3.1 que necesita mucho más código.</li>
                  <li><b><i>Reutilización del código: </i></b>Las funciones permiten utilizar una y otra vez y las veces que se requiera una función solo invocándola o llamándola desde cualquier parte de un programa.</li>
                  <li><b><i>Mantención del código: </i></b>El uso de funciones permite dar mantenimiento y actualizar el código de un programa más fácilmente.</li>
                </ol>
              </ng-template>
            </mat-tab>

            <mat-tab  label="3.1.4.   Uso de Funciones">
              <ng-template matTabContent>
                <br><h1>Uso de Funciones</h1>
                <p>De acuerdo con (Luna, F., 2004), para utilizar adecuadamente las funciones dentro de los programas se deben considerar las siguientes observaciones:</p>
              <ol type="A">
                <li>Una función debe ser declarada o definida antes de ser llamada o invocada, para que el compilador pueda reconocerla en la llamada a ésta.</li>
                <li>La declaración de una función (conocida también como el prototipo de la función) consiste del tipo de retorno, el nombre de la función y la lista de parámetros terminando la sentencia con un punto y coma.</li>
                <li>Una vez que una función ha sido declarada, puede ser definida o implementada en cualquier parte del programa. La definición de la función de la función contiene el cuerpo de la función y consiste del código que especifica lo que actualmente hace la función.</li>
                <li>Una función puede ser definida sin necesidad de ser declarada, antes del programa principal o antes de la llamada a la misma.</li>
                
              </ol>
              
              <br><h4><b>Ejercicio 3.3: </b>Escribir un programa utilizando la declaración y la definición de una función, de tal manera que se calcule el área de un rectángulo para los siguientes valores de ancho y largo: a) ancho: 7; largo: 2; b) ancho: 9; largo: 5; c) ancho: 8; largo: 4; ingresados desde el teclado en forma seguida, es decir, uno a continuación de otro.</h4>
              <h5><b>Programa 3.3: </b>Programa con funciones, utilizando la declaración y la definición de una función.</h5>
                  <pre><code [highlight]="prefTabs3[0].programa3_3"  [lineNumbers]="true"></code></pre>
                 <br> <h5><b>Ejecución 3.3 </b>Salida del programa.</h5>
                  <img src="./assets/images/Capitulos/III/media/Ejecucion 3.3.png" style="display:block; margin:auto; "><br>
            </ng-template>
            </mat-tab>

          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Paso de Parámetros por Valor">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="Introducción">
              <ng-template matTabContent>
                <br><h1>Paso de Parámetros por Valor</h1>
                <p>El paso de parámetros por valor o por copia, significa que cuando el compilador de C/C++ compila la función y el código que invoca o llama a la función, ésta recibe una copia de los valores de los parámetros. Si dentro de la función se cambia el valor de un parámetro que viene a ser una variable local de la misma, el cambio sólo afecta a la función y no tiene efecto fuera de ella (Granizo, E., 2016). </p>
                <p>Con el paso de parámetros por valor sólo se pueden operar con los parámetros de la función mas no modificar los contenidos de las variables que se envían a la función que son los argumentos que se copian o se asignan a los parámetros de la función.</p>
                <p>Un parámetro no es un valor por sí mismo, más bien es un valor propietario de un lugar para una variable. Esto significa que cuando la función es invocada o llamada en algún lugar del programa se envía una variable que toma el nombre del argumento que es el valor pasado dentro de la llamada de una función en particular y el parámetro de la función recibe una copia de la variable original que se envía como argumento a la misma.</p>
              </ng-template>
            </mat-tab>
            <mat-tab  label="3.2.1. Funciones sin Parámetros">
              <ng-template matTabContent>
                <br><h1>Funciones sin Parámetros</h1>
                <p>Las funciones pueden no tener parámetros, lo que significa que solamente pueden ejecutar ciertas tareas y dependiendo del tipo de retorno, devolver un valor o retornar un ‘void’ si la función no devuelve ningún valor (Luna, F., 2004).</p>
                <p>La función <font face="Consolas"><b>CalcularAreaRectangulo()</b></font> del programa 3.3, 
                  es un ejemplo del uso de funciones sin parámetros, donde esta función lee el valor del ancho y del largo del rectángulo, calcula el valor del área del rectángulo y retorna el valor del cálculo del área del rectángulo, como se puede ver en la Figura 3.3.</p>
                  <pre><code [highlight]="prefTabs3[0].Figura3_3"  [lineNumbers]="true"></code></pre>
                  <h5 style="text-align:center"><b>Figura 3.3. </b>Ejemplo de una función sin parámetros</h5>
 
                </ng-template>
            </mat-tab>
            <mat-tab  label="3.2.2. Funciones con un Parámetro">
              <ng-template matTabContent>
                <br><h1>Funciones con un Parámetro</h1>
                <p>Las funciones pueden tener un parámetro, donde el valor que se envía a la función se conoce como argumento, donde la función recibe una copia de la variable original, la cual solo puede ser utilizada, mas no modificada (Luna, F., 2004). En el programa 3.4, se muestra un ejemplo del manejo de funciones con un parámetro.</p>
                <h4><b>Ejercicio 3.4: </b>Escribir un programa utilizando funciones que calcule el cubo de tres números, ingresados desde el teclado en forma seguida, utilizando la declaración y la definición de una función.</h4>
                <h5><b>Programa 3.4: </b>Función con un parámetro, que calcula el cubo de tres números.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_2"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.4: </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.4.png" style="display:block; margin:auto; "><br>
  <p>La Figura 3.4 muestra un ejemplo de cómo trabaja la 
    función <font face="Consolas">QuintaPotenciaDeUnNumero()</font>, luego de ser declarada y definida.
     La llamada a la función <font face="Consolas">QuintaPotenciaDeUnNumero()</font> envía un argumento a un parámetro de la función, la misma que hace el cálculo de la quinta potencia de un número y retorna ese valor calculado a la llamada de la función. Se puede pensar que una función es una máquina separada donde se alimenta de datos de entrada (se copian los argumentos dentro de los parámetros), 
    luego hace algo con esos parámetros (cuerpo de la función) y a la salida se obtiene un resultado (retorna algo a la llamada de la función). Las funciones permiten a los programas organizar el código en partes más manejables, donde cada parte ejecuta una tarea específica.</p>
    <img src="./assets/images/Capitulos/III/media/Figura 3.4.png" style="display:block; margin:auto; "><br>       
    <h5 style="text-align:center"><b>Figura 3.4. </b>Llamadas a las funciones con parámetros y retorno de resultados.</h5>
 
              </ng-template>
            </mat-tab>

            <mat-tab  label="3.2.3. Funciones con Varios Parámetros">
              <ng-template matTabContent>
                <br><h1>Funciones con Varios Parámetros</h1>
                <p>Las funciones pueden tener varios parámetros, ya que no están limitadas a tener cero parámetros o un solo parámetro (Luna, F., 2004). En el programa 3.5, se muestra un ejemplo del manejo de funciones con varios parámetros. </p>
                <h4><b>Ejercicio 3.5: </b>Escribir un programa utilizando funciones que lea e imprima los valores de tres vectores en el espacio, donde cada vector se compone de tres componentes (x, y, z).</h4>
                <h5><b>Programa 3.2: </b>Función con varios parámetros.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_5"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.5 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.5.png" style="display:block; margin:auto; "><br>            
              </ng-template>
            </mat-tab>

            <mat-tab  label="3.2.4. Funciones de la Librería de Números Aleatorios">
              <ng-template matTabContent>
                <br><h1>Funciones de la Librería de Números Aleatorios</h1>
                <p>La Librería de Utilidades Generales Estándar (C Standard General Utilities Library) del lenguaje C/C++ (<font color="blue">#include </font> <font color="Red">&lt;cstdlib&gt;</font>), proporciona una función llamada <font face="Consolas"><b>rand()</b></font>, que puede ser utilizada para generar números pseudo-aleatorios (pseudorandom). Esta función retorna un número entero aleatorio dentro de un rango [0, MAX_RANGO], donde MAX_RANGO es algún valor predefinido por el programador, como por ejemplo un valor constante (Dawson, M., 2008). </p>
                <p>Para generar números aleatorios diferentes cada vez que se ejecuta un programa se utiliza de manera conjunta la función <font face="Consolas"><b>time()</b></font> con la función <font face="Consolas"><b>srand()</b></font>, donde el valor retornado por la función <font face="Consolas"><b>time()</b></font> se pasa como parámetro a la función <font face="Consolas"><b>srand()</b></font>, de la siguiente manera:</p>
<pre><code>
  srand(time(0));
</code></pre>
                <p>La función <font face="Consolas"><b>time()</b></font> pertenece a la Librería de Tiempo (C Time Library) del lenguaje C/C++ (<font color="blue">#include </font> <font color="Red">&lt;ctime&gt;</font>). Esta función retorna la cantidad de segundos transcurridos desde la medianoche, acorde al sistema del reloj (Stroustrup, B., 1997).</p>
                <p>La función <font face="Consolas"><b>srand()</b></font>pertenece a la Librería de Utilidades Generales Estándar (C Standard General Utilities Library) del lenguaje C/C++ (<font color="blue">#include </font> <font color="Red">&lt;cstdlib&gt;</font>). Esta función se utiliza como punto de entrada para generar números aleatorios conocida como la semilla generadora de números pseudo-aleatorios. A esta función se la debe llamar solamente una vez en el programa (Stroustrup, B., 1997).</p>
                <h4><b>Ejercicio 3.6: </b>Considerando que la resolución mínima de la pantalla del computador para el sistema operativo Windows 7, Windows 8, Windows 8.1 y Windows 10 es 1024 x 768 píxeles; escribir un programa que primeramente imprima los datos iniciales de la posición del ratón (mouse) en la coordenada (0, 0) y luego imprima la posición del ratón (mouse) de manera aleatoria en alguna parte de la pantalla del computador. Los prototipos de las funciones que se deben implementar son:</h4>
                <table><tr><td><p><font face="Consolas" color="blue">void </font><font face="Consolas" color="black">ImprimirDatosInicialesRaton</font>(<font face="Consolas" color="blue">int </font>x, <font face="Consolas" color="blue">int </font> y);</p>
                  <p><font face="Consolas" color="blue">int </font><font face="Consolas" color="black">ObtenerPosicionXRaton</font>();</p>
                  <p><font face="Consolas"color="blue">int </font><font face="Consolas" color="black">ObtenerPosicionYRaton</font>();</p>
                  <p><font face="Consolas" color="blue">void </font><font face="Consolas" color="black">ImprimirPosicionRaton</font>(<font face="Consolas" color="blue">int </font>x, <font face="Consolas" color="blue">int </font> y);</p>
                </td></tr></table>
                <h5><b>Programa 3.6: </b>Función con varios parámetros.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_6"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.6 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.6.png" style="display:block; margin:auto; "><br>            
             <br><h1>3.2.4.1. Especificación del Rango de un Número Aleatorio</h1>
                <p>Generalmente, se utilizan números aleatorios generados dentro del rango [0, MAX_RANGO], pero hay ocasiones en las que el programador necesita generar un rango diferente, como por ejemplo el rango [3, 18]. Para este tipo de casos, se puede generalizar la obtención de un número aleatorio dentro del rango [a, b], donde el valor de ‘a’ representa al límite inferior del rango y el valor de ‘b’ representa al límite superior del rango, utilizando la siguiente fórmula propuesta por (Luna, F., 2004):</p>
                <table align="right">
                  <td width="350"><font face="Consolas">valor = a + rand() % ((b + 1) - a);</font></td>
                <td align="right" width="200">Ec. 3.1.</td>
                </table><br>    
              <p>Así por ejemplo, si se quiere obtener números aleatorios dentro del rango [3, 18], se reemplazan dichos valores en la Ec. 3.1 y se obtiene la siguiente expresión:</p>
            <p style="text-align:center"><font face="Consolas">valor = 3+rand() % ((18+1)-3 );</font></p>  
            <p style="text-align:center"><font face="Consolas">valor = 3+rand() % 16;</font></p>  
            
            <h4><b>Ejercicio 3.7: </b>Escribir un programa que genere 10 números aleatorios dentro del rango [5, 20]. El prototipo de la función que se debe implementar es:</h4>
            <p><font face="Consolas" color="blue">void </font><font face="Consolas">ImprimirDatosAleatorios();</font></p>
            <p>Para resolver este ejercicio se aplica la Ec. 3.2.1, para calcular el valor del rango:</p>
            <p style="text-align:center"><font face="Consolas">valor = 5+rand() % ((20+1)-5 );</font></p>  
            <p style="text-align:center"><font face="Consolas">valor = 5+rand() % 17;</font></p>  
            <h5><b>Programa 3.7: </b>Función con varios parámetros.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_7"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.7 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.7.png" style="display:block; margin:auto; "><br>
  

          </ng-template>
            </mat-tab>
           
            <mat-tab  label="3.2.5. Sobrecarga de Funciones">
              <ng-template matTabContent>
                <br><h1>Sobrecarga de Funciones</h1>
                <p>Algunas veces se requiere dos o más versiones de una misma función (Ceballos, F.J., 2007). Por ejemplo, supongamos que se requieren dos funciones que calculen el área de un rectángulo: a) La primera función CalcularAreaRectangulo(), no tiene parámetros, lee los datos del rectángulo y calcula el valor del área; b) La segunda función CalcularAreaRectangulo(), tiene dos parámetros, calcula el valor del área y retorna ese valor calculado, como se indican en los siguientes prototipos de las funciones sobrecargadas:</p>
                <p><font face="Consolas" color="blue">float </font><font face="Consolas">CalcularAreaRectangulo();</font></p>
                <p><font face="Consolas" color="blue">float </font><font face="Consolas">CalcularAreaRectangulo(</font><font face="Consolas" color="blue">float </font><font face="Consolas">ancho, </font><font face="Consolas" color="blue">float </font><font face="Consolas">largo);</font></p>
                <p>Ambas versiones, para el compilador son correctas y solo difieren en la <b><i>firma de la función</i></b>. La firma de la función incluye el nombre de la función y la lista de parámetros, pero no incluye el tipo de retorno.</p>
             <p>La Tabla 3.1 muestra la implementación de la función de la primera versión y la Tabla 3.2 muestra la implementación de la función de la segunda versión.</p>
             <h5><b>Tabla 3.1: </b>Primera versión de la función Area().</h5>
                    <pre><code [highlight]="prefTabs3[0].tabla3_1"  [lineNumbers]="true"></code></pre>
            <h5><b>Tabla 3.2: </b>Segunda versión de la función Area(Lista_Parámetros).</h5>
                  <pre><code [highlight]="prefTabs3[0].tabla3_2"  [lineNumbers]="true"></code></pre>
            <br>
                  <h4><b>Ejercicio 3.8: </b>Re-escribir el programa del ejercicio 3.3 utilizando sobrecarga de funciones. En el primer y segundo cálculo del área del rectángulo utilizar la primera versión de la función sobrecargada y para el tercer cálculo utilizar la segunda versión de la función sobrecargada. Además, implementar la función ImprimirDatos (Lista_Parámetros), que imprime el valor del área calculada, cuyo prototipo de la función es:</h4>
            <p><font face="Consolas" color="blue">void </font><font face="Consolas">ImprimirDatos(</font><font face="Consolas" color="blue">float </font><font face="Consolas">area); </font></p>
                
            <h5><b>Programa 3.8: </b>Programa con funciones, utilizando la declaración y la definición de una función.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_8"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.8 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.8.png" style="display:block; margin:auto; "><br>
  
 
              </ng-template>
            </mat-tab>

          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Referencias">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="Introducción">
              <ng-template matTabContent>
                <br><h1>Referencias</h1>
                <p>Una referencia es un alias de una variable (Luna, F., 2004). Por ejemplo, dada una referencia R a una variable A, se puede directamente acceder a la variable A con la referencia R, por lo que se dice que la referencia R se refiere a la variable A. Para crear una referencia se debe considerar los siguientes puntos:</p>
                <ol type="a"><li>Especificar el tipo de la variable a la cual se referirá la referencia.</li>
                  <li>Utilizar el operador unario de dirección (&).</li>
                  <li>Utilizar un nombre para la referencia.</li>
                  <li>Seguida con una inicialización, la cual especifica la variable a la cual la referencia se referirá.</li>
              </ol>
                
                <p>Una referencia permite manipular la variable original a la cual se refiere, por lo tanto, puede ser utilizada para modificar el valor de la variable original para realizar operaciones de lectura y diferentes cálculos.</p>
             <p>A continuación, se presentan algunos ejemplos que muestran la creación de referencias referenciadas a variables:</p>
             <p><font color="green">// Variables</font></p>
             <p><font face="Consolas" color="blue">int </font><font face="Consolas">c + 7;</font></p>
             <p><font face="Consolas" color="blue">char </font><font face="Consolas">letra = </font><font face="Consolas" color="red">'M' </font><font face="Consolas">; </font></p>
             <p><font face="Consolas" color="blue">bool </font><font face="Consolas">veracidad = </font><font face="Consolas" color="blue">true </font><font face="Consolas">; </font></p>
             <p><font face="Consolas" color="blue">float </font><font face="Consolas">ex = exp(2.0);</font></p>
            <br>
            <p><font color="green">// Referencias ref a variables</font></p>
             <p><font face="Consolas" color="blue">int </font><font face="Consolas">&ref = c;</font></p>
             <p><font face="Consolas" color="blue">char </font><font face="Consolas">&ref = letra; </font>/p>
             <p><font face="Consolas" color="blue">bool </font><font face="Consolas">&ref = veracidad; </font></p>
             <p><font face="Consolas" color="blue">float </font><font face="Consolas">&ref = ex;</font></p>
            <br><h4><b>Ejercicio 3.9: </b>Escribir un programa donde se crea una variable con el valor de 7 y a continuación se crea una referencia a esa variable. Luego, imprimir el valor de la variable y el contenido de la referencia. Después, modificar el contenido de la referencia con el número 70. Finalmente, imprimir nuevamente el contenido de la variable y el contenido de la referencia:</h4>
            <h5><b>Programa 3.9: </b>Programa con referencias, utilizando la declaración y la definición de una referencia.</h5>
                <pre><code [highlight]="prefTabs3[0].programa3_9"  [lineNumbers]="true"></code></pre>
               <br> <h5><b>Ejecución 3.9: </b>Salida del programa.</h5>
                <img src="./assets/images/Capitulos/III/media/Ejecucion 3.9.png" style="display:block; margin:auto; "><br>
              <p>Como se puede ver en el programa 3.9, al ser la referencia un alias de una variable, el momento en que se modifica el contenido de la referencia, automáticamente se modifica el valor de la variable referenciada por esa referencia.</p>

              </ng-template>
            </mat-tab>
            <mat-tab  label="3.3.1.   Paso de Parámetros por Referencias">
              <ng-template matTabContent>
                <br><h1>Paso de Parámetros por Referencias</h1>
                <p>Se pueden retornar múltiples valores con referencias, por lo que las referencias permiten manipular las variables originales a las cuales se refieren, lo que se conoce como paso de parámetros por referencias (Luna, F., 2004). En esta sección se realizarán algunos ejercicios para realizar operaciones de lectura y cálculos matemáticos para modificar los valores de las variables originales utilizando referencias.</p>
                <h4><b>Ejercicio 3.10: </b>Escribir un programa con funciones y referencias que permita invertir dos números utilizando una variable auxiliar. Los prototipos de las funciones son:</h4>

                <p><font face="Consolas" color="blue">void </font><font face="Consolas">LeerDatos(</font><font face="Consolas" color="blue">int </font><font face="Consolas">&x, </font><font face="Consolas" color="blue">int </font><font face="Consolas">&y); </font></p>
                <p><font face="Consolas" color="blue">void </font><font face="Consolas">Invertir(</font><font face="Consolas" color="blue">int </font><font face="Consolas">&x, </font><font face="Consolas" color="blue">int </font><font face="Consolas">&y); </font></p>
                <p><font face="Consolas" color="blue">void </font><font face="Consolas">ImprimirDatos( </font><font face="Consolas" color="blue">int </font><font face="Consolas">x, </font><font face="Consolas" color="blue">int </font><font face="Consolas">y); </font></p>
               <br>
               <ol type="a">
                <li>El programa utilizará la función LeerDatos(), que permitirá leer dos valores enteros utilizando 2 referencias para manipular las variables. </li>
                <li>El programa utilizará la función Invertir(), que permitirá invertir dos valores numéricos utilizando 2 referencias y una variable auxiliar.</li>
                <li>El programa utilizará la función ImprimirDatos(), que permitirá imprimir dos valores numéricos, utilizando paso de parámetros por valor o por copia.</li>
                
               </ol>
          
          <h5><b>Programa 3.10: </b>Programa con referencias, utilizando la declaración y la definición de una referencia.</h5>
          <pre><code [highlight]="prefTabs3[0].programa3_10"  [lineNumbers]="true"></code></pre>
         <br> <h5><b>Ejecución 3.10: </b>Salida del programa.</h5>
          <img src="./assets/images/Capitulos/III/media/Ejecucion 3.10.png" style="display:block; margin:auto; "><br>

                <p>Como se puede ver en el programa 3.10, se implementaron dos funciones que utilizan el paso de parámetros por referencia: a) 
                  <font face="Consolas" color="blue">void</font> LeerDatos(
                    <font face="Consolas" color="blue">int </font>&x, 
                    <font face="Consolas" color="blue">int</font>&y); b) 
                    <font face="Consolas" color="blue">void </font> Invertir(
                      <font face="Consolas" color="blue">int </font>&x, 
                      <font face="Consolas" color="blue">int </font>&y); y se implementó una función que utiliza el paso de parámetros por valor: a) 
                      <font face="Consolas" color="blue">void </font> ImprimirDatos(
                  <font face="Consolas" color="blue">int </font>x, 
                  <font face="Consolas" color="blue">int </font>y).</p>
                  
                  <h4><b>Ejercicio 3.11: </b>Escribir un programa con funciones y referencias que permita ordenar tres números flotantes tomados de dos en dos. Los prototipos de las funciones son:</h4>

                  <p><font face="Consolas" color="blue">void </font><font face="Consolas">LeerDatos(</font><font face="Consolas" color="blue">float </font><font face="Consolas">&n1, </font><font face="Consolas" color="blue">float </font><font face="Consolas">&n2, </font><font face="Consolas" color="blue">float </font><font face="Consolas">&n3); </font></p>
                  <p><font face="Consolas" color="blue">void </font><font face="Consolas">ordenar(</font><font face="Consolas" color="blue">float </font><font face="Consolas">&menor, </font><font face="Consolas" color="blue">float </font><font face="Consolas">&mayor); </font></p>
                  <p><font face="Consolas" color="blue">void </font><font face="Consolas">ImprimirDatos( </font><font face="Consolas" color="blue">float </font><font face="Consolas">n1, </font><font face="Consolas" color="blue">float </font><font face="Consolas">n2, </font><font face="Consolas" color="blue">float </font><font face="Consolas">n3); </font></p>
                 <br>
                 <ol type="a"
                 >
                 <li>El programa utilizará la función LeerDatos(), que permitirá leer tres valores enteros utilizando 3 referencias para manipular las variables. </li>
                 <li>El programa utilizará la función Ordenar(), que permitirá ordena números de dos en dos utilizando 2 referencias y una variable auxiliar.</li>
                 <li>El programa utilizará la función ImprimirDatos(), que permitirá imprimir 3 valores numéricos, utilizando paso de parámetros por valor o por copia.</li>
                 </ol>
            
            <h5><b>Programa 3.11: </b>Programa con referencias, utilizando la declaración y la definición de una referencia.
              </h5>
            <pre><code [highlight]="prefTabs3[0].programa3_11"  [lineNumbers]="true"></code></pre>
           <br> <h5><b>Ejecución 3.11: </b>Salida del programa.</h5>
            <img src="./assets/images/Capitulos/III/media/Ejecucion 3.11.png" style="display:block; margin:auto; "><br>
  
                  <p>Como se puede ver en el programa 3.11, se implementaron dos funciones que utilizan el paso de parámetros por referencia: a) 
                    <font face="Consolas" color="blue">void</font> LeerDatos(
                      <font face="Consolas" color="blue">float </font>&n1, 
                      <font face="Consolas" color="blue">float </font>&n2,
                      <font face="Consolas" color="blue">float </font>&n3); b) 
                      <font face="Consolas" color="blue">void </font> Irdenar(
                        <font face="Consolas" color="blue">float </font>&menor, 
                        <font face="Consolas" color="blue">float </font>&mayor); y se implementó una función que utiliza el paso de parámetros por valor: a) 
                        <font face="Consolas" color="blue">void </font> ImprimirDatos(
                    <font face="Consolas" color="blue">float </font>n1, 
                    <font face="Consolas" color="blue">float </font>n2,  
                    <font face="Consolas" color="blue">int </font>n3).</p>
             
                  </ng-template>
            </mat-tab>

          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Punteros">
        <ng-template matTabContent>
          <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="Introducción">
              <ng-template matTabContent>
                <br><h1>Punteros</h1>
                <p>Un puntero es una variable especial que almacena la dirección de memoria de una variable, para poder manipular el contenido de la variable a la que apunta (Granizo, E., 2016). Como cualquier tipo de variable, un puntero debe haber sido declarado antes de que pueda ser utilizado y ocupa 4 bytes de memoria. Un puntero se declara de acuerdo con la siguiente sintaxis:</p>
                <table border="1" CELLPADDING=5 CELLSPACING=0>
                  <tr VALIGN=top><td><b> Sintaxis:</b><p>
                    <font face="Consolas">Tipo_de_Dato *Nombre_del_Puntero;</font>
                  </p></tr>
                </table><br>
                <table>
                  <tr><td><font face="Consolas">Tipo_de_Dato</font></td><td>Tipo de dato definido por el lenguaje C/C++.</td></tr>
                  <tr><td>*</td><td>Operador de indirección, que indica que se creó un puntero.</td></tr>
                  <tr><td><font face="Consolas">Nombre_del_Puntero</font></td><td>Identificador que indica el nombre del puntero</td></tr>
                </table><br>

                <table border="1" CELLPADDING=5 CELLSPACING=0>
                  <tr VALIGN=top><td width="50"><b> Nota:</b></td><td>  
                    Un puntero permite manipular la variable a la cual apunta, por lo tanto, puede ser utilizado para modificar el valor de la variable apuntada, para realizar operaciones de lectura y diferentes cálculos.
                  </td></tr>
                </table><br>
                <p>A continuación, se presentan algunos ejemplos que muestran la creación de punteros que apuntan a variables:</p>

                <p><font color="green">// Variables</font></p>
                <p><font face="Consolas" color="blue">int </font><font face="Consolas">c = 7;</font></p>
                <p><font face="Consolas" color="blue">char </font><font face="Consolas">letra = </font><font face="Consolas" color="red">'M' </font><font face="Consolas">; </font></p>
                <p><font face="Consolas" color="blue">bool </font><font face="Consolas">veracidad = </font><font face="Consolas" color="blue">true </font><font face="Consolas">; </font></p>
                <p><font face="Consolas" color="blue">float </font><font face="Consolas">ex = exp(2.0);</font></p>
               <br>
               <p><font color="green">// Punteros que apuntan a variables</font></p>
                <p><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr; ptr = &amp;c;</font></p>
                <p><font face="Consolas" color="blue">char </font><font face="Consolas">*ptr; = ptr = &amp;letra; </font>/p>
                <p><font face="Consolas" color="blue">bool </font><font face="Consolas">*ptr; = ptr = &amp;veracidad; </font></p>
                <p><font face="Consolas" color="blue">float </font><font face="Consolas">*ptr; = ptr = &amp;ex;</font></p>
                <br>
                <p>También, se puede hacer que en una sola instrucción se realice la declaración e inicialización de un puntero, como se indica a continuación:</p>
                <p><font color="green">// Punteros que apuntan a variables</font></p>
                 <p><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr = &amp;c;</font></p>
                 <p><font face="Consolas" color="blue">char </font><font face="Consolas">*ptr = &amp;letra; </font>/p>
                 <p><font face="Consolas" color="blue">bool </font><font face="Consolas">*ptr = &amp;veracidad; </font></p>
                 <p><font face="Consolas" color="blue">float </font><font face="Consolas">*ptr = &amp;ex;</font></p>
               
              </ng-template>
            </mat-tab>
            <mat-tab  label="3.4.1. El Operador de Dirección (&)">
              <ng-template matTabContent>
                <br><h1>El Operador de Dirección (&)</h1>
                <p>El operador de dirección (&) es un operador unario que se utiliza tanto para almacenar la dirección de memoria de una variable, así como también para devolver la dirección de memoria de su operando (Davies, P., 1995). Por ejemplo, considerando las siguientes instrucciones: </p>
              <ol type="a">
                <li><font face="Consolas" color="blue">int </font><font face="Consolas">c = 7;</font></li>
                <li><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr;</font></li>
                <li>ptr = &amp;c;</li>
                <ol type="a">
                  <li>Declaración e inicialización de la variable 'c' con el número ‘7’.</li>
                  <li>El identificador ‘ptr’ es el nombre del puntero. El operador ‘*’ significa que ‘ptr’ es un puntero. El puntero ‘ptr’ puede ser utilizado para apuntar variables de tipo ‘int’ (entero).</li>
                  <li>El puntero ‘ptr’ es un puntero a entero inicializado con la dirección de la variable ‘c’.</li>
                </ol>
              </ol>
              <p>Es muy común declarar y luego inicializar directamente al puntero, con lo que se obtienen las siguientes dos instrucciones en lugar de tres:</p>
              <ol type="a">
                <li><font face="Consolas" color="blue">int </font><font face="Consolas">c = 7;</font></li>
                <li><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr = &amp;c;</font></li>
                <ol type="a">
                  <li>Declaración e inicialización de la variable 'c' con el número ‘7’.</li>
                <li>b.	Se crea un puntero a entero llamado ‘ptr’, utilizando el operador de indirección (*) y luego se lo inicializa con la dirección de la variable ‘c’.</li>  
                </ol>
              </ol>
              </ng-template>
            </mat-tab>

            <mat-tab  label="3.4.2. El Operador de Indirección (*)">
              <ng-template matTabContent>
                <br><h1>El Operador de Indirección (*)</h1>
                <p>De acuerdo con (Davies, P., 1995), el operador de indirección (*) es un operador unario que, a más de ser utilizado como el operador de multiplicación, cumple con otras dos funciones muy importantes:</p>
              <ol type="a">
                <li>Se utiliza para declarar o crear un puntero. Por ejemplo:
                  <p><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr;</font></p>
                </li>
                <li>b.	Se utiliza para devolver una expresión equivalente al valor contenido en la dirección apuntada por un puntero. Esta operación recibe el nombre de “desreferencia” ya que permite que un puntero pueda acceder y modificar el valor contenido actual de la variable apuntada por dicho puntero, por lo que se dice que el puntero está desreferenciado. Por ejemplo:
                  <p><font face="Consolas">*ptr = 70;</font></p>
                  <p>En esta instrucción se asigna al contenido de lo que apunta el puntero 'ptr' el valor de 70, utilizando el operador de indirección (*). Debido a que el puntero 'ptr' apunta a una variable, puede modificar el contenido de esa variable, utilizando el operador de indirección (*).</p>
                </li>
              </ol>
              
              
              </ng-template>
            </mat-tab>

            <mat-tab  label="3.4.3. El 'rvalue' y el 'lvalue' de una Variable y de un Puntero">
              <ng-template matTabContent>
                <br><h1>El 'rvalue' y el 'lvalue' de una Variable y de un Puntero</h1>
              <p>De acuerdo con (Davies, P., 1995), cuando en el lenguaje C/C++ se trabajan con variables y punteros se puede hablar del <font face="Consolas">'rvalue'</font> y del <font face="Consolas">'lvalue'</font> de una variable.</p>
                <ol type="a">
                  <li>El <font face="Consolas">'lvalue'</font> de una variable es la dirección de memoria (localidad) donde la variable está almacenada.</li>
                  <li>El <font face="Consolas">'rvalue'</font> de una variable es el dato (contenido real) que la variable tiene. En otras palabras, es el valor de la variable.</li>
                </ol>
            <p>Como se habló en la sección 1.4. la dirección de memoria donde se ubica una variable se representa en formato hexadecimal (hex). Por cuestiones didácticas vamos a utilizar valores en formato decimal (dec) para representar las direcciones de memoria de las variables.</p>
            <p>Considerando las siguientes dos instrucciones explicadas anteriormente, vamos a analizar el <font face="Consolas">'rvalue'</font> y el <font face="Consolas">'lvalue'</font> de cada una de las variables:</p>
            <p><font face="Consolas" color="blue">int </font><font face="Consolas">c = 7;</font></p>
            <p><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr = &amp;c;</font></p>
            <li>La variable ‘c’ tiene un rvalue igual a 7 y reside en la dirección de memoria o lvalue igual a hex 1000.</li>
                <li>El puntero ‘ptr’ reside en la dirección de memoria o lvalue igual a hex 3000 y en su rvalue tiene asignado la dirección de memoria de la variable ‘c’ que es igual a hex 1000.</li>
                <p>A continuación, se presenta en la Figura 3.5. el diagrama de bloques de los valores reales (rvalues) y de las localidades de la memoria (lvalues) de la variable ‘c’ y del puntero ‘ptr’.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.5.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 3.5. </b>Diagrama de Bloques de los <font face="Consolas">'rvalue'</font> y <font face="Consolas">'lvalue'</font> de las variables.</h5>
      <p>En la Figura 3.6. se presenta el mapa de la memoria RAM de la variable ‘c’ y del puntero ‘ptr’.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.6.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 3.6. </b>Mapa de la memoria RAM.</h5>
              <p>Como se puede ver en el mapa de la memoria RAM la variable ‘c’ de tipo entero ocupa 2 bytes de memoria desde la dirección 1000 a la dirección 1002. El puntero ‘ptr’ en cambio ocupa 4 bytes de memoria desde la dirección 3000 a la dirección 3004 y apunta a la variable ‘c’.</p>
                <p>El número de bytes que necesita una variable de tipo puntero (apuntador) no depende del tipo de dato al que apunta, por lo que un puntero siempre necesitará 4 bytes de memoria en plataformas de 32 bits, en cambio en plataformas de 64 bits ocupará 8 bytes de memoria y en plataformas de 16 bits ocupará 2 bytes de memoria.</p>
                <h4><b>Ejercicio 3.12: </b>Escribir un programa donde se crea una variable con el valor de 7 y a continuación se crea un puntero que apunta a esa variable. Luego, imprimir el valor de la variable y el contenido de lo que apunta el puntero. Después, modificar el contenido de lo que apunta el puntero con el número 70. Finalmente, imprimir nuevamente el contenido de la variable y el contenido de lo que apunta el puntero:</h4>
                <h5><b>Programa 3.12: </b>Programa con referencias, utilizando la declaración y la definición de una referencia.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_12"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.12 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.12.png" style="display:block; margin:auto; "><br>
                <p>Como se puede ver en el programa 3.11, al apuntar el puntero ‘ptr’ a la variable ‘c’, este puntero puede acceder a la variable ‘c’ y modificar el contenido de la misma. El momento en que el puntero ‘ptr’ modifica el contenido de la variable ‘c’, la variable ‘c’ tiene un nuevo valor. En la Figura 3.12.1, se muestra el mapa de la memoria RAM de este programa. </p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.12.1.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.12.1. </b>Mapa de la memoria RAM.</h5>
                <p>En la Figura 3.12.2, se muestra el diagrama de bloques de los valores ‘rvalues’ y ‘lvalues’ de este programa, donde se pude ver claramente que el puntero ‘ptr’ modifica el contenido de la variable ‘c’.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.12.2.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.12.2. </b>Mapa de la memoria RAM.</h5>              
              </ng-template>
            </mat-tab>

            <mat-tab  label="3.4.4.   Paso de Parámetros por Dirección o Punteros">
              <ng-template matTabContent>
                <br><h1>Paso de Parámetros por Dirección o Punteros</h1>
                <p>Se pueden retornar múltiples valores con punteros, por lo que los punteros permiten manipular las variables a las cuales apuntan, lo que se conoce como paso de parámetros por dirección o por punteros (Davies, P., 1995). En esta sección se realizarán algunos ejercicios para realizar operaciones de lectura y cálculos matemáticos para modificar los valores de las variables originales utilizando punteros.</p>
                <h4><b>Ejercicio 3.13: </b>Escribir un programa con funciones y punteros que permita invertir dos números utilizando una variable auxiliar. Los prototipos de las funciones son:</h4>
                <p><font face="Consolas" color="blue">void </font><font face="Consolas">LeerDatos(</font><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr_x, </font><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr_y); </font></p>
                <p><font face="Consolas" color="blue">void </font><font face="Consolas">Invertir(</font><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr_x, </font><font face="Consolas" color="blue">int </font><font face="Consolas">*ptr_y); </font></p>
                <p><font face="Consolas" color="blue">void </font><font face="Consolas">ImprimirDatos(</font><font face="Consolas" color="blue">int </font><font face="Consolas">x, </font><font face="Consolas" color="blue">int </font><font face="Consolas">y); </font></p>
               <br> 
               <ol type="a">
                <li>El programa utilizará la función LeerDatos(), que permitirá leer dos valores enteros utilizando 2 punteros para manipular las variables. </li>
                <li>El programa utilizará la función Invertir(), que permitirá invertir dos valores numéricos utilizando 2 punteros y una variable auxiliar.</li>
                <li>El programa utilizará la función ImprimirDatos(), que permitirá imprimir dos valores numéricos, utilizando paso de parámetros por valor o por copia.</li>
               </ol>
               
                <h5><b>Programa 3.13: </b>Programa con referencias, utilizando la declaración y la definición de una referencia.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_13"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.13 </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.13.png" style="display:block; margin:auto; "><br>
                    <p>Como se puede ver en el programa 3.13, se implementaron dos funciones que utilizan el paso de parámetros por dirección (punteros): a) 
                    <font face="Consolas" color="blue">void</font> LeerDatos(
                      <font face="Consolas" color="blue">int </font>&x, 
                      <font face="Consolas" color="blue">int </font>&y); b) 
                      <font face="Consolas" color="blue">void </font> Invertir(
                        <font face="Consolas" color="blue">int </font>&x, 
                        <font face="Consolas" color="blue">int </font>&y); y se implementó una función que utiliza el paso de parámetros por valor: a) 
                        <font face="Consolas" color="blue">void </font> ImprimirDatos(
                    <font face="Consolas" color="blue">int </font>x,   
                    <font face="Consolas" color="blue">int </font>y).</p>
              
            <br>
                <br><h2>3.13.1.  Función <font face="Consolas">LeerDatos()</font></h2>
                <p>La Figura 3.13.1 muestra cómo trabaja la función ‘LeerDatos()’, luego de ser declarada y definida. La llamada a la función ‘LeerDatos()’ envía dos argumentos por dirección a los parámetros (punteros) de la función, la misma que cumple con las tareas de lectura de datos y no retorna ningún valor.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.13.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.13. </b>Llamada a la función con parámetros y retorno de un void.</h5>
              <p>En la Figura 3.13.1 se presenta el mapa de la memoria RAM de la función ‘LeerDatos()’, antes de que los punteros modifiquen los valores contenidos en las variables ‘a’ y ‘b’.</p>
              <img src="./assets/images/Capitulos/III/media/Figura 3.13.1.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.13.1. </b>Mapa de la memoria RAM antes de modificar los valores de las variables.</h5>
              <p>En la Figura 3.13.2 se presenta el mapa de la memoria RAM de la función ‘LeerDatos()’, después de que los punteros modifican los valores contenidos en las variables ‘a’ y ‘b’, donde cada puntero accede al contenido de cada variable utilizando el operador de indirección (*).</p>
              <img src="./assets/images/Capitulos/III/media/Figura 3.13.2.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.13.2. </b>Mapa de la memoria RAM antes de modificar los valores de las variables.</h5>
              <img src="./assets/images/Capitulos/III/media/Figura 3.13.3.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.13.3. </b>Llamada a la función con parámetros y retorno de un void.</h5>
                <br><h2>3.13.2.  Función <font face="Consolas">ImprimirDatos()</font></h2>
                <p>La Figura 3.13.3 muestra cómo trabaja la función ‘ImprimirDatos()’, luego de ser declarada y definida. La llamada a la función ‘ImprimirDatos()’ envía dos argumentos por valor a los parámetros de la función, la misma que cumple con las tareas de impresión de datos y no retorna ningún valor. En este caso la función ‘ImprimirDatos()’, imprime los valores de los números originales antes de ser invertidos.</p>
                <p>En la Figura 3.13.4 se presenta el mapa de la memoria RAM de la función ‘ImprimirDatos()’, donde las variables ‘x’ e ‘y’ reciben los valores por copia de las variables ‘a’ y ‘b’.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.13.4.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.13.4. </b>Mapa de la memoria RAM de la función ‘ImprimirDatos()’.</h5>
              <p>La Figura 3.13.5 muestra el proceso de impresión de los valores de los números invertidos, para lo cual se llama a la función ‘ImprimirDatos()’ la misma que envía dos argumentos por valor a los parámetros de la función.</p>
              <img src="./assets/images/Capitulos/III/media/Figura 3.13.5.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.13.5. </b>Llamada a la función con parámetros y retorno de un void.</h5>
                <p>En la Figura 3.13.6 se presenta el mapa de la memoria RAM de la función ‘ImprimirDatos()’, donde las variables ‘x’ e ‘y’ reciben los valores por copia de las variables ‘a’ y ‘b’.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.13.6.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 3.13.6. </b>Mapa de la memoria RAM de la función ‘ImprimirDatos()’.</h5>
                
                <br><h2>3.13.3.  Función <font face="Consolas">InvertirDatos()</font></h2>
              <p>La Figura 3.13.7 muestra cómo trabaja la función ‘InvertirDatos()’, luego de ser declarada y definida. La llamada a la función ‘InvertirDatos()’ envía dos argumentos por dirección a los parámetros (punteros) de la función, la misma que cumple con la tarea de invertir los datos y no retorna ningún valor.</p>
              <img src="./assets/images/Capitulos/III/media/Figura 3.13.7.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 3.13.7. </b>Llamada a la función con parámetros y retorno de un void.</h5>
                <p>En la Figura 3.13.8 se presenta el mapa de la memoria RAM de la función ‘InvertirDatos()’, antes de que los punteros modifiquen los valores contenidos en las variables ‘a’ y ‘b’, con la ayuda de la variable ‘temp’.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.13.8.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 3.13.8. </b>Mapa de la memoria RAM antes de modificar los valores de las variables.</h5>
                <p>En la Figura 3.13.9 se presenta el mapa de la memoria RAM de la función ‘InvertirDatos()’, después de que los punteros modifican los valores contenidos en las variables ‘a’ y ‘b’, con la ayuda de la variable ‘temp’, donde cada puntero accede al contenido de cada variable utilizando el operador de indirección (*).</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.13.9.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 3.13.9. </b>Mapa de la memoria RAM antes de modificar los valores de las variables.</h5>
                <h4><b>Ejercicio 3.14: </b>Escribir un programa con funciones y punteros que permita ordenar tres números flotantes tomados de dos en dos. Los prototipos de las funciones son</h4>
                <p><font face="Consolas" color="blue">void </font><font face="Consolas">LeerDatos(</font><font face="Consolas" color="blue">float</font><font face="Consolas">* ptr_n1, </font><font face="Consolas" color="blue">float</font><font face="Consolas">* ptr_n2, </font><font face="Consolas" color="blue">float</font><font face="Consolas">* ptr_n3); </font></p>
                <p><font face="Consolas" color="blue">void </font><font face="Consolas">Ordenar(</font><font face="Consolas" color="blue">float</font><font face="Consolas">* pmenor, </font><font face="Consolas" color="blue">float </font><font face="Consolas">* pmayor); </font></p>
                <p><font face="Consolas" color="blue">void </font><font face="Consolas">ImprimirDatos( </font><font face="Consolas" color="blue">float </font><font face="Consolas">n1, </font><font face="Consolas" color="blue">float </font><font face="Consolas">n2, </font><font face="Consolas" color="blue">float</font><font face="Consolas">n3); </font></p>
               <ol type="a">
                 <li>El programa utilizará la función LeerDatos(), que permitirá leer 3 valores enteros utilizando 3 punteros para manipular las variables. </li>
                  <li>El programa utilizará la función Ordenar(), que permitirá ordenar números de dos en dos utilizando 2 punteros y una variable auxiliar.</li>
                <li>El programa utilizará la función ImprimirDatos(), que permitirá imprimir 3 valores numéricos, utilizando paso de parámetros por valor o por copia.</li>
                </ol>
                <h5><b>Programa 3.14: </b>Programa con referencias, utilizando la declaración y la definición de una referencia.</h5>
                    <pre><code [highlight]="prefTabs3[0].programa3_14"  [lineNumbers]="true"></code></pre>
                   <br> <h5><b>Ejecución 3.14: </b>Salida del programa.</h5>
                    <img src="./assets/images/Capitulos/III/media/Ejecucion 3.14.png" style="display:block; margin:auto; "><br>
                    <p>Como se puede ver en el programa 3.14, se implementaron dos funciones que utilizan el paso de parámetros por dirección: a) 
                      <font face="Consolas" color="blue">void</font> LeerDatos(
                        <font face="Consolas" color="blue">float </font>* ptr_n1, 
                        <font face="Consolas" color="blue">float </font>* ptr_n2,
                        <font face="Consolas" color="blue">float </font>* ptr_n3); b) 
                        <font face="Consolas" color="blue">void </font> Ordenar(
                          <font face="Consolas" color="blue">float </font>* pmenor, 
                          <font face="Consolas" color="blue">float </font>* pmayor); y se implementó una función que utiliza el paso de parámetros por valor: a) 
                          <font face="Consolas" color="blue">void </font> ImprimirDatos(
                      <font face="Consolas" color="blue">float </font>n1, 
                      <font face="Consolas" color="blue">float </font>n2,  
                      <font face="Consolas" color="blue">int </font>n3).</p>

              </ng-template>
            </mat-tab>
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Aplicaciones de Funciones Matemáticas">
        <ng-template matTabContent>
           <mat-tab-group>
            <!-- <mat-tab *ngFor="let tab of asyncTabs | async"> -->
            <mat-tab  label="Introducción">
              <ng-template matTabContent>
                <br><h1>Aplicaciones de Funciones Matemáticas</h1>
          <p>Así, como existe una gran variedad de funciones matemáticas en la librería de Encabezado de Funciones Matemáticas (Math Library Header), como se mencionó en la sección 1.2.1 y luego se aplicó varias de estas funciones en la resolución de problemas como se puede ver en la sección 1.8.1, este número de funciones son limitadas, por lo que se pueden crear librerías propias de funciones matemáticas aplicadas a la vida real y a otras áreas de las ciencias del saber. </p>
          <p>Uno de los conceptos más importantes en las Matemáticas es la función, ya que se puede aplicar en numerosas situaciones de la vida cotidiana y determinar las relaciones que existen entre magnitudes tanto en Matemáticas, Física, Química, Biología, Economía, etc., y poder calcular el valor de una de ellas en función de otras de las que depende (Ballester, S., 2009).</p>
          <p>El famoso matemático Euler fue el primero en emplear la expresión y = f(x) para representar una función ‘f’ asociada a un valor ‘x’. Con esta representación que es empleada hoy en el Cálculo Diferencial e Integral, se comenzó a utilizar el concepto de función en las Matemáticas.</p>
          <p>En esta sección se presentarán algunas funciones aplicadas a varias áreas del saber tales como: Cinemática, Dinámica, Energía, Química, Acústica, Economía, Termodinámica y Física Clásica. </p>
         
              </ng-template>
            </mat-tab>
            <mat-tab  label="Caso de Estudio 3.1">
              <ng-template matTabContent>
                <br><h1><b>Caso de Estudio 3.1: Encontrar la distancia, tiempo de vuelo y la altura alcanzada por un proyectil.</b></h1>
               <h2><b>A) Problema</b></h2>
              <p>Escribir un programa para calcular e imprimir la distancia ‘d’, el tiempo de vuelo ‘t’ y la altura ‘h’ alcanzada por un proyectil que es disparado con un ángulo θ (‘theta’) en grados con respecto a la horizontal y a una velocidad inicial ‘v’ en m/seg. La trayectoria parabólica del proyectil se muestra en la Figura 3.1.1 y cuyas fórmulas son las siguientes:</p>
              <img src="./assets/images/Capitulos/III/media/Figura 3.1.1.png" style="display:block; margin:auto; "><br>
              <h5 style="text-align:center"><b>Figura 3.1.1. </b>Tiro Parabólico de un Proyectil.</h5>
 
              <h2><b>B) Análisis</b></h2>
              <p>Claramente, se puede ver que las entradas del problema son la velocidad inicial de lanzamiento del proyectil y el ángulo de lanzamiento theta en grados. Hay tres salidas requeridas: el tiempo de vuelo, la distancia y la altura alcanzada por un proyectil. Partiendo de un conocimiento básico de Física, se sabe que hay una relación entre la velocidad y el ángulo de lanzamiento con la distancia, el tiempo de vuelo y la altura. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
              
	          <h3><b>B.1) Requerimiento de los Datos</b></h3>
            <p><b>Constante del Problema</b></p>
           <p>PI + 3.141596</p>
            <p>g = 9.8</p>          
           <br> 
            <p><b>Entradas del Programa</b></p>		
	          	<table>
                  <tr><td width="200"> v </td><td width="200">/* velocidad de lanzamiento */</td></tr>
                  <tr><td>theta</td><td>/* ángulo de lanzamiento */</td></tr>
                </table><br>
                <p><b>Salidas del Problema</b></p>
                <table>
                  <tr><td width="200"> d </td><td width="400">/* distancia alcanzada por el proyectil */</td></tr>
                  <tr><td width="200"> t </td><td width="400">/* tiempo de vuelo */</td></tr>
                  <tr><td width="200"> h </td><td width="400">/* altura alcanzada por el proyectil */</td></tr>
                </table><br>
		
                <p><b>Fórmulas Relevantes</b></p>
                <table>
		<tr><td ><i>d = (<sup>v<sup>2</sup>∙sen(2θ)</sup>) / <sub>g</sub></i></td><td> (1) </td><td>/* Fórmula de la distancia alcanzada por el proyectil */</td></tr>
                <tr><td width="120"><i>d = (<sup>v∙sen(2θ)</sup>) / <sub>g</sub></i></td><td width="30"> (2) </td><td width="400">/* Fórmula del tiempo de vuelo del proyectil */</td></tr>
                  <tr><td ><i>d = (<sup>v<sup>2</sup>∙sen<sup>2</sup> (2θ)</sup>) / <sub>2g</sub></i></td><td> (3) </td><td>/* Fórmula de la altura alcanzada por el proyectil */</td></tr>
                </table> <br>

                <h3><b>B.2) Diagrama de Entrada-Salida</b></h3>
                <p>En la Figura 3.1.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘v’ (velocidad) y la variable ‘theta’ (ángulo); b) Salidas: las variables ‘d’ (distancia), ‘t’ (tiempo) y ‘h’ (altura); c) Auxiliares: la constante ‘PI’ y la constante ‘g’ (gravedad).</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.1.2.png" style="display:block; margin:auto; "><br>
                <h5 style="text-align:center"><b>Figura 3.1.2. </b>Diagrama de Entrada-Salida del Programa.</h5>
                <h2><b>C) Diseño</b></h2>
                <p>Una vez que se conocen las entradas, las auxiliares y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
                <h3><b>C.1) Algoritmos</b></h3>
                <p><b>Algoritmo de la Función <font face="Consolas">ImprimirMensajeInformacion()</font></b></p>
                <ol type="1">
                  <li>Imprimir el mensaje de información: <font face="Consolas" color="red">“Tiro Parabólico de un Proyectil.”</font>.</li>
                  <li>Imprimir dos saltos de línea (INTRO).</li>
                </ol>
                <p><b>Algoritmo de la Función <font face="Consolas">LeerDatos()</font></b></p>
                <ol type="1">
                  <li>Leer el valor de la velocidad en m/seg, utilizando la referencia ‘v’.</li>
                  <li>Leer el valor del ángulo theta en grados, utilizando la referencia ‘theta’.</li>
                </ol>
                <p><b>Algoritmo de la Función <font face="Consolas">ConvertirGradosARadianes()</font></b></p>
                <ol type="1">
                  <li>Convertir el ángulo theta de grados a radianes.</li>
                  <ol type="1">
                    <li>1.	Asignar a la variable ‘theta’ el valor que retorna la función ConvertirGradosARadianes(), que es el producto del ángulo ‘theta’ por la constante PI y dividido para el valor de 180 grados.</li>
                  </ol>
                </ol>
                <p><b>Algoritmo de la Función <font face="Consolas">Distancia()</font></b></p>
                <ol type="1">
                  <li>Calcular la distancia alcanzada por el proyectil.</li>
                  <ol type="1">
                    <li>1.	Asignar a la variable ‘d’ (distancia) el valor que retorna la función Distancia(), que es el valor que contempla la fórmula de la distancia (1), según la Física Clásica.</li>
                  </ol>
                </ol>
                <p><b>Algoritmo de la Función <font face="Consolas">Tiempo()</font></b></p>
                <ol type="1">
                  <li>Calcular el tiempo de vuelo del proyectil.</li>
                  <ol type="1">
                    <li>1.	Asignar a la variable ‘t’ (tiempo) el valor que retorna la función Tiempo(), que es el valor que contempla la fórmula del tiempo de vuelo (2), según la Física Clásica.</li>
                  </ol>
                </ol>
                <p><b>Algoritmo de la Función <font face="Consolas">Altura()</font></b></p>
                <ol type="1">
                  <li>Calcular la altura alcanzada por el proyectil.</li>
                  <ol type="1">
                    <li>1.	Asignar a la variable ‘h’ (altura) el valor que retorna la función Altura(), que es el valor que contempla la fórmula de la altura (3), según la Física Clásica.</li>
                  </ol>
                </ol>
                <p><b>Algoritmo de la Función <font face="Consolas">ImprimirDatos()</font></b></p>
                <ol type="1">
                  <li>Imprimir los valores de la variable ‘d’ (distancia), de la variable ‘t’ (tiempo) y de la variable ‘h’ (altura).</li>
                </ol>
                <p><b>Algoritmo de la Función <font face="Consolas">main()</font></b></p>
                <ol type="1">
                  <li>Llamada a la función ImprimirMensajeInformacion().</li>
                  <li>Llamada a la función LeerDatos().</li>
                  <li>Asignar a la variable ‘theta’ el valor que retorna la función <font face="Consolas">ConvertirGradosARadianes()</font>.</li>
                  <li>Asignar a la variable ‘d’ el valor que retorna la función <font face="Consolas">Distancia()</font>.</li>
                  <li>Asignar a la variable ‘t’ el valor que retorna la función <font face="Consolas">Tiempo()</font>.</li>
                  <li>Asignar a la variable ‘h’ el valor que retorna la función <font face="Consolas">Altura()</font>.</li>
                  <li>Imprimir un salto de línea (INTRO).</li>
                  <li>Llamada a la función <font face="Consolas">ImprimirDatos()</font>.</li>
                </ol>
                <h2><b>D) Implementación</b></h2>
                <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 3.1.1 se muestra el código del programa en C/C++.</p>
                <h5><b>Tabla 3.1.1. </b>Programa que calcula la distancia, tiempo de vuelo y la altura alcanzada por un proyectil.</h5>
                <pre><code [highlight]="prefTabs3[0].Tabla3_1_1"  [lineNumbers]="true"></code></pre> <br>
                <h3><b>D.1.) Explicación de las Funciones</b></h3>
                <p><b>3.1.9. Función <font face="Consolas">ImprimirMensajeInformacion()</font></b></p>
                <p>La Figura 3.1.3 muestra cómo trabaja la función ‘ImprimirMensajeInformacion()’, luego de ser declarada y definida. La llamada a la función ‘ImprimirMensajeInformacion()’ no envía argumentos a la función, pero cumple con la tarea de imprimir el mensaje de información:
                  <font face="Consolas" color="red">"Tiro Parabólico de un Proyectil."</font>, e imprime dos saltos de línea y no retorna ningún valor.</p>
                  <img src="./assets/images/Capitulos/III/media/Figura 3.1.3.png" style="display:block; margin:auto; "><br>
                  <h5 style="text-align:center"><b>Figura 3.1.3. </b>Llamada a la función sin parámetros y retorno de un void.</h5>
                  <p><b>3.1.10. Función <font face="Consolas">LeerDatos()</font></b></p>
                <p>La Figura 3.1.4 muestra cómo trabaja la función ‘LeerDatos()’, luego de ser declarada y definida. La llamada a la función ‘LeerDatos()’ envía dos argumentos a los parámetros de la función que son dos referencias, la misma que cumple con las tareas de lectura de datos y no retorna ningún valor.</p>
                   <img src="./assets/images/Capitulos/III/media/Figura 3.1.4.png" style="display:block; margin:auto; "><br>
                  <h5 style="text-align:center"><b>Figura 3.1.4. </b>Llamada a la función con dos parámetros y retorno de un void.</h5>
                  
                  <p><b>3.1.11. Función <font face="Consolas">ConvertirGradosARadianes()</font></b></p>
                <p>La Figura 3.1.5 muestra cómo trabaja la función ‘ConvertirGradosARadianes()’, luego de ser declarada y definida. La llamada a la función ‘ConvertirGradosARadianes()’ envía un argumento por valor al parámetro de la función, la misma que cumple con la tarea de convertir un valor dado en grados a radianes y retorna ese valor calculado.</p>  
                <img src="./assets/images/Capitulos/III/media/Figura 3.1.5.png" style="display:block; margin:auto; "><br>
                  <h5 style="text-align:center"><b>Figura 3.1.5. </b>Llamada a la función con un parámetro y retorno de un valor.</h5>
                  
                  <p><b>3.1.12. Función <font face="Consolas">Distancia()</font></b></p>
                <p>La Figura 3.1.6 muestra cómo trabaja la función ‘Distancia()’, luego de ser declarada y definida. La llamada a la función ‘Distancia()’ envía dos argumentos por valor a los parámetros de la función, la misma que cumple con la tarea de calcular la distancia recorrida por un proyectil y retorna ese valor calculado.</p>
                <img src="./assets/images/Capitulos/III/media/Figura 3.1.6.png" style="display:block; margin:auto; "><br>
                  <h5 style="text-align:center"><b>Figura 3.1.6. </b>Llamada a la función con dos parámetros y retorno de un valor.</h5>
                  
                  <p><b>3.1.13. Función <font face="Consolas">Tiempo()</font></b></p>
                  <p>La Figura 3.1.7 muestra cómo trabaja la función ‘Tiempo()’, luego de ser declarada y definida. La llamada a la función ‘Tiempo()’ envía dos argumentos por valor a los parámetros de la función, la misma que cumple con la tarea de calcular el tiempo de vuelo de un proyectil y retorna ese valor calculado.</p>
                  <img src="./assets/images/Capitulos/III/media/Figura 3.1.7.png" style="display:block; margin:auto; "><br>
                    <h5 style="text-align:center"><b>Figura 3.1.7. </b>Llamada a la función con dos parámetros y retorno de un valor.</h5>
                    
                    <p><b>3.1.14. Función <font face="Consolas">Altura()</font></b></p>
                    <p>La Figura 3.1.8 muestra cómo trabaja la función ‘Altura()’, luego de ser declarada y definida. La llamada a la función ‘Altura()’ envía dos argumentos por valor a los parámetros de la función, la misma que cumple con la tarea de calcular la altura alcanzada por un proyectil y retorna ese valor calculado.</p>
                    <img src="./assets/images/Capitulos/III/media/Figura 3.1.8.png" style="display:block; margin:auto; "><br>
                      <h5 style="text-align:center"><b>Figura 3.1.8. </b>Llamada a la función con dos parámetros y retorno de un valor.</h5>
                    
                  <p><b>3.1.15. Función <font face="Consolas">ImprimirDatos()</font></b></p>
                  <p>La Figura 3.1.9 muestra cómo trabaja la función ‘ImprimirDatos()’, luego de ser declarada y definida. La llamada a la función ‘ImprimirDatos()’ envía tres argumentos por valor a los parámetros de la función, la misma que cumple con las tareas de impresión de datos y no retorna ningún valor. En este caso la función ‘ImprimirDatos()’, imprime los valores de la distancia ‘d’, del tiempo de vuelo ‘t’ y de la altura ‘h’.</p>
                  <img src="./assets/images/Capitulos/III/media/Figura 3.1.9.png" style="display:block; margin:auto; "><br>
                      <h5 style="text-align:center"><b>Figura 3.1.9. </b>Llamada a la función con dos parámetros y retorno de un valor.</h5>
                    
                  <h2>E) Pruebas</h2>
                 <p>En la Tabla 3.1.2 se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora.</p>
	            	<h5><b>Tabla 3.1.2.</b> Salida del programa</h5>
                <img src="./assets/images/Capitulos/III/media/Tabla 3.1.2.png" style="display:block; margin:auto; "><br>
            		                
               
              </ng-template>
            </mat-tab>
            <mat-tab  label="Caso de Estudio 3.2">
              <h3><strong>Caso de Estudio 2.8: Encontrar la aceleración de dos objetos conectados mediante una cuerda. </strong></h3>
              <h4><strong>A)   Problema </strong></h4>
              <p>Escribir un programa para calcular e imprimir la magnitud de la aceleración (‘a’) de dos objetos conectados mediante una cuerda, la tensión (‘T’) en la cuerda y la normal (‘n’) de la masa m_2, donde una bola de masa m_1 y un bloque de masa m_2 se unen mediante una cuerda ligera que pasa sobre una polea sin fricción de masa despreciable, como se muestra en la Figura 2.8.1. El bloque se encuentra sobre un plano inclinado sin fricción de ángulo θ (‘theta’) en grados. A continuación, se presentan las ecuaciones que calculan los elementos solicitados.</p>
              <img src="./assets/images/Capitulos/II/media/a20.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.8.1. </strong>(a) Dos objetos conectados mediante una cuerda ligera sobre una polea sin friccion. (b) Diagrama de cuerpo libre para la bola. (c) Diagrama de cuerpo libre para el bloque (Serway, R., Jewett, J., 2005).</h5>
              
              <h4><strong>B)   Análisis </strong></h4>
              <p>Claramente, se puede ver que las entradas del problema son la masa m_1, la masa m_2 y el ángulo θ (‘theta’) en grados. Hay tres salidas requeridas: la aceleración, la tensión y la normal (‘n’) de la masa m_2. Partiendo de un conocimiento básico de Física, se sabe que hay una relación entre la masa m_1, la masa m_2 y el ángulo θ (‘theta’) del plano inclinado con la acelaración, la tensión y la normal. Las fórmulas requeridas se incluyen en el requerimiento de los datos.</p>
              <h4><strong>B.1)   Requerimiento de los Datos </strong></h4>
              <h4><strong>Constantes del Problema </strong></h4>
              <p>PI = 3.141596</p>
              <p>g = 9.80665</p>
              <h4><strong>Entradas del Problema </strong></h4>
              <p>m1	&nbsp; &nbsp;/* primera masa */ </p>
              <p>m2	&nbsp; &nbsp;/* segunda masa */ </p>
              <p>theta	&nbsp; &nbsp;/* ángulo del plano inclinado */ </p>
              
              <h4><strong>Salidas del Problema </strong></h4>
              <p>a	&nbsp; &nbsp;/* aceleración de dos objetos conectados mediante una cuerda */ </p>
              <p>T	&nbsp; &nbsp;/* tensión en la cuerda */ </p>
              <p>n	&nbsp; &nbsp;/* normal (‘n’) de la masa m_2 */ </p>
              <h4><strong>Formulas Relevantes </strong></h4>
              <img src="./assets/images/Capitulos/II/media/a21.png" style="display:block; margin:auto; "><br>
              <h4><strong>B.2)   Diagrama de Entrada-Salida </strong></h4>
              <p>En la Figura 2.8.2 se muestra el diagrama de Entrada-Salida del programa donde se identifican y se diagraman las entradas, salidas y auxiliares del problema como son: a) Entradas: la variable ‘m1’ (primera masa), la variable ‘m2’ y la variable ‘theta’ (ángulo del plano inclinado); b) Salidas: las variables ‘a’ (aceleración), ‘T’ (tensión) y ‘n’ (normal); c) Auxiliares: la constante ‘PI’ y la constante ‘g’ (gravedad). </p>
              <img src="./assets/images/Capitulos/II/media/a22.png" style="display:block; margin:auto; "><br>
              <h5><strong>Figura 2.8.2. </strong>Diagrama de Entrada-Salida del Programa.</h5>
              <h4><strong>C)   Diseño </strong></h4>
              <p>Una vez que se conoce las entradas y las salidas del problema, se deben listar los pasos necesarios para resolver el problema, es decir, el algoritmo.</p>
              <h4><strong>Algoritmo </strong></h4>
              <p>1.	Imprimir el mensaje de información: “Aceleración de dos objetos conectados mediante una cuerda”</p>
              <p>2.	Leer el valor de la primera masa, utilizando la variable ‘m1’.</p>
              <p>3.	Leer el valor de la segunda masa, utilizando la variable ‘m2’.</p>
              <p>4.	Leer el valor del ángulo theta del plano inclinado en grados, utilizando la variable ‘theta’</p>
              <p>5. Convertir el ángulo theta de grados a radianes.</p>
              <p> &nbsp; &nbsp; 5.1. Asignar a la variable ‘theta’ el producto del ángulo theta por la constante PI y dividirlo para el valor de 180 grados.</p>
                          
              <p>6.	Si la suma entre las masas ‘m1’ y ‘m2’ es diferente de cero.</p>
              <p> &nbsp; &nbsp; 6.1.	Calcular la aceleración de dos objetos conectados mediante una cuerda.</p>
              <p> &nbsp; &nbsp; &nbsp; 6.1.1.	Asignar a la variable ‘a’ (aceleración) los valores que contempla la fórmula de la aceleración (1), según la Física Clásica.</p>
              <p> &nbsp; &nbsp; 6.2.	Calcular la tensión en la cuerda.</p>
              <p> &nbsp; &nbsp; &nbsp; 6.2.1.	Asignar a la variable ‘T’ (tensión) los valores que contempla la fórmula de la tensión (2), según la Física Clásica.</p>
              <p> &nbsp; &nbsp; 6.3.	Calcular el valor de la normal de la masa ‘m2’.</p>
              <p> &nbsp; &nbsp; &nbsp; 6.3.1.	Asignar a la variable ‘n’ (normal) los valores que contempla la fórmula de la normal (3), según la Física Clásica.</p>
              <p> &nbsp; &nbsp; 6.4.	Imprimir el valor de la variable ‘a’ (aceleración), de la variable ‘T’ (tensión) y de la variable ‘n’ (normal).</p>
              <p>7.	Caso contrario, la suma entre las masas m1 y m2 es igual a cero.</p>
              <p> &nbsp; &nbsp; 7.1.	Imprimir el mensaje de error: “Error en el ingreso de los valores de las masas”.</p>
                      
              <h4><strong>D)   Implementación </strong></h4>
              <p>Para implementar la solución, se debe escribir el algoritmo como un programa de C/C++ que contenga toda la información necesaria para completar la traducción a lenguaje máquina. En la Tabla 2.8.1 se muestra el código del programa en C/C++.</p>
              <h5><strong>Tabla 2.8.1. </strong>Programa que calcula la aceleración de dos objetos conectados mediante una cuerda, la tensión y la normal.</h5>
              <pre><code [highlight]="prefTab[0].programa8"  [lineNumbers]="true"></code></pre><br>
              <h4><strong>E) Pruebas </strong></h4>
              <p>En la Tabla 2.8.2 se muestra un ejemplo de la salida del programa, donde se puede ver que los resultados del programa tienen sentido, comparando estos resultados con los datos devueltos por una calculadora científica.</p>
              
              <h5><strong>Tabla 2.8.2. </strong>Salida del programa.</h5>
              <img src="./assets/images/Capitulos/II/media/a23.png" style="display:block; margin:auto; "><br>
            </mat-tab>

            <mat-tab  label="Caso de Estudio 3.3">
              <ng-template matTabContent></ng-template>
            </mat-tab>
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Creación de Menús">
        <ng-template matTabContent>
          <mat-tab-group>

          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="3.7. Archivos de Cabecera">
        <ng-template matTabContent>
          <mat-tab-group>
            <mat-tab  label="Introducción">
              <ng-template matTabContent></ng-template>
            </mat-tab>
            <mat-tab  label="3.7.1. Sentencias de Inclusión (Inclusion Guards)">
              <ng-template matTabContent></ng-template>
            </mat-tab>
            <mat-tab  label="Caso de Estudio 3.4">
              <ng-template matTabContent></ng-template>
            </mat-tab>
            <mat-tab  label="3.7.1. Sentencias de Inclusión (Inclusion Guards)">
              <ng-template matTabContent></ng-template>
            </mat-tab>
          </mat-tab-group>
        </ng-template>
      </mat-tab>

      <mat-tab label="Resumen">
        <ng-template matTabContent>

        </ng-template>
      </mat-tab>
    </mat-tab-group>

    <button mat-button (click)="selectTabNext()" *ngIf="positionCurrentNext">{{titleNext}} <mat-icon>navigate_next</mat-icon></button>
    <button mat-button (click)="selectTabBefore()" *ngIf="positionCurrentBefore"><mat-icon>navigate_before</mat-icon> Atras  &nbsp; &nbsp; &nbsp;&nbsp;</button>

</div>
<!-- Examples
<mat-tab label="Teoría">
  <ng-template matTabContent>
    <br>
    <h1>5.1.   OpenTK</h1>
    <p>OpenTK (Open Toolkit), es un conjunto de APIs gráficas desarrolladas para C#. Estas APIs son portátiles en varios sistemas operativos (OS) y rápidas en el momento de ejecutarse. OpenTK, tiene un conjunto de clases y librerías de bajo nivel para OpenGL, OpenGL ES, OpenAL y OpenCL, ya que parte del core (núcleo) de OpenTK está construido en C/C++. OpenTK, se ejecuta en todas las plataformas principales como Windows, Linux y MAC. Además, potencia el desarrollo de cientos de aplicaciones gráficas, juegos en 2D y 3D y programas de investigación matemática y científica (De Vries, J., Perks, D., 2021).</p>
    <p>OpenTK proporciona varias bibliotecas de utilidades, incluido un paquete de matemáticas y álgebra lineal, un sistema de ventanas y manejo de entrada de datos. OpenTK no es un motor de juegos, ni intenta serlo: ofrece un conjunto útil de herramientas y permite decidir cómo usarlas en diferentes tipos de aplicaciones. Además, es el punto de partida ideal si se desea escribir un juego o un motor de juegos y también una aplicación científica desde cero (De Vries, J., Perks, D., 2021).</p>
    <p>De acuerdo con (De Vries, J., Perks, D., 2021), las principales APIs de OpenTK son:</p>
    <ul>
      <li>OpenTK.Audio.OpenAL</li>
      <li>OpenTK.Compute.Native</li>
      <li>OpenTK.Compute.OpenCL</li>
      <li>OpenTK.Core</li>
      <li>OpenTK.Graphics</li>
      <li>OpenTK.Input.Hid</li>
      <li>OpenTK.Mathematics</li>
      <li>OpenTK.Platform.Windows</li>
    </ul>
    <h1>5.1.1. OpenGL, OpenCL y OpenAL</h1>
    <p>OpenGL es una biblioteca de representación de gráficos por computadora multiplataforma, desarrollada originalmente por Silicon Graphics (SGI) y ahora mantenida por el grupo Khronos. OpenGL se usa para todo, desde videojuegos hasta herramientas CAD, navegadores web y teléfonos móviles.</p>
    <p>OpenCL es una especificación de computación paralela multiplataforma, desarrollada originalmente por Apple y ahora mantenida por el grupo Khronos. Se utiliza principalmente para realizar cálculos en GPU que, de otro modo, se calcularían de forma menos eficiente en CPU, pero también se puede utilizar para controlar procesadores de señales digitales (DSP), matrices de puertas programables en campo (FPGA) y otros tipos de aceleradores de cálculo de hardware.</p>
    <p>OpenAL es una biblioteca de audio 3D multiplataforma, desarrollada originalmente por Loki Software y lanzada como una especificación abierta por Creative Labs, con múltiples implementaciones tanto en hardware como en software. OpenAL se usa en muchos juegos para proporcionar efectos de sonido y música y es el sucesor de EAX y A3D.</p>
    <h1>5.1.2. Clases y Métodos Principales de OpenTK para la Graficación de Figuras Geométricas en 2D y 3D</h1>
    <h1>5.1.2.1.	Class GameWindow</h1>
    <p>La clase GameWindow contiene métodos multiplataforma para crear y renderizar en una ventana OpenGL, manejar la entrada y cargar recursos (Ramos, F., 2014). En la Tabla 5.1, se muestra un ejemplo de código fuente para esta clase, donde se define una ventana de resolución de 500×500, dentro del programa principal (void Main).</p>
    <h5><strong>Tabla 5.1. </strong>Ejemplo de código fuente para la clase GameWindow.</h5><br>
    <pre *ngFor="let formula of introduccion"><code [highlight]="formula.f1" (highlighted)="onHighlight($event)" [lineNumbers]="true"></code></pre><br>
    <h1>5.1.2.2.	Class Game</h1>
    <p>La clase Game contiene métodos para: a) Constructor/es de la clase Game; b) Arrancar una aplicación gráfica; c) Redimensionar una ventana; d) Renderizar los frames de la aplicación gráfica; e) Inicializar la carga de la aplicación gráfica. La estructura básica de la clase Game se muestra en la Tabla 5.2.</p>
    <h5><strong>Tabla 5.2. </strong>Estructura básica de la clase game.</h5><br>
    <pre *ngFor="let formula of introduccion"><code [highlight]="formula.f2" (highlighted)="onHighlight($event)" [lineNumbers]="true"></code></pre><br>
    <p>En los Pracniques resueltos 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8 , 5.9 y 5.10, se muestran algunos ejemplos prácticos de cómo graficar figuras geométricas en 2D y 3D, como se indica a continuación:</p>
    <ul>
      <li>Pracnique 5.1: Triángulo de 3 colores.</li>
      <li>Pracnique 5.2: Cuadrado de 4 colores rotando.</li>
      <li>Pracnique 5.3: Cubo de 6 colores con doble rotación.</li>
      <li>Pracnique 5.4: Dos cubos de diferente tamaño rotando.</li>
      <li>Pracnique 5.5: Un cubo y una pirámide rotando.</li>
      <li>Pracnique 5.6: Cubo manejado por teclado.</li>
      <li>Pracnique 5.7: Cubo con luces.</li>
      <li>Pracnique 5.8: Cubo con textura.</li>
      <li>Pracnique 5.9: Cubo con textura y cuadrado transparente.</li>
      <li>Pracnique 5.10: Cono rotando.</li>
    </ul>
    <p>La estructura de los Pracniques se basa en una adaptación del trabajo de Wirth, M., (2013), para lo cual los autores de este trabajo plantean las siguientes fases para el diseño, desarrollo e implementación de programas enfocados a la Computación Gráfica:              a) Sinopsis; b) Descripción del Problema; c) Geometría de la Figura; d) Algoritmos; e) Código de la Aplicación; f) Pruebas de la Aplicación. </p>
    <p>Los Pracniques resueltos son una adaptación del trabajo de The Pentamollis Project, (2017), que es un canal de YouTube que presenta un Curso Básico de OpenTK con C#, compuesto por 10 video tutoriales. </p>
    <p>El análisis matemático y geométrico tanto 2D como 3D de las diferentes figuras geométricas, fue adaptado de los trabajos de Ammeraal, L., Zhang, K., (2017), Lengyel, E., (2011), Mortenson, M.E., (1999). Este análisis forma parte de la fase de Geometría de la Figura que se implementa en los diferentes pracniques.</p>
  </ng-template>
</mat-tab>
<mat-tab label="Video Tutorial">
  <ng-template matTabContent>
    <br>
    <div class="social-item">
      <h2><b><u>Pracnique 5.3 - Cubo de 6 Colores con Doble Rotación <a href="https://youtu.be/ne2OyOv5Z_4" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></b></h2>
    </div>
    <div class="video-responsive">
      <div class="video-responsive">
        <iframe width="560" height="315" src="https://www.youtube.com/embed/ne2OyOv5Z_4?rel=0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
      </div>
    </div>

    <br>
    <div class="social-item">
      <h2><b><u>Pracnique 5.8 - Cubo con Textura con Rotación Constante <a href="https://youtu.be/RHaH62cmnmc" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></b></h2>
    </div>
    <div class="video-responsive">
      <div class="video-responsive">
        <iframe width="560" height="315" src="https://www.youtube.com/embed/RHaH62cmnmc?rel=0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
      </div>
    </div>

    <br>
    &lt;!&ndash;            <div class="social-item">
                        <h2><b><u>Pracnique 5.10 - Cono con Rotación controlada por Teclado <a href="#" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></b></h2>
                    </div>
                    <div class="video-responsive">
                        <div class="video-responsive">
                            <video controls preload="auto">
                                <source src="https://drive.google.com/uc?export=download&id=1Tq3Vu004_iBChLVLFPoKo2gXWZQAfVXn#t=1" type="video/mp4" />
                                    Tu navegador no soporta HTML5 Video
                                </video>
                        </div>
                    </div>
    &ndash;&gt;                <br>
    <div>
      <h1><b>Curso Completo OpenGL and C# tutorial | The OpenTK Library</b></h1>
      <ul>
        <li><h2><u>Pracnique 5.1 - Triángulo de 3 colores <a href="https://www.youtube.com/watch?v=xBR6ZIJAuXc" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></h2></li>
        <li><h2><u>Pracnique 5.2 - Cuadrado de 4 colores rotando <a href="https://www.youtube.com/watch?v=xBR6ZIJAuXc" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></h2></li>
        <li><h2><u>Pracnique 5.4 - Dos cubos de diferente tamaño rotando <a href="https://www.youtube.com/watch?v=xBR6ZIJAuXc" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></h2></li>
        <li><h2><u>Pracnique 5.5 - Un cubo y una pirámide rotando <a href="https://www.youtube.com/watch?v=xBR6ZIJAuXc" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></h2></li>
        <li><h2><u>Pracnique 5.6 - Cubo manejado por teclado <a href="https://www.youtube.com/watch?v=xBR6ZIJAuXc" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></h2></li>
        <li><h2><u>Pracnique 5.7 - Cubo con luces <a href="https://www.youtube.com/watch?v=xBR6ZIJAuXc" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></h2></li>
        <li><h2><u>Pracnique 5.9 - Cubo con textura y cuadrado transparente <a href="https://www.youtube.com/watch?v=xBR6ZIJAuXc" target="_blank"><img src="https://img.icons8.com/bubbles/100/000000/youtube.png" width="50px" height="50px"/></a></u></h2></li>
      </ul>
    </div>
  </ng-template>
</mat-tab>
<mat-tab label="Pracniques">
  <ng-template matTabContent>
    <mat-tab-group>
      &lt;!&ndash; <mat-tab *ngFor="let tab of asyncTabs | async"> &ndash;&gt;
      <mat-tab *ngFor="let tab of praqnique" label="{{tab.label}}">
        <br>
        <table>
          <tr>
            <td>
              <h2 style="color:green;"><strong>{{tab.tituloN}}</strong></h2>
            </td>
            <td>
              <h2>{{tab.titulo}}</h2>
            </td>
          </tr>
        </table>
        <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
          <TR>
            <TABLE>
              <TR><strong>SINOPSIS</strong></TR>
              <TR>{{tab.sinopsisDescrip}}</TR>
            </TABLE>
          </TR>
          <TR>
            <TABLE BORDER WIDTH="100%" CELLPADDING=1 CELLSPACING=0 class="mat-elevation-z8">
              <TR *ngFor="let item of tab.sinopsis">
                <TD><strong>{{item.titulo}}</strong>{{item.descrip}}</TD>
              </TR>
            </TABLE>
          </TR>
        </TABLE><br>
        <a href="{{tab.link}}" download="ProgramaPracnique">
          <mat-icon>save_alt</mat-icon><strong>Descargar {{tab.tituloN}} PracniqueCompGraf.zip</strong>
        </a>
        <br><br>
        <h3><strong>{{tab.A.subtitulo}}</strong></h3>
        <p>{{tab.A.problema}}</p>
        <img src="{{tab.A.fotoPath}}" style="display:block; margin:auto;"><br>
        <h5><strong>{{tab.A.fotoN}}</strong>{{tab.A.fotoDescrip}}</h5><br>

        <h3><strong>{{tab.B.subtitulo}}</strong></h3>
        <div *ngFor="let itemPasos of tab.B.pasosB">
          <mathjax [content]=itemPasos.parrafo class='box'></mathjax>
          <img src="{{itemPasos.fotoPath}}" style="display:block; margin:auto; ">
          <h5><strong>{{itemPasos.fotoN}}</strong>{{itemPasos.fotoDescrip}}</h5><br>
        </div>

        <h3><strong>{{tab.C.subtitulo}}</strong></h3>
        <dl *ngFor="let itemAlgoritmos of tab.C.algoritmosC">
          <dt>{{itemAlgoritmos.titulo}}</dt>
          <dd>
            <ul *ngFor="let p of itemAlgoritmos.pasos; index as i">
              <div value="{{i+1}}">{{p}}</div>
            </ul>
            <ul *ngFor="let p of itemAlgoritmos.pasosFormulas; index as i">
              <div value="{{i+1}}">{{p}}</div>
            </ul>
          </dd>
        </dl>
        <h3><strong>{{tab.D.subtitulo}}</strong></h3>
        <div *ngFor="let itemCodigos of tab.D.listaCodigo">
          <p>{{itemCodigos.problema}}</p>
          <h5><strong>{{itemCodigos.tablaN}}</strong>{{itemCodigos.tablaDescrip}}</h5><br>
          <pre><code [highlight]="itemCodigos.tablaDatos" (highlighted)="onHighlight($event)" [lineNumbers]="true"></code></pre><br>
        </div>
        <h3><strong>{{tab.E.subtitulo}}</strong></h3>
        <div *ngFor="let item of tab.E.listaPrueba">
          <p>{{item.problema}}</p>
          <img src="{{item.fotoPath}}" style="display:block; margin:auto; width: 30%;"><br>
          <h5><strong>{{item.fotoN}}</strong>{{item.fotoDescrip}}</h5><br>
        </div>
      </mat-tab>
    </mat-tab-group>
  </ng-template>
</mat-tab>
<mat-tab label="Pracniques Propuestos">
  <ng-template matTabContent>
    <mat-tab-group>
      &lt;!&ndash; <mat-tab *ngFor="let tab of asyncTabs | async"> &ndash;&gt;
      <mat-tab *ngFor="let tab of praqniquePropuesto" label="{{tab.label}}">
        <br>
        <table>
          <tr>
            <td>
              <h2 style="color:green;"><strong>{{tab.tituloN}}</strong></h2>
            </td>
            <td>
              <h2>{{tab.titulo}}</h2>
            </td>
          </tr>
        </table>
        <h3><strong>{{tab.subtitulo}}</strong></h3>
        <div *ngFor="let item of tab.listaGeneral">
          <div *ngFor="let i of item.listaParrafoFotos">
            <mathjax [content]=i.problema class='box'></mathjax><br>
            <img src="{{i.fotoPathp1}}" style="display:block; margin:auto; width: 50%;"><br>
            <img src="{{i.fotoPath}}" style="display:block; margin:auto; width: 50%;"><br>
            <h5><strong>{{i.fotoN}}</strong>{{i.fotoDescrip}}</h5><br>
          </div>
        </div>
      </mat-tab>
    </mat-tab-group>
  </ng-template>
</mat-tab>
<mat-tab label="Evaluación">
  <ng-template matTabContent>
    <div class="Evaluacion">
      <app-quiz [propagarNumCapitulo]="num_capitulo"></app-quiz>
    </div>
  </ng-template>
</mat-tab>
<mat-tab label="Juegos">
  <ng-template matTabContent>
    <div class="Snake">
      <app-snake></app-snake>
    </div>
  </ng-template>

</mat-tab>
<mat-tab label="Resumen">
  <ng-template matTabContent>
    <br>
    <h1>Resumen</h1>
    <ul>
      <li>OpenTK (Open Toolkit), es un conjunto de APIs gráficas desarrolladas para C#. Estas APIs son portátiles en varios sistemas operativos (OS) y rápidas en el momento de ejecutarse.</li>
      <li>OpenTK, brinda acceso a herramientas gráficas contenidas en OpenGL, OpenCL y OpenAL, con una variedad de lenguajes basados en CLR como C# y F# entre otros.</li>
      <li>OpenTK proporciona varias bibliotecas de utilidades, incluido un paquete de matemáticas y álgebra lineal, un sistema de ventanas y manejo de entrada de datos. </li>
      <li>Las principales APIs de OpenTK son: a) OpenTK.Audio.OpenAL;                              b) OpenTK.Compute.Native; c) OpenTK.Compute.OpenCL; d) OpenTK.Core;   e) OpenTK.Graphics; f) OpenTK.Input.Hid; g) OpenTK.Mathematics;                      h) OpenTK.Platform.Windows.</li>
      <li>OpenGL es una biblioteca de representación de gráficos por computadora multiplataforma, desarrollada originalmente por Silicon Graphics (SGI) y ahora mantenida por el grupo Khronos.</li>
      <li>OpenCL es una especificación de computación paralela multiplataforma, desarrollada originalmente por Apple y ahora mantenida por el grupo Khronos.</li>
      <li>OpenAL es una biblioteca de audio 3D multiplataforma, desarrollada originalmente por Loki Software y lanzada como una especificación abierta por Creative Labs, con múltiples implementaciones tanto en hardware como en software.</li>
      <li>La clase GameWindow contiene métodos multiplataforma para crear y renderizar en una ventana OpenGL, manejar la entrada y cargar recursos.</li>
      <li>La clase Game contiene métodos para: a) Constructor/es de la clase Game; b) Arrancar una aplicación gráfica; c) Redimensionar una ventana; d) Renderizar los frames de la aplicación gráfica; e) Inicializar la carga de la aplicación gráfica.</li>
    </ul>
  </ng-template>
</mat-tab>
<mat-tab label="Bibliografía">
  <ng-template matTabContent>
    <br>
    <h1>Bibliografía</h1>
    <ul>
      <li>Woo, M., Neider, J., Davis, T., Shreiner, D., 2005. OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 2 (The Red Book). Addison-Wesley, 5th Edition. ISBN-13: 978-0321335739. </li>
      <li>Shreiner, D., 2005. OpenGL: Reference Manual (The Blue Book). Addison-Wesley, 4th Edition. ISBN-13: 978-0321173836.</li>
      <li>Vidani, P., 2021. Silicon Graphics / SGI Vintage Stuff. Blog sgihardware-tumblr. Disponible en: https://sgihardware.tumblr.com/</li>
      <li>Kahle, B., Gilliat, B., 2001. SGI-Newsroom. Wayback Machine. Disponible en: https://web.archive.org/web/*/sgi</li>
      <li>Silicon Graphics-Wikipedia, 2021. Wikipedia. La enciclopedia libre. Fundación Wikimedia. Contenido multimedia bajo Licencia Creative Commons CC-BY-SA, 2001. Disponible en: https://es.wikipedia.org/wiki/Silicon_Graphics </li>
      <li>Tao Framework-Wikipedia, 2021. Wikipedia. La enciclopedia libre. Fundación Wikimedia. Contenido multimedia bajo Licencia Creative Commons CC-BY-SA, 2001. Disponible en: https://en.wikipedia.org/wiki/Tao_Framework </li>
      <li>OpenTK-Wikipedia, 2021. Wikipedia. La enciclopedia libre. Fundación Wikimedia. Contenido multimedia bajo Licencia Creative Commons CC-BY-SA, 2001. Disponible en: https://en.wikipedia.org/wiki/OpenTK </li>
      <li>De Vries, J., Perks, D., 2021. OpenTK. Tutoriales, Recursos, API, GitHub. Disponible en: https://opentk.net/</li>
      <li>The Pentamollis Project, 2017. OpenGL and C# Tutorial. The OpenTK Library. Canal de Youtube. Curso compuesto por 10 videotutoriales. Disponible en: https://www.youtube.com/watch?v=jb_gHLl1dgU&list=PLWzp0Bbyy_3ggUK3XZjBmwnSjhbhJH3kp</li>
      <li>Ramos, F., 2014. Pro OpenGL for C# Developers: High-Performance 2D and 3D Graphics for Deskto´p, Web, iOS and Android. Apress, United States. ISBN: 978-1-4842-0051-3.</li>
      <li>Ammeraal, L., Zhang, K., 2017. Computer Graphics for Java Programmers. Springer. Third Edition.</li>
      <li>Lengyel, E., 2011. Mathematics for 3D Game Programming and Computer Graphics. Charles River Media. Third Edition.</li>
      <li>Mortenson, M.E., 1999. Mathematics for Computer Graphics Applications. Industrial Press, Inc.; Second Edition. ISBN: 978-0831131111.</li>
      <li>Wirth, M., 2013. The Craft of Coding. Musing on Programming. Pracniques (Programming Case Studies). Available in: https://craftofcoding.wordpress.com/pracniques/, last accessed 2021/10/11.</li>
      <li>Kronos Group, 2006. OpenGL Documentation. Copyright © 1991-2006 Silicon Graphics, Inc. Disponible en: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml</li>
      <li>Hock-Chuan, C., 2012. 3D Graphics with OpenGL by Examples. Available in: https://www3.ntu.edu.sg/home/ehchua/programming/opengl/CG_Examples.html </li>
      <li>Korthals Altes, G., 1998. Paper Models of Polyhedra. Available in: https://www.polyhedra.net/es/model.php?name-en=pyramids-of-the-same-height</li>
    </ul>
  </ng-template>
</mat-tab>-->
